===== PROJECT STRUCTURE =====
.
├── db.sqlite3
├── login_required_project
│   ├── __init__.py
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
├── main
│   ├── __init__.py
│   ├── admin.py
│   ├── apps.py
│   ├── event_queue.py
│   ├── forms.py
│   ├── models.py
│   ├── permissions.py
│   ├── serializers.py
│   ├── signals.py
│   ├── templates
│   │   ├── game_board
│   │   │   ├── base.html
│   │   │   ├── board_editor.html
│   │   │   └── board_list.html
│   │   ├── main
│   │   │   ├── base.html
│   │   │   ├── define_grid.html
│   │   │   ├── home.html
│   │   │   ├── login.html
│   │   │   ├── register.html
│   │   │   ├── upload_common_image.html
│   │   │   ├── upload_image.html
│   │   │   └── user_panel.html
│   │   ├── registration
│   │   │   ├── login.html
│   │   │   └── register.html
│   │   └── rest_framework
│   │       └── api.html
│   ├── tests.py
│   ├── urls.py
│   ├── urls_board.py
│   └── views.py
├── manage.py
├── package-lock.json
├── package.json
├── project_dump.txt
├── script.sh
└── tsconfig.json

7 directories, 38 files


===== File: ./login_required_project/urls.py =====
from django.contrib import admin
from django.urls import path, include
from django.contrib.auth import views as auth_views
from django.conf import settings
from django.conf.urls.static import static
from rest_framework.authtoken import views as authtoken_views 
from main import views as main_views

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('main.urls')),
    path('login/', auth_views.LoginView.as_view(template_name='main/login.html'), name='login'),
    path('logout/', auth_views.LogoutView.as_view(), name='logout'),
    path('api/', include('main.urls')),
    path('api-auth/', include('rest_framework.urls', namespace='rest_framework')),
    path('api-token-auth/', authtoken_views.obtain_auth_token, name='api_token_auth'),
    path('board/', include('main.urls_board')),
    path('api/save_grid_as_image/', main_views.save_grid_as_image_view, name='save_grid_as_image_api'), # NEW
    path('sse/notifications/', main_views.sse_notifications_view, name='sse_global_notifications'), # ADD THIS LINE
    path('api/add_reaction/', main_views.add_reaction_view, name='add_reaction_api'),
]

urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

===== File: ./login_required_project/settings.py =====
from pathlib import Path
import os

BASE_DIR = Path(__file__).resolve().parent.parent

SECRET_KEY = 'django-insecure-testkey'

DEBUG = True

ALLOWED_HOSTS = []

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'rest_framework',
    'rest_framework.authtoken',
    'main.apps.MainConfig',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'login_required_project.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [BASE_DIR / 'templates'],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [ 
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'login_required_project.wsgi.application'

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}

AUTH_PASSWORD_VALIDATORS = []

LANGUAGE_CODE = 'en-us'
TIME_ZONE = 'UTC'
USE_I18N = True
USE_TZ = True

STATIC_URL = 'static/'

STATICFILES_DIRS = [
    os.path.join(BASE_DIR, 'static'),
]

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

LOGIN_URL = '/login/'
LOGIN_REDIRECT_URL = '/'
LOGOUT_REDIRECT_URL = '/login/'

MEDIA_URL = '/media/'
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')

REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework.authentication.TokenAuthentication', 
        'rest_framework.authentication.SessionAuthentication', 
        
    ],
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated', 
    ],
}

===== File: ./login_required_project/__init__.py =====


===== File: ./login_required_project/wsgi.py =====
import os
from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'login_required_project.settings')
application = get_wsgi_application()


===== File: ./static/main/css/style.css =====
body {
    font-family: sans-serif;
    margin: 20px;
}
a {
    margin-right: 10px;
}
h2, h3 {
    color: #333;
}
form select, form button, #add-point-on-image-btn, #add-point-on-list-btn {
    padding: 8px;
    margin: 5px 0;
    border-radius: 4px;
    border: 1px solid #ccc;
}
#image-container {
    position: relative;
    display: inline-block;
    border: 1px solid #ddd;
    margin-top: 10px;
    margin-bottom: 10px;
}
.click-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background-color: red;
    position: absolute;
    cursor: move;
    /* Dla lepszego pozycjonowania względem kursora */
    transform: translate(-50%, -50%); 
}
.dot-number {
    position: absolute;
    top: -15px; /* nieco wyżej */
    left: 50%;
    transform: translateX(-50%);
    color: blue; /* zmieniony kolor dla odróżnienia */
    font-weight: bold;
    font-size: 12px;
    text-shadow: 0 0 2px white; /* dla lepszej czytelności na obrazie */
    pointer-events: none;
    user-select: none;
}
.delete-dot-btn {
    position: absolute;
    top: -8px; /* dostosuj pozycję */
    right: -18px; /* dostosuj pozycję */
    background: rgba(255, 255, 255, 0.7);
    border: 1px solid #aaa;
    color: red;
    font-size: 12px; /* mniejszy */
    width: 16px; /* mniejszy */
    height: 16px; /* mniejszy */
    line-height: 14px; /* wyśrodkowanie X */
    text-align: center;
    border-radius: 50%;
    cursor: pointer;
    padding: 0;
}
#connection-lines line {
    stroke-dasharray: 3,3; /* Kreskowane linie */
    stroke-linecap: round;
}
#coordinates-list-container {
    padding: 10px;
    border: 1px solid #ccc;
    border-radius: 5px;
    background-color: #f9f9f9;
    max-width: 400px; /* Ograniczenie szerokości */
}
#coordinates-list {
    list-style-type: none;
    padding-left: 0;
}
#coordinates-list li {
    padding: 8px 0;
    border-bottom: 1px dashed #eee;
    display: flex; /* Dla lepszego ułożenia elementów */
    align-items: center; /* Wyśrodkowanie w pionie */
}
#coordinates-list li:last-child {
    border-bottom: none;
}
.coordinate-item input[type="number"] {
    margin: 0 5px;
    padding: 4px;
    border: 1px solid #ccc;
    border-radius: 3px;
    width: 70px; /* nieco szersze */
}
.coordinate-item button {
    margin-left: 8px;
    padding: 4px 8px;
    font-size: 12px;
    border-radius: 3px;
    cursor: pointer;
}
.update-coord-btn {
    background-color: #e0e0e0;
    border: 1px solid #aaa;
}
.delete-coord-btn {
    background-color: #fdd;
    border: 1px solid #d99;
    color: #900;
}
#message-container {
    padding: 10px;
    margin-bottom: 10px;
    border-radius: 4px;
    background-color: #e7f3fe;
    border: 1px solid #d0e3f0;
}
#editor-layout {
    display: flex; /* Enables flexbox layout */
    align-items: flex-start; /* Aligns items to the top of the container */
    gap: 20px; /* Optional: adds space between the image and the list */
    margin-top: 10px; /* Optional: space above the layout */
    margin-bottom: 10px; /* Optional: space below the layout */
}
.click-dot.highlighted,
.click-dot:hover { /* Dodatkowe podświetlenie dla samej kropki */
    background-color: yellow; /* Lub inny kolor wyróżnienia */
    box-shadow: 0 0 5px 2px orange; /* Opcjonalny cień */
    z-index: 10; /* Aby była nad innymi elementami, jeśli się nakładają */
}

#coordinates-list .coordinate-item.highlighted,
#coordinates-list .coordinate-item:hover { /* Dodatkowe podświetlenie dla samego elementu listy */
    background-color: #e6f7ff; /* Jasnoniebieskie tło */
    font-weight: bold; /* Pogrubienie tekstu */
}

#image-container {
    position: relative;
    display: inline-block; /* Or 'block' if you want it to take full available width before shrinking */
    border: 1px solid #ddd;
    margin-top: 10px;
    margin-bottom: 10px;
    /* REMOVE fixed width and height from here */
    /* width: 400px; */
    /* height: 400px; */
    /* Add this to make the container shrink-to-fit the image */
    line-height: 0; /* Fixes potential extra space below inline-block images */
}

#main-image {
    display: block; /* Or inline-block */
    max-width: 400px;   /* Image will not exceed 400px width */
    max-height: 400px;  /* Image will not exceed 400px height */      /* Allow height to adjust based on width and aspect ratio */
    width: auto;
    height: auto;
    /* These (width: auto; height: auto;) are often default for <img> but good to be explicit */
}

#image-container #connection-lines { /* Be more specific if #connection-lines is used elsewhere */
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
}

#toast-container {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 9999; /* Aby były na wierzchu */
    width: 300px; /* Możesz dostosować */
}

.toast-notification {
    background-color: #333;
    color: white;
    padding: 15px;
    margin-bottom: 10px;
    border-radius: 5px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    opacity: 0;
    transform: translateX(100%);
    transition: opacity 0.5s ease, transform 0.5s ease;
    font-size: 0.9em;
}

.toast-notification.show {
    opacity: 1;
    transform: translateX(0);
}

.toast-notification .toast-close-btn {
    float: right;
    background: none;
    border: none;
    color: #aaa;
    font-size: 1.2em;
    line-height: 1;
    cursor: pointer;
    margin-left: 10px;
}
.toast-notification .toast-close-btn:hover {
    color: white;
}

===== File: ./static/main/js/functions.js =====
function initializePageElements() {
    redrawLines();
    document.querySelectorAll('.click-dot').forEach(initializeDot);
    renumberDotsAndListItems();
}

function renumberDotsAndListItems() {
    const dots = document.querySelectorAll('.click-dot');
    dots.forEach((dot, index) => {
        const dotNumberElement = dot.querySelector('.dot-number');
        if (dotNumberElement) dotNumberElement.innerText = index + 1;
    });

    const listItems = document.querySelectorAll('#coordinates-list .coordinate-item');
    listItems.forEach((item, index) => {
        const pointDisplayNumber = item.querySelector('.point-display-number');
        if (pointDisplayNumber) pointDisplayNumber.innerText = index + 1;
    });
    redrawLines();
}

function redrawLines() {
    const svg = document.getElementById('connection-lines');
    if (!svg) return;
    svg.innerHTML = '';

    const dots = Array.from(document.querySelectorAll('.click-dot'));
    if (dots.length < 2) return;

    for(let i = 0; i < dots.length - 1; i++) {
        const dot1 = dots[i];
        const dot2 = dots[i + 1];
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        const x1 = parseFloat(dot1.style.left); // Kropka jest już wyśrodkowana przez transform
        const y1 = parseFloat(dot1.style.top);
        const x2 = parseFloat(dot2.style.left);
        const y2 = parseFloat(dot2.style.top);

        line.setAttribute('x1', x1);
        line.setAttribute('y1', y1);
        line.setAttribute('x2', x2);
        line.setAttribute('y2', y2);
        line.setAttribute('stroke-width', '2');
        line.setAttribute('stroke', '#ff0000');
        svg.appendChild(line);
    }
}

function createCoordinateListItem(clickId, x, y, isNew = false) {
    const listItem = document.createElement('li');
    listItem.classList.add('coordinate-item');
    if (!isNew && clickId) {
        listItem.setAttribute('data-click-id', clickId);
    }

    const pointNumberSpan = document.createElement('span');
    pointNumberSpan.classList.add('point-display-number');

    const inputX = document.createElement('input');
    inputX.type = 'number';
    inputX.classList.add('coord-x-input');
    inputX.value = parseFloat(x).toFixed(2);
    inputX.step = '0.01';

    const inputY = document.createElement('input');
    inputY.type = 'number';
    inputY.classList.add('coord-y-input');
    inputY.value = parseFloat(y).toFixed(2);
    inputY.step = '0.01';

    const updateButton = document.createElement('button');
    updateButton.classList.add('update-coord-btn');
    updateButton.textContent = isNew ? 'Save New' : 'Update';
    if (isNew) {
        updateButton.classList.add('save-new-coord-btn');
    }

    const deleteButton = document.createElement('button');
    deleteButton.classList.add('delete-coord-btn');
    deleteButton.textContent = 'Delete';

    listItem.appendChild(document.createTextNode('Point'));
    listItem.appendChild(pointNumberSpan);
    listItem.appendChild(document.createTextNode(': X'));
    listItem.appendChild(inputX);
    listItem.appendChild(document.createTextNode('Y'));
    listItem.appendChild(inputY);
    listItem.appendChild(updateButton);
    listItem.appendChild(deleteButton);

    document.getElementById('coordinates-list').appendChild(listItem);
    attachEventListenersToListItem(listItem, isNew); // Przekazuj tylko isNew
    return listItem;
}

function attachEventListenersToListItem(listItem, isNewInitially = false) {
    const updateBtn = listItem.querySelector('.update-coord-btn');
    const deleteBtn = listItem.querySelector('.delete-coord-btn');
    const inputX = listItem.querySelector('.coord-x-input');
    const inputY = listItem.querySelector('.coord-y-input');
    let isStillNew = isNewInitially; // Flaga do śledzenia, czy element jest nowy

    console.log(`[attachEventListenersToListItem] For item data-id=${listItem.dataset.clickId}, X_val=${inputX.value}, Y_val=${inputY.value}`);

    updateBtn.addEventListener('click', function() {
        const currentClickId = listItem.dataset.clickId;
        const newX = parseFloat(inputX.value);
        const newY = parseFloat(inputY.value);

        if (isNaN(newX) || isNaN(newY)) {
            alert('Please enter valid numbers for X and Y.');
            return;
        }

        if (isStillNew || !currentClickId) { // Zapis nowego punktu
            fetch('/add-click/', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
                body: JSON.stringify({ image_id: selectedImageId, x: newX, y: newY })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    listItem.setAttribute('data-click-id', data.click_id);
                    updateBtn.textContent = 'Update';
                    updateBtn.classList.remove('save-new-coord-btn');
                    isStillNew = false; // Już nie jest nowy
                    createDotOnImage(data.click_id, newX, newY);
                    renumberDotsAndListItems();
                } else { alert('Failed to save new point.'); }
            });
        } else { // Aktualizacja istniejącego punktu
            fetch('/update-click/', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
                body: JSON.stringify({ id: currentClickId, x: newX, y: newY })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    const dot = document.querySelector(`.click-dot[data-id="${currentClickId}"]`);
                    if (dot) {
                        dot.style.left = newX + 'px';
                        dot.style.top = newY + 'px';
                        redrawLines();
                    }
                } else { alert('Failed to update point.'); }
            });
        }

    });

    listItem.addEventListener('mouseenter', () => {
        const clickId = listItem.dataset.clickId;
        if (!clickId) return; // Nie podświetlaj, jeśli to nowy, niezapisany element

        listItem.classList.add('highlighted'); // Podświetl sam element listy
        const dotElement = document.querySelector(`.click-dot[data-id="${clickId}"]`);
        if (dotElement) {
            dotElement.classList.add('highlighted');
        }
    });

    listItem.addEventListener('mouseleave', () => {
        const clickId = listItem.dataset.clickId;
        if (!clickId) return;

        listItem.classList.remove('highlighted'); // Usuń podświetlenie z elementu listy
        const dotElement = document.querySelector(`.click-dot[data-id="${clickId}"]`);
        if (dotElement) {
            dotElement.classList.remove('highlighted');
        }
    });

    deleteBtn.addEventListener('click', function() {
        const currentClickId = listItem.dataset.clickId;
        if (isStillNew || !currentClickId) {
            listItem.remove();
            renumberDotsAndListItems();
            return;
        }

        fetch('/delete-click/', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
            body: JSON.stringify({ id: currentClickId })
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'deleted') {
                listItem.remove();
                const dot = document.querySelector(`.click-dot[data-id="${currentClickId}"]`);
                if (dot) dot.remove();
                renumberDotsAndListItems();
            } else { alert('Failed to delete point.'); }
        });
    });

    [inputX, inputY].forEach(input => {
        input.addEventListener('input', function() { // ZMIANA: 'input' zamiast 'change'
            const currentClickId = listItem.dataset.clickId;
            if (currentClickId && !isStillNew) { // Użyj flagi isStillNew
                const dot = document.querySelector(`.click-dot[data-id="${currentClickId}"]`);
                if (dot) {
                    let newXFromInput = parseFloat(inputX.value); // Use inputX from outer scope
                    let newYFromInput = parseFloat(inputY.value);
                    const mainImageForMove = document.getElementById('main-image');
                    if (!mainImageForMove) return; 
                    
                    const imageRect = mainImageForMove.getBoundingClientRect();

                    const boundaryMaxLeft = mainImageForMove.width;
                    const boundaryMinLeft = 0;
                    const boundaryMaxTop = mainImageForMove.height;
                    const boundaryMinTop = 0;
                    
                    // Keep entire dot within image boundaries
                    newXFromInput = Math.max(boundaryMinLeft, Math.min(newXFromInput, boundaryMaxLeft));
                    newYFromInput = Math.max(boundaryMinTop, Math.min(newYFromInput, boundaryMaxTop));   

                    newXFromInput = Math.max(0, newXFromInput);
                    newYFromInput = Math.max(0, newYFromInput)

                    if (!isNaN(newXFromInput) && !isNaN(newYFromInput)) {
                        dot.style.left = newXFromInput + 'px';
                        dot.style.top = newYFromInput + 'px';
                        inputX.value = newXFromInput;
                        inputY.value = newYFromInput;
                        redrawLines(); // Przesuń linie łączące punkty
                    }
                }
            }
        });
    });
}

function initializeCoordinateListInteractions() {
    document.querySelectorAll('#coordinates-list .coordinate-item').forEach(item => {
        const clickId = item.dataset.clickId;
        if (clickId) {
                attachEventListenersToListItem(item, false);
        }
    });

    const addPointToListBtn = document.getElementById('add-point-on-list-btn');
    if (addPointToListBtn) {
        addPointToListBtn.addEventListener('click', () => {
            const mainImage = document.getElementById('main-image');
            const defaultX = mainImage ? mainImage.width / 2 : 50;
            const defaultY = mainImage ? mainImage.height / 2 : 50;
            createCoordinateListItem(null, defaultX, defaultY, true);
            renumberDotsAndListItems();
        });
    }
}

function initializeDot(dot) {
    const image = document.getElementById("main-image");
    if (!image) return;

    let offsetX = 0, offsetY = 0;

    dot.addEventListener("mousedown", (e) => {
        if (e.button !== 0) return;
        draggedDot = dot; // Ustaw aktualnie przeciąganą kropkę
        const rect = dot.getBoundingClientRect();
        offsetX = e.clientX - rect.left;
        offsetY = e.clientY - rect.top;
        
        e.preventDefault();
        document.addEventListener('mouseup', handleDocumentMouseUp, { once: true });
    });

    dot.querySelector('.delete-dot-btn').addEventListener('click', function (e) {
        const clickId = dot.dataset.id;
        if (confirm('Are you sure you want to delete this point?')) {
            fetch('/delete-click/', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
                body: JSON.stringify({ id: clickId })
            }).then(response => response.json()).then(data => {
                if (data.status === 'deleted') {
                    dot.remove();
                    const listItem = document.querySelector(`#coordinates-list .coordinate-item[data-click-id="${clickId}"]`);
                    if (listItem) listItem.remove();
                    renumberDotsAndListItems();
                }
            });
        }
    });

    dot.addEventListener('mouseenter', () => {
        const clickId = dot.dataset.id;
        if (!clickId) return;

        dot.classList.add('highlighted'); // Podświetl samą kropkę
        const listItem = document.querySelector(`#coordinates-list .coordinate-item[data-click-id="${clickId}"]`);
        if (listItem) {
            listItem.classList.add('highlighted');
        }
    });

    dot.addEventListener('mouseleave', () => {
        const clickId = dot.dataset.id;
        if (!clickId) return;

        dot.classList.remove('highlighted'); // Usuń podświetlenie z kropki
        const listItem = document.querySelector(`#coordinates-list .coordinate-item[data-click-id="${clickId}"]`);
        if (listItem) {
            listItem.classList.remove('highlighted');
        }
    });
}

function handleDocumentMouseUp() {
    if (!draggedDot) return;

    const finalX = parseFloat(draggedDot.style.left);
    const finalY = parseFloat(draggedDot.style.top);

    fetch('/update-click/', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
        body: JSON.stringify({ id: draggedDot.dataset.id, x: finalX, y: finalY })
    }).then(response => {
        if (!response.ok) console.error('Position save failed after drag for dot ID:', draggedDot.dataset.id);
    });
    draggedDot = null; // Zakończ przeciąganie
}

function createDotOnImage(clickId, x, y) {
    const container = document.getElementById('image-container');
    const dot = document.createElement('div');
    dot.className = 'click-dot';
    dot.style.left = `${x}px`;
    dot.style.top = `${y}px`;
    dot.setAttribute('data-id', clickId);
    dot.innerHTML = `<span class="dot-number"></span>
                    <button class="delete-dot-btn" title="Delete this point">✖</button>`;
    container.appendChild(dot);
    initializeDot(dot);
    return dot;
}


===== File: ./static/main/ts/src/sseNotifications.ts =====
// static/main/ts/src/sseNotifications.ts

// --- Interfejsy dla danych przychodzących z SSE ---
interface BoardEventData {
    board_id: number;
    board_name: string;
    creator_username: string;
}

interface PathEventData {
    path_id: number | null;
    board_id: number; // W tym kontekście to UserImage.id lub GameBoard.id
    board_name: string;
    user_username: string;
    action?: "created" | "updated" | "point_added"; // Typy akcji dla ścieżek/obrazów
}

interface ReactionEventData {
    reaction_id: number;
    reaction_type: string; // np. 'heart', 'gasp', 'grin'
    reaction_display: string; // np. '❤️', '😮', '😄'
    user_username: string;
    object_type: string; // 'gameboard' lub 'userimage'
    object_id: number;
    object_name: string;
}

class SSENotifications {
    private eventSource: EventSource | null = null;
    private toastContainer: HTMLElement | null = null;
    private sseEndpointUrl: string;

    constructor(endpointUrl: string = '/board/events/') { // UŻYJ URL swojego endpointu SSE
        this.sseEndpointUrl = endpointUrl;
        this.toastContainer = document.getElementById('toast-container');

        if (this.toastContainer) {
            console.log("Toast container found. Proceeding with SSE connection.");
            this.connect();
        } else {
            console.warn("Toast container with ID 'toast-container' not found. SSE Notifications will not be visually displayed as toasts.");
            // Mimo to można próbować się połączyć, jeśli powiadomienia mają inne efekty
            // lub jeśli kontener jest dodawany dynamicznie później (choć to mniej typowe).
            // this.connect(); // Odkomentuj, jeśli nadal chcesz się łączyć bez wizualnych toastów
        }
    }

    private connect(): void {
        if (this.eventSource && (this.eventSource.readyState === EventSource.OPEN || this.eventSource.readyState === EventSource.CONNECTING)) {
            console.log("SSE connection already open or connecting.");
            return;
        }

        console.log(`Attempting to connect to SSE endpoint: ${this.sseEndpointUrl}`);
        try {
            this.eventSource = new EventSource(this.sseEndpointUrl);
        } catch (e) {
            console.error("Error creating EventSource (e.g., invalid URL or security policy):", e);
            this.showToast("Could not establish notification service. Check URL or network.", "error", 10000);
            return;
        }


        this.eventSource.onopen = (event) => {
            console.log("SSE Connection opened.", event);
            // Możesz tu wyświetlić powiadomienie o połączeniu, jeśli chcesz
            // this.showToast("Connected to real-time notifications.", "info");
        };

        this.eventSource.onerror = (errorEvent) => {
            console.error("SSE Error Event:", errorEvent);
            // EventSource automatycznie próbuje ponownie nawiązać połączenie.
            // Możemy wyświetlić informację o problemie.
            if (this.eventSource) {
                if (this.eventSource.readyState === EventSource.CLOSED) {
                    this.showToast("Notification service disconnected. Attempting to reconnect...", "error", 10000);
                    // Można by spróbować this.connect() po jakimś czasie, ale EventSource robi to samo.
                } else if (this.eventSource.readyState === EventSource.CONNECTING) {
                    this.showToast("Notification service having trouble connecting...", "error", 10000);
                }
            }
        };

        this.eventSource.addEventListener('newBoard', (event) => {
            console.log("SSE 'newBoard' event received:", event);
            try {
                const data = JSON.parse((event as MessageEvent).data) as BoardEventData;
                const message = `User '${data.creator_username}' created a new board: "${data.board_name}".`;
                const link = `/board/${data.board_id}/edit/`; // Dostosuj URL, jeśli jest inny
                this.showToast(message, "success", 7000, link);
            } catch (e) {
                console.error("Error parsing newBoard data:", e, (event as MessageEvent).data);
            }
        });

        this.eventSource.addEventListener('newPath', (event) => {
            console.log("SSE 'newPath' event received:", event);
            try {
                const data = JSON.parse((event as MessageEvent).data) as PathEventData;
                let messageBase = `User '${data.user_username}' `;
                let objectName = data.board_name || "a board/image"; // Fallback

                if (data.action === "created") {
                    messageBase += `uploaded a new path background: "${objectName}".`;
                } else if (data.action === "updated") {
                    messageBase += `updated paths on: "${objectName}".`;
                } else if (data.action === "point_added") {
                    messageBase += `added a point to a path on: "${objectName}".`;
                } else { // Domyślny komunikat, jeśli brak 'action' lub jest nieznane
                    messageBase += `interacted with: "${objectName}".`;
                }
                
                // Link do UserImage (który działa jako plansza dla ścieżek)
                // Zakładamy, że board_id w tym zdarzeniu to UserImage.id
                const link = `/?selected=${encodeURIComponent(objectName)}`;
                this.showToast(messageBase, "info", 7000, link);
            } catch (e) {
                console.error("Error parsing newPath data:", e, (event as MessageEvent).data);
            }
        });

        this.eventSource.addEventListener('newReaction', (event) => {
            console.log("SSE 'newReaction' event received:", event);
            try {
                const data = JSON.parse((event as MessageEvent).data) as ReactionEventData;
                const message = `User '${data.user_username}' reacted with ${data.reaction_display} to "${data.object_name}".`;
                
                this.showToast(message, "info", 5000); // Toasty dla reakcji mogą być krótsze i bez linku

                // Aktualizacja UI dla reakcji
                this.updateReactionsDisplay(
                    data.object_type,
                    data.object_id,
                    data.reaction_type,
                    data.user_username,
                    data.reaction_display
                );
            } catch (e) {
                console.error("Error parsing newReaction data:", e, (event as MessageEvent).data);
            }
        });

        this.eventSource.onmessage = (event) => {
            // To będzie przechwytywać wiadomości bez określonego "event: name"
            // oraz komentarze, jeśli serwer je wysyła bez poprzedzającego dwukropka (co nie powinno mieć miejsca dla keep-alive)
            if (event.data.startsWith(":")) { // Ignoruj komentarze keep-alive, jeśli tu dotrą
                console.log("SSE keep-alive or comment received in onmessage:", event.data);
                return;
            }
            console.log("SSE Generic message received:", event.data);
            // Możesz chcieć wyświetlić to jako ogólne powiadomienie, jeśli serwer może wysyłać takie komunikaty
            // this.showToast(`Notification: ${event.data}`, "info");
        };
    }

    public showToast(
        message: string, 
        type: 'info' | 'success' | 'error' = 'info', 
        duration: number = 5000, 
        link?: string
    ): void {
        if (!this.toastContainer) {
            console.warn("Toast container not found, cannot show toast for:", message);
            return;
        }

        const toast = document.createElement('div');
        toast.className = `toast-notification ${type}`; // np. "toast-notification success"
        
        let toastContentHTML = '';
        // Sanitize message before putting into innerHTML if it comes directly from user input elsewhere.
        // For now, assuming messages are safe or constructed server-side/client-side from known parts.
        const escapedMessage = message.replace(/&/g, "&").replace(/</g, "<").replace(/>/g, ">").replace(/"/g, """).replace(/'/g, "'");

        if (link) {
            // Ensure link is also somewhat safe or from a trusted source
            const safeLink = link.startsWith('/') ? link : '#'; // Basic check for relative links
            toastContentHTML = `<a href="${safeLink}" style="color: white; text-decoration: underline;">${escapedMessage}</a>`;
        } else {
            toastContentHTML = escapedMessage;
        }
        
        const messageSpan = document.createElement('span');
        messageSpan.innerHTML = toastContentHTML; // Use innerHTML because link might be present
        toast.appendChild(messageSpan);

        const closeBtn = document.createElement('button');
        closeBtn.className = 'toast-close-btn';
        closeBtn.type = 'button'; // Good practice for buttons not submitting forms
        closeBtn.innerHTML = '×'; // '×' character
        closeBtn.setAttribute('aria-label', 'Close notification');
        
        let toastRemoved = false; // Flaga, aby uniknąć wielokrotnego usuwania

        const removeToast = () => {
            if (toastRemoved) return;
            toastRemoved = true;
            toast.classList.remove('show');
            // Poczekaj na zakończenie animacji CSS przed usunięciem elementu z DOM
            toast.addEventListener('transitionend', () => {
                if (toast.parentNode === this.toastContainer) {
                    this.toastContainer?.removeChild(toast);
                }
            }, { once: true }); // Listener zostanie automatycznie usunięty po pierwszym wywołaniu
            // Fallback, gdyby transitionend się nie odpaliło (np. brak animacji)
            setTimeout(() => {
                 if (toast.parentNode === this.toastContainer) {
                    this.toastContainer?.removeChild(toast);
                }
            }, 550); // nieco dłużej niż czas trwania animacji
        };

        closeBtn.onclick = removeToast;
        toast.appendChild(closeBtn);

        this.toastContainer.appendChild(toast);

        // Wymuś reflow, aby animacja CSS zadziałała przy dodaniu klasy 'show'
        void toast.offsetWidth; 
        toast.classList.add('show');

        // Automatyczne usunięcie toasta po określonym czasie
        setTimeout(removeToast, duration);
    }

    // Szkielet metody do aktualizacji UI z reakcjami
    public updateReactionsDisplay(
        objectType: string, 
        objectId: number, 
        reactionTypeKey: string, // np. 'heart'
        reactingUsername: string,
        reactionDisplayIcon: string // np. '❤️'
    ): void {
        console.log(`UI Update Triggered: User '${reactingUsername}' reacted with ${reactionDisplayIcon} on ${objectType} ID ${objectId}`);
        
        const reactionContainer = document.querySelector(
            `.reactions-container[data-object-type="${objectType}"][data-object-id="${objectId}"]`
        );

        if (!reactionContainer) {
            // console.warn(`UI Update: Reaction container not found for ${objectType} ${objectId}`);
            return;
        }

        // Znajdź lub utwórz element dla konkretnego typu reakcji
        let reactionTypeDiv = reactionContainer.querySelector(`.reaction-type-display[data-reaction-type="${reactionTypeKey}"]`) as HTMLElement;
        
        if (!reactionTypeDiv) {
            reactionTypeDiv = document.createElement('span');
            reactionTypeDiv.className = 'reaction-type-display';
            reactionTypeDiv.dataset.reactionType = reactionTypeKey;
            
            const emojiSpan = document.createElement('span');
            emojiSpan.className = 'reaction-emoji';
            emojiSpan.textContent = reactionDisplayIcon;
            
            const countSpan = document.createElement('span');
            countSpan.className = 'reaction-count';
            countSpan.textContent = '0'; // Inicjalizuj z 0, backend powinien być źródłem prawdy o liczbie

            reactionTypeDiv.appendChild(emojiSpan);
            reactionTypeDiv.appendChild(document.createTextNode(' ')); // Spacja
            reactionTypeDiv.appendChild(countSpan);
            
            // TODO: Dodaj logikę do przechowywania listy użytkowników, np. w data-users tooltip
            reactionTypeDiv.dataset.users = reactingUsername;

            reactionContainer.appendChild(reactionTypeDiv);
            // Dodaj trochę marginesu między typami reakcji
            reactionTypeDiv.style.marginRight = "10px";

        } else {
            // Użytkownik już zareagował, lub inny użytkownik dodał ten sam typ reakcji
            // TODO: Zaktualizuj listę użytkowników w data-users
            const users = reactionTypeDiv.dataset.users ? reactionTypeDiv.dataset.users.split(',') : [];
            if (!users.includes(reactingUsername)) { // Dodaj tylko jeśli jeszcze nie ma
                users.push(reactingUsername);
                reactionTypeDiv.dataset.users = users.join(',');
            }
        }
        
        // Aktualizuj licznik - UWAGA: Ta logika jest uproszczona.
        // Idealnie, serwer powinien zwracać całkowitą liczbę reakcji danego typu,
        // a frontend tylko ją wyświetlać, zamiast inkrementować.
        // Poniższa logika zakłada, że każde zdarzenie 'newReaction' to nowa unikalna reakcja.
        const countSpan = reactionTypeDiv.querySelector('.reaction-count') as HTMLSpanElement;
        if (countSpan) {
            let currentCount = parseInt(countSpan.textContent || "0", 10);
            // To jest problematyczne: jeśli wielu użytkowników reaguje, ten licznik będzie rósł
            // dla każdego klienta niezależnie przy każdym zdarzeniu.
            // Lepiej, żeby SSE wysyłało aktualną łączną liczbę reakcji.
            // Na razie, dla prostoty, załóżmy, że zdarzenie oznacza +1.
            // W rzeczywistości, to SSE powinno wysłać {"total_hearts": 5, "total_gasps": 2} itd.
            // Albo, `updateReactionsDisplay` powinno być bardziej idempotentne.
            countSpan.textContent = (currentCount + 1).toString(); // UPROSZCZENIE - wymaga poprawy
        }

        // Ustawienie tooltipa z listą użytkowników
        const usersWhoReacted = reactionTypeDiv.dataset.users || "";
        reactionTypeDiv.title = usersWhoReacted ? `Reacted by: ${usersWhoReacted}` : "";

    }

    public closeConnection(): void {
        if (this.eventSource) {
            this.eventSource.close();
            console.log("SSE Connection closed by client.");
        }
    }
}

// Inicjalizacja po załadowaniu DOM
document.addEventListener('DOMContentLoaded', () => {
    // Sprawdź, czy element #toast-container istnieje, zanim zainicjujesz SSENotifications
    if (document.getElementById('toast-container')) {
        console.log("Initializing SSE Notifications client...");
        // Upewnij się, że URL jest poprawny dla Twojego projektu (np. z Django {% url ... %})
        // Poniżej jest przykład, jak można by go przekazać z szablonu Django, jeśli jest dynamiczny
        // const sseUrlElement = document.getElementById('sse-url-data');
        // const sseUrl = sseUrlElement ? sseUrlElement.dataset.url : '/board/events/';
        
        const sseClient = new SSENotifications('/board/events/'); // ZASTĄP URL, JEŚLI POTRZEBA

        // Opcjonalnie: udostępnij sseClient globalnie, jeśli potrzebujesz go wywoływać z innych miejsc
        // (np. window.sseClient = sseClient; - używaj ostrożnie)
    } else {
        console.log("No #toast-container found, SSE notifications will not have a visual display area via this script.");
    }
});

===== File: ./static/main/ts/src/functions.ts =====
// functions.ts

// Deklaracje typów dla zmiennych globalnych (zakładamy, że są zdefiniowane gdzie indziej)
declare const csrfToken: string;
declare const selectedImageId: number | null;
declare let draggedDot: HTMLElement | null;

// --- Interfejsy dla danych z serwera (opcjonalne, ale dobre dla typowania) ---
interface ClickData {
    id: number;
    x?: number;
    y?: number;
    col_index?: number;
    row_index?: number;
   
}

interface AddClickResponse {
    success: boolean;
    click_id?: number;
    is_grid_click?: boolean;
    error?: string;
}

interface UpdateClickResponse {
    status: 'success' | 'error' | 'not found or forbidden';
    message?: string;
}

interface DeleteClickResponse {
    status: 'deleted' | 'not found' | 'error';
}


// --- Funkcje ---

function initializePageElements(): void {
    redrawLines();
    document.querySelectorAll<HTMLElement>('.click-dot').forEach(initializeDot);
    renumberDotsAndListItems();
}

function renumberDotsAndListItems(): void {
    const dots = document.querySelectorAll<HTMLElement>('.click-dot');
    dots.forEach((dot, index) => {
        const dotNumberElement = dot.querySelector<HTMLSpanElement>('.dot-number');
        if (dotNumberElement) {
            dotNumberElement.innerText = (index + 1).toString();
        }
    });

    const listItems = document.querySelectorAll<HTMLLIElement>('#coordinates-list .coordinate-item');
    listItems.forEach((item, index) => {
        const pointDisplayNumber = item.querySelector<HTMLSpanElement>('.point-display-number');
        if (pointDisplayNumber) {
            pointDisplayNumber.innerText = (index + 1).toString();
        }
    });
    redrawLines();
}

function redrawLines(): void {
    const svg = document.getElementById('connection-lines') as SVGElement | null;
    if (!svg) return;
    svg.innerHTML = '';

    const dots = Array.from(document.querySelectorAll<HTMLElement>('.click-dot'));
    if (dots.length < 2) return;

    for (let i = 0; i < dots.length - 1; i++) {
        const dot1 = dots[i];
        const dot2 = dots[i + 1];
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');

       
        const x1 = parseFloat(dot1.style.left || '0');
        const y1 = parseFloat(dot1.style.top || '0');
        const x2 = parseFloat(dot2.style.left || '0');
        const y2 = parseFloat(dot2.style.top || '0');

        line.setAttribute('x1', x1.toString());
        line.setAttribute('y1', y1.toString());
        line.setAttribute('x2', x2.toString());
        line.setAttribute('y2', y2.toString());
        line.setAttribute('stroke-width', '2');
        line.setAttribute('stroke', '#ff0000');
        svg.appendChild(line);
    }
}

function createCoordinateListItem(clickId: number | null, x: number, y: number, isNew: boolean = false): HTMLLIElement {
    const listItem = document.createElement('li');
    listItem.classList.add('coordinate-item');
    if (!isNew && clickId !== null) {
        listItem.setAttribute('data-click-id', clickId.toString());
    }

    const pointNumberSpan = document.createElement('span');
    pointNumberSpan.classList.add('point-display-number');

    const inputX = document.createElement('input');
    inputX.type = 'number';
    inputX.classList.add('coord-x-input');
    inputX.value = x.toFixed(2);
    inputX.step = '0.01';
    inputX.autocomplete = 'off';


    const inputY = document.createElement('input');
    inputY.type = 'number';
    inputY.classList.add('coord-y-input');
    inputY.value = y.toFixed(2);
    inputY.step = '0.01';
    inputY.autocomplete = 'off';

    const updateButton = document.createElement('button');
    updateButton.classList.add('update-coord-btn');
    updateButton.textContent = isNew ? 'Save New' : 'Update';
    if (isNew) {
        updateButton.classList.add('save-new-coord-btn');
    }

    const deleteButton = document.createElement('button');
    deleteButton.classList.add('delete-coord-btn');
    deleteButton.textContent = 'Delete';

    listItem.appendChild(document.createTextNode('Point '));
    listItem.appendChild(pointNumberSpan);
    listItem.appendChild(document.createTextNode(': X '));
    listItem.appendChild(inputX);
    listItem.appendChild(document.createTextNode(' Y '));
    listItem.appendChild(inputY);
    listItem.appendChild(updateButton);
    listItem.appendChild(deleteButton);

    const coordinatesList = document.getElementById('coordinates-list');
    if (coordinatesList) {
        coordinatesList.appendChild(listItem);
    } else {
        console.error("Element with ID 'coordinates-list' not found.");
    }
    
    attachEventListenersToListItem(listItem, isNew);
    return listItem;
}

function attachEventListenersToListItem(listItem: HTMLLIElement, isNewInitially: boolean = false): void {
    const updateBtn = listItem.querySelector<HTMLButtonElement>('.update-coord-btn');
    const deleteBtn = listItem.querySelector<HTMLButtonElement>('.delete-coord-btn');
    const inputX = listItem.querySelector<HTMLInputElement>('.coord-x-input');
    const inputY = listItem.querySelector<HTMLInputElement>('.coord-y-input');
    let isStillNew = isNewInitially;

    if (!updateBtn || !deleteBtn || !inputX || !inputY) {
        console.error("Could not find all required elements within list item:", listItem);
        return;
    }

    console.log(`[attachEventListenersToListItem] For item data-id=${listItem.dataset.clickId}, X_val=${inputX.value}, Y_val=${inputY.value}`);

    updateBtn.addEventListener('click', function() {
        const currentClickIdStr = listItem.dataset.clickId;
        const currentClickId = currentClickIdStr ? parseInt(currentClickIdStr, 10) : null;
        const newX = parseFloat(inputX.value);
        const newY = parseFloat(inputY.value);

        if (isNaN(newX) || isNaN(newY)) {
            alert('Please enter valid numbers for X and Y.');
            return;
        }

        const requestBody = {
            item_id: selectedImageId,
            item_type: 'user_image', 
            x: newX,
            y: newY,
            id: currentClickId
        };
        
        if (isStillNew || currentClickId === null) {
            fetch('/add-click/', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
                body: JSON.stringify({ image_id: requestBody.item_id, x: newX, y: newY })
            })
            .then(response => response.json() as Promise<AddClickResponse>)
            .then(data => {
                if (data.success && data.click_id !== undefined) {
                    listItem.setAttribute('data-click-id', data.click_id.toString());
                    updateBtn.textContent = 'Update';
                    if (updateBtn.classList.contains('save-new-coord-btn')) {
                        updateBtn.classList.remove('save-new-coord-btn');
                    }
                    isStillNew = false;
                    createDotOnImage(data.click_id, newX, newY);
                    renumberDotsAndListItems();
                } else { 
                    alert('Failed to save new point. ' + (data.error || '')); 
                }
            }).catch(error => console.error('Error saving new point:', error));
        } else {
            fetch('/update-click/', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
                body: JSON.stringify({ id: currentClickId, x: newX, y: newY })
            })
            .then(response => response.json() as Promise<UpdateClickResponse>)
            .then(data => {
                if (data.status === 'success') {
                    const dot = document.querySelector<HTMLElement>(`.click-dot[data-id="${currentClickId}"]`);
                    if (dot) {
                        dot.style.left = newX + 'px';
                        dot.style.top = newY + 'px';
                        redrawLines();
                    }
                } else { 
                    alert('Failed to update point. ' + (data.message || ''));
                }
            }).catch(error => console.error('Error updating point:', error));
        }
    });

    listItem.addEventListener('mouseenter', () => {
        const clickId = listItem.dataset.clickId;
        if (!clickId) return;

        listItem.classList.add('highlighted');
        const dotElement = document.querySelector<HTMLElement>(`.click-dot[data-id="${clickId}"]`);
        if (dotElement) {
            dotElement.classList.add('highlighted');
        }
    });

    listItem.addEventListener('mouseleave', () => {
        const clickId = listItem.dataset.clickId;
        if (!clickId) return;

        listItem.classList.remove('highlighted');
        const dotElement = document.querySelector<HTMLElement>(`.click-dot[data-id="${clickId}"]`);
        if (dotElement) {
            dotElement.classList.remove('highlighted');
        }
    });

    deleteBtn.addEventListener('click', function() {
        const currentClickIdStr = listItem.dataset.clickId;
        
        if (isStillNew || !currentClickIdStr) {
            listItem.remove();
           
           
           
            renumberDotsAndListItems();
            return;
        }
        const currentClickId = parseInt(currentClickIdStr, 10);

        fetch('/delete-click/', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
            body: JSON.stringify({ id: currentClickId })
        })
        .then(response => response.json() as Promise<DeleteClickResponse>)
        .then(data => {
            if (data.status === 'deleted') {
                listItem.remove();
                const dot = document.querySelector<HTMLElement>(`.click-dot[data-id="${currentClickId}"]`);
                if (dot) dot.remove();
                renumberDotsAndListItems();
            } else { 
                alert('Failed to delete point.'); 
            }
        }).catch(error => console.error('Error deleting point:', error));
    });

    [inputX, inputY].forEach(inputField => {
        inputField.addEventListener('input', function() {
            const currentClickIdStr = listItem.dataset.clickId;
            if (currentClickIdStr && !isStillNew) {
                const currentClickId = parseInt(currentClickIdStr, 10);
                const dot = document.querySelector<HTMLElement>(`.click-dot[data-id="${currentClickId}"]`);
                
                if (dot) {
                    let newXFromInput = parseFloat(inputX.value);
                    let newYFromInput = parseFloat(inputY.value);

                    if (!isNaN(newXFromInput) && !isNaN(newYFromInput)) {
                        // --- BEGIN MODIFICATION: Clamp coordinates for live input update ---
                        const mainImageElement = document.getElementById('main-image') as HTMLImageElement | null;
                        let clampedX = newXFromInput;
                        let clampedY = newYFromInput;

                        if (mainImageElement) {
                            const dotWidth = 10; // As per CSS .click-dot width
                            const dotHeight = 10; // As per CSS .click-dot height

                            // Clamp X
                            if (mainImageElement.width < dotWidth) {
                                clampedX = mainImageElement.width / 2;
                            } else {
                                const minXAllowed = dotWidth / 2;
                                const maxXAllowed = mainImageElement.width - (dotWidth / 2);
                                clampedX = Math.max(minXAllowed, Math.min(newXFromInput, maxXAllowed));
                            }

                            // Clamp Y
                            if (mainImageElement.height < dotHeight) {
                                clampedY = mainImageElement.height / 2;
                            } else {
                                const minYAllowed = dotHeight / 2;
                                const maxYAllowed = mainImageElement.height - (dotHeight / 2);
                                clampedY = Math.max(minYAllowed, Math.min(newYFromInput, maxYAllowed));
                            }
                            
                            // Update input field if value was clamped, to give feedback
                            if (clampedX.toFixed(2) !== newXFromInput.toFixed(2) && inputField === inputX) {
                                inputX.value = clampedX.toFixed(2);
                            }
                            if (clampedY.toFixed(2) !== newYFromInput.toFixed(2) && inputField === inputY) {
                                inputY.value = clampedY.toFixed(2);
                            }
                        } else {
                             console.warn("Main image element not found, cannot apply boundary constraints for live input.");
                        }
                        // --- END MODIFICATION ---

                        dot.style.left = clampedX + 'px';
                        dot.style.top = clampedY + 'px';
                        redrawLines();
                    }
                }
            }
        });
    });
}

function initializeCoordinateListInteractions(): void {
    document.querySelectorAll<HTMLLIElement>('#coordinates-list .coordinate-item').forEach(item => {
        const clickId = item.dataset.clickId;
        if (clickId) {
            attachEventListenersToListItem(item, false);
        }
    });

    const addPointToListBtn = document.getElementById('add-point-on-list-btn');
    if (addPointToListBtn) {
        addPointToListBtn.addEventListener('click', () => {
            const mainImage = document.getElementById('main-image') as HTMLImageElement | null;
           
            const defaultX = mainImage ? mainImage.width / 2 : 50;
            const defaultY = mainImage ? mainImage.height / 2 : 50;
            
            createCoordinateListItem(null, defaultX, defaultY, true);
            renumberDotsAndListItems();
        });
    }
}


function initializeDot(dot: HTMLElement): void {
    const image = document.getElementById("main-image") as HTMLImageElement | null;
   
   

    dot.addEventListener("mousedown", (e: MouseEvent) => {
        if (e.button !== 0) return;
       
       

        draggedDot = dot;
       
        e.preventDefault();
        document.addEventListener('mouseup', handleDocumentMouseUp, { once: true });
    });

    const deleteBtn = dot.querySelector<HTMLButtonElement>('.delete-dot-btn');
    if (deleteBtn) {
        deleteBtn.addEventListener('click', function (e: MouseEvent) {
            e.stopPropagation();
            const clickIdStr = dot.dataset.id;
            if (!clickIdStr) {
                console.warn("Dot has no data-id for deletion:", dot);
               
               
                return;
            }
            const clickId = parseInt(clickIdStr, 10);

           
            fetch('/delete-click/', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
                body: JSON.stringify({ id: clickId })
            })
            .then(response => response.json() as Promise<DeleteClickResponse>)
            .then(data => {
                if (data.status === 'deleted') {
                    dot.remove();
                    const listItem = document.querySelector<HTMLLIElement>(`#coordinates-list .coordinate-item[data-click-id="${clickId}"]`);
                    if (listItem) listItem.remove();
                    renumberDotsAndListItems();
                } else {
                    alert('Failed to delete point.');
                }
            }).catch(error => console.error('Error deleting point:', error));
        });
    }

    dot.addEventListener('mouseenter', () => {
        const clickId = dot.dataset.id;
        if (!clickId) return;
        dot.classList.add('highlighted');
        const listItem = document.querySelector<HTMLLIElement>(`#coordinates-list .coordinate-item[data-click-id="${clickId}"]`);
        if (listItem) {
            listItem.classList.add('highlighted');
        }
    });

    dot.addEventListener('mouseleave', () => {
        const clickId = dot.dataset.id;
        if (!clickId) return;
        dot.classList.remove('highlighted');
        const listItem = document.querySelector<HTMLLIElement>(`#coordinates-list .coordinate-item[data-click-id="${clickId}"]`);
        if (listItem) {
            listItem.classList.remove('highlighted');
        }
    });
}


function handleDocumentMouseUp(): void {
    if (!draggedDot) return;

    const finalX = parseFloat(draggedDot.style.left || '0');
    const finalY = parseFloat(draggedDot.style.top || '0');
    const clickIdStr = draggedDot.dataset.id;

    if (!clickIdStr) {
        console.error("Dragged dot has no data-id for update:", draggedDot);
        draggedDot = null;
        return;
    }
    const clickId = parseInt(clickIdStr, 10);

    fetch('/update-click/', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
        body: JSON.stringify({ id: clickId, x: finalX, y: finalY })
    })
    .then(response => {
        if (!response.ok) {
            console.error('Position save failed after drag for dot ID:', clickId, response.statusText);
           
        }
        return response.json() as Promise<UpdateClickResponse>;
    })
    .then(data => {
        if (data.status !== 'success') {
            console.warn('Update click response status not success:', data);
        }
    })
    .catch(error => console.error('Error updating position after drag:', error));
    
    draggedDot = null;
}

function createDotOnImage(clickId: number, x: number, y: number): HTMLElement {
    const container = document.getElementById('image-container');
    if (!container) {
        console.error("Element with ID 'image-container' not found.");
       
        throw new Error("Image container not found, cannot create dot.");
    }
    const dot = document.createElement('div');
    dot.className = 'click-dot';
    dot.style.left = `${x}px`;
    dot.style.top = `${y}px`;
    dot.setAttribute('data-id', clickId.toString());
    dot.innerHTML = `<span class="dot-number"></span>
                    <button class="delete-dot-btn" title="Delete this point">✖</button>`;
    container.appendChild(dot);
    initializeDot(dot);
    return dot;
}

===== File: ./static/main/ts/src/grid.ts =====
interface Dot {
    row: number;
    col: number;
    color: string;
}

interface BoardState {
    id: number | null;
    name: string;
    rows: number;
    cols: number;
    dots: Dot[];
}

class BoardEditor {
    private gridContainer: HTMLElement;
    private numRowsInput: HTMLInputElement;
    private numColsInput: HTMLInputElement;
    private boardNameInput: HTMLInputElement;
    private generateGridButton: HTMLButtonElement;
    private saveBoardButton: HTMLButtonElement;
    private saveAsImageButton: HTMLButtonElement;
    private colorPaletteContainer: HTMLElement;
    private selectedColorDisplay: HTMLElement;
    private messagesDiv: HTMLElement;
    private csrfToken: string;
    private boardIdInput: HTMLInputElement;
    private cellSizePx: number = 0;

    private boardState: BoardState = {
        id: null,
        name: "My New Board",
        rows: 5,
        cols: 5,
        dots: []
    };

    private availableColors: string[] = [
        "#FF0000", "#00FF00", "#0000FF", "#FFFF00", "#FF00FF", "#00FFFF",
        "#FFA500", "#800080", "#A52A2A", "#008000"
    ];
    private selectedColor: string | null = null;
    private firstDotOfPair: { row: number, col: number } | null = null;
    private readonly MAX_GRID_DIMENSION_PX = 400;
    private readonly MIN_CELL_SIZE_PX = 10;


    constructor() {
        this.gridContainer = document.getElementById('grid-container')!;
        this.numRowsInput = document.getElementById('numRows') as HTMLInputElement;
        this.numColsInput = document.getElementById('numCols') as HTMLInputElement;
        this.boardNameInput = document.getElementById('boardName') as HTMLInputElement;
        this.generateGridButton = document.getElementById('generateGridButton') as HTMLButtonElement;
        this.saveBoardButton = document.getElementById('saveBoardButton') as HTMLButtonElement;
        this.colorPaletteContainer = document.getElementById('color-palette')!;
        this.selectedColorDisplay = document.getElementById('selected-color-display')!;
        this.messagesDiv = document.getElementById('messages')!;
        this.boardIdInput = document.getElementById('boardId') as HTMLInputElement;
        this.saveAsImageButton = document.getElementById('saveAsImageButton') as HTMLButtonElement;

        const csrfTokenElement = document.querySelector('[name=csrfmiddlewaretoken]') as HTMLInputElement;
        this.csrfToken = csrfTokenElement ? csrfTokenElement.value : '';

        this.loadInitialBoardData();
        this.initEventListeners();
        this.populateColorPalette();
        if (!this.boardState.id) {
            this.updateBoardStateFromInputs();
        }
        this.renderGrid();
    }

    private loadInitialBoardData(): void {
        const initialDataScript = document.getElementById('initial-board-data');
        if (initialDataScript && initialDataScript.textContent) {
            try {
                const data = JSON.parse(initialDataScript.textContent);
                if (data && data.id) {
                    this.boardState.id = data.id;
                    this.boardState.name = data.name;
                    this.boardState.rows = data.rows;
                    this.boardState.cols = data.cols;
                    this.boardState.dots = data.dots_config || [];

                    this.boardNameInput.value = this.boardState.name;
                    this.numRowsInput.value = this.boardState.rows.toString();
                    this.numColsInput.value = this.boardState.cols.toString();
                }
            } catch (e) {
                console.error("Error parsing initial board data:", e);
            }
        }
    }

    private initEventListeners(): void {
        this.saveAsImageButton.addEventListener('click', () => this.handleSaveAsImage());
        
        this.generateGridButton.addEventListener('click', () => {
            const oldRows = this.boardState.rows;
            const oldCols = this.boardState.cols;
            const newRows = parseInt(this.numRowsInput.value, 10);
            const newCols = parseInt(this.numColsInput.value, 10);

            if (this.boardState.rows !== newRows || this.boardState.cols !== newCols) {
                 this.boardState.dots = this.boardState.dots.filter(dot =>
                    dot.row < newRows && dot.col < newCols
                );
                this.firstDotOfPair = null;
            }
            this.boardState.rows = newRows;
            this.boardState.cols = newCols;
            this.renderGrid();
        });

        this.saveBoardButton.addEventListener('click', () => this.saveBoard());

        this.boardNameInput.addEventListener('input', () => {
            this.boardState.name = this.boardNameInput.value;
             const titleDisplay = document.getElementById('board-title-display');
             if(titleDisplay) titleDisplay.textContent = this.boardState.name;
        });
    }

    private updateBoardStateFromInputs(): void {
        this.boardState.name = this.boardNameInput.value;
        this.boardState.rows = parseInt(this.numRowsInput.value, 10) || 5;
        this.boardState.cols = parseInt(this.numColsInput.value, 10) || 5;
    }

    private populateColorPalette(): void {
        this.availableColors.forEach(color => {
            const colorButton = document.createElement('div');
            colorButton.classList.add('color-button');
            colorButton.style.backgroundColor = color;
            colorButton.dataset.color = color;
            colorButton.addEventListener('click', () => this.selectColor(color, colorButton));
            this.colorPaletteContainer.appendChild(colorButton);
        });
    }

    private selectColor(color: string, buttonElement: HTMLElement): void {
        this.selectedColor = color;
        this.firstDotOfPair = null;
        this.selectedColorDisplay.textContent = color;
        this.selectedColorDisplay.style.color = color;

        document.querySelectorAll('.color-button.selected').forEach(btn => btn.classList.remove('selected'));
        buttonElement.classList.add('selected');
    }

    private renderGrid(): void {
        this.gridContainer.innerHTML = '';

        const numRows = this.boardState.rows;
        const numCols = this.boardState.cols;

        if (numRows <= 0 || numCols <= 0) {
            this.gridContainer.style.width = '0px';
            this.gridContainer.style.height = '0px';
            return;
        }

        let calculatedCellSizePx: number;
        const cellWidthIfLimitedByCols = this.MAX_GRID_DIMENSION_PX / numCols;
        const cellHeightIfLimitedByRows = this.MAX_GRID_DIMENSION_PX / numRows;
        calculatedCellSizePx = Math.floor(Math.min(cellWidthIfLimitedByCols, cellHeightIfLimitedByRows));
        calculatedCellSizePx = Math.max(calculatedCellSizePx, this.MIN_CELL_SIZE_PX);
        this.cellSizePx = calculatedCellSizePx;

        const totalGridWidth = this.cellSizePx * numCols;
        const totalGridHeight = this.cellSizePx * numRows;

        this.gridContainer.style.width = `${totalGridWidth}px`;
        this.gridContainer.style.height = `${totalGridHeight}px`;

        this.gridContainer.style.gridTemplateRows = `repeat(${numRows}, ${this.cellSizePx}px)`;
        this.gridContainer.style.gridTemplateColumns = `repeat(${numCols}, ${this.cellSizePx}px)`;

        for (let r = 0; r < numRows; r++) {
            for (let c = 0; c < numCols; c++) {
                const cell = document.createElement('div');
                cell.classList.add('grid-cell');
                cell.dataset.row = r.toString();
                cell.dataset.col = c.toString();
                cell.addEventListener('click', () => this.handleCellClick(r, c));
                this.gridContainer.appendChild(cell);
            }
        }
        this.renderDots();
    }

    private renderDots(): void {
        this.gridContainer.querySelectorAll('.dot-visual').forEach(dv => dv.remove());

        this.boardState.dots.forEach(dot => {
            const cell = this.gridContainer.querySelector(`.grid-cell[data-row='${dot.row}'][data-col='${dot.col}']`);
            if (cell) {
                const dotVisual = document.createElement('div');
                dotVisual.classList.add('dot-visual');
                dotVisual.style.backgroundColor = dot.color;
                cell.appendChild(dotVisual);
            }
        });
    }

    private handleCellClick(row: number, col: number): void {
        if (!this.selectedColor) {
            this.showMessage("Please select a color first.", "error");
            return;
        }

        const existingDotIndex = this.boardState.dots.findIndex(d => d.row === row && d.col === col);

        if (existingDotIndex !== -1) {
            const existingDot = this.boardState.dots[existingDotIndex];
            if (existingDot.color === this.selectedColor) {
                this.boardState.dots.splice(existingDotIndex, 1);
                if (this.firstDotOfPair && this.firstDotOfPair.row === row && this.firstDotOfPair.col === col) {
                    this.firstDotOfPair = null;
                }
                this.renderDots();
                this.showMessage(`Dot removed from (${row}, ${col}).`, "info");
            } else {
                 this.showMessage("Cell is already occupied by a different color.", "error");
            }
            return;
        }

        const dotsOfSelectedColor = this.boardState.dots.filter(d => d.color === this.selectedColor);

        if (dotsOfSelectedColor.length >= 2) {
            this.showMessage(`Already placed two dots for color ${this.selectedColor}. Select a different color or remove existing dots of this color.`, "error");
            return;
        }

        const newDot: Dot = { row, col, color: this.selectedColor };

        if (!this.firstDotOfPair) {
            this.boardState.dots.push(newDot);
            this.firstDotOfPair = { row, col };
            this.showMessage(`First dot of color ${this.selectedColor} placed at (${row}, ${col}). Click another empty cell.`, "info");
        } else {
            if (this.firstDotOfPair.row === row && this.firstDotOfPair.col === col) { // Prevent placing second dot on the first dot's cell
                this.showMessage("Cannot place the second dot on the same cell as the first.", "error");
                return;
            }
            this.boardState.dots.push(newDot);
            this.showMessage(`Second dot of color ${this.selectedColor} placed at (${row}, ${col}). Pair complete.`, "success");
            this.firstDotOfPair = null;
        }
        this.renderDots();
    }

    private async saveBoard(): Promise<void> {
        if (!this.boardNameInput.value.trim()) {
            this.showMessage("Board name cannot be empty.", "error");
            return;
        }
        this.boardState.name = this.boardNameInput.value.trim();

        const colorCounts: { [key: string]: number } = {};
        this.boardState.dots.forEach(dot => {
            colorCounts[dot.color] = (colorCounts[dot.color] || 0) + 1;
        });

        for (const color in colorCounts) {
            if (colorCounts[color] === 1) {
                 this.showMessage(`Color ${color} has only one dot. Please complete the pair or remove it.`, "error");
                 return;
            }
        }

        const payload = {
            id: this.boardState.id,
            name: this.boardState.name,
            rows: this.boardState.rows,
            cols: this.boardState.cols,
            dots_config: this.boardState.dots
        };

        try {
            const response = await fetch('/board/api/save_board/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': this.csrfToken,
                    'X-Requested-With': 'XMLHttpRequest'
                },
                body: JSON.stringify(payload)
            });

            const result = await response.json();

            if (response.ok) {
                this.showMessage(result.message || "Board saved successfully!", "success");
                if (result.board_id) {
                    this.boardState.id = result.board_id;
                    this.boardIdInput.value = result.board_id.toString();
                    const titleDisplay = document.getElementById('board-title-display');
                    if(titleDisplay) {
                         titleDisplay.textContent = this.boardState.name;
                    } else {
                        const h1 = document.querySelector('h1');
                        if(h1) h1.innerHTML = `Edit Board: <span id="board-title-display">${this.boardState.name}</span>`;
                    }
                    if (this.boardState.id && !window.location.pathname.includes(this.boardState.id.toString())) {
                         window.history.pushState({}, '', `/board/${this.boardState.id}/edit/`);
                    }
                }
            } else {
                let errorMsg = result.message || "Failed to save board.";
                if (result.errors) {
                    errorMsg += "<ul>";
                    for (const field in result.errors) {
                        result.errors[field].forEach((err: string) => {
                            errorMsg += `<li>${field}: ${err}</li>`;
                        });
                    }
                    errorMsg += "</ul>";
                }
                this.showMessage(errorMsg, "error", false);
            }
        } catch (error) {
            console.error("Error saving board:", error);
            this.showMessage("An unexpected error occurred while saving.", "error");
        }
    }

    public async getBoardAsImageDataURL(format: 'image/png' | 'image/jpeg' = 'image/png'): Promise<string | null> {
        const rows = this.boardState.rows;
        const cols = this.boardState.cols;
        const dots = this.boardState.dots;

        if (rows <= 0 || cols <= 0 || this.cellSizePx <= 0) {
            console.error("Board dimensions or cell size invalid for image generation.");
            return null;
        }

        const canvas = document.createElement('canvas');
        const canvasWidth = cols * this.cellSizePx;
        const canvasHeight = rows * this.cellSizePx;
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        const ctx = canvas.getContext('2d');
        if (!ctx) {
            console.error("Could not get 2D context from canvas");
            return null;
        }

        // 1. Draw background (optional)
        ctx.fillStyle = "#FFFFFF"; // White background
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // 2. Draw grid lines
        ctx.strokeStyle = "#CCCCCC"; // Light grey for grid lines
        ctx.lineWidth = 1;

        for (let r = 0; r <= rows; r++) {
            ctx.beginPath();
            ctx.moveTo(0, r * this.cellSizePx);
            ctx.lineTo(canvas.width, r * this.cellSizePx);
            ctx.stroke();
        }
        for (let c = 0; c <= cols; c++) {
            ctx.beginPath();
            ctx.moveTo(c * this.cellSizePx, 0);
            ctx.lineTo(c * this.cellSizePx, canvas.height);
            ctx.stroke();
        }

        // 3. Draw the colored dots
        const dotRadius = this.cellSizePx * 0.35; // 35% of cell size for dot radius
        dots.forEach(dot => {
            const centerX = dot.col * this.cellSizePx + this.cellSizePx / 2;
            const centerY = dot.row * this.cellSizePx + this.cellSizePx / 2;

            ctx.beginPath();
            ctx.arc(centerX, centerY, dotRadius, 0, 2 * Math.PI, false);
            ctx.fillStyle = dot.color;
            ctx.fill();
            // Optional: add a border to dots
            // ctx.lineWidth = 1;
            // ctx.strokeStyle = '#333333';
            // ctx.stroke();
        });

        return canvas.toDataURL(format);
    }

    public async handleSaveAsImage(): Promise<void> {
        this.showMessage("Generating image...", "info", false);
        const imageDataURL = await this.getBoardAsImageDataURL();

        if (!imageDataURL) {
            this.showMessage("Failed to generate image data.", "error");
            return;
        }

        // Prepare data for backend
        const boardName = this.boardState.name || "Generated Grid Board";
        const fileName = `${boardName.replace(/[^a-zA-Z0-9]/g, '_')}_${Date.now()}.png`;

        const payload = {
            name: boardName,       // Name for the UserImage
            image_data_url: imageDataURL,
            filename: fileName     // Suggested filename
        };

        try {
            const response = await fetch('/api/save_grid_as_image/', { // NEW ENDPOINT
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': this.csrfToken,
                },
                body: JSON.stringify(payload)
            });

            const result = await response.json();
            if (response.ok && result.status === 'success') {
                this.showMessage(`Board saved as image: ${result.image_name}. You can now use it for path editing.`, "success");
                // Optionally redirect or update UI
            } else {
                this.showMessage(result.message || "Failed to save board as image on server.", "error");
            }
        } catch (error) {
            console.error("Error saving board as image:", error);
            this.showMessage("An error occurred while sending image to server.", "error");
        }
    }

    private showMessage(message: string, type: 'success' | 'error' | 'info', autoClear: boolean = true): void {
        this.messagesDiv.innerHTML = `<p class="${type}">${message}</p>`;
        if (autoClear) {
            setTimeout(() => {
                this.messagesDiv.innerHTML = '';
            }, 5000);
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    if (document.getElementById('grid-container')) {
        new BoardEditor();
    }
});

===== File: ./static/main/ts/dist/sseNotifications.js =====
"use strict";
// static/main/ts/src/sseNotifications.ts
class SSENotifications {
    constructor(endpointUrl = '/board/events/') {
        this.eventSource = null;
        this.toastContainer = null;
        this.sseEndpointUrl = endpointUrl;
        this.toastContainer = document.getElementById('toast-container');
        // Inicjuj tylko jeśli kontener istnieje
        if (this.toastContainer) {
            this.connect();
        }
        else {
            console.warn("Toast container not found. SSE Notifications will not be displayed visually.");
            // Mimo to można próbować się połączyć, jeśli powiadomienia mają inne efekty
            // this.connect(); 
        }
    }
    connect() {
        if (this.eventSource && (this.eventSource.readyState === EventSource.OPEN || this.eventSource.readyState === EventSource.CONNECTING)) {
            console.log("SSE connection already open or connecting.");
            return;
        }
        console.log(`Attempting to connect to SSE endpoint: ${this.sseEndpointUrl}`);
        this.eventSource = new EventSource(this.sseEndpointUrl);
        this.eventSource.onopen = (event) => {
            console.log("SSE Connection opened.", event);
            // Możesz tu wyświetlić powiadomienie o połączeniu, jeśli chcesz
            // this.showToast("Connected to real-time notifications.", "info");
        };
        this.eventSource.onerror = (error) => {
            console.error("SSE Error:", error);
            // Możesz spróbować zamknąć i ponownie otworzyć połączenie po jakimś czasie,
            // EventSource domyślnie próbuje się połączyć ponownie.
            if (this.eventSource) {
                this.showToast("Notification service error. Reconnecting...", "error", 10000);
                // Domyślne ponowne połączenie EventSource powinno zadziałać.
                // Jeśli readyState to EventSource.CLOSED, można by spróbować this.eventSource.close(); a potem this.connect();
            }
        };
        // Listener dla konkretnego zdarzenia "newBoard"
        this.eventSource.addEventListener('newBoard', (event) => {
            console.log("SSE newBoard event received:", event);
            try {
                const data = JSON.parse(event.data);
                const message = `User '${data.creator_username}' created a new board: "${data.board_name}".`;
                // Opcjonalnie: link do planszy
                const link = `/board/${data.board_id}/edit/`; // Dostosuj URL, jeśli jest inny
                this.showToast(message, "success", 7000, link);
            }
            catch (e) {
                console.error("Error parsing newBoard data:", e);
            }
        });
        // Listener dla konkretnego zdarzenia "newPath"
        this.eventSource.addEventListener('newPath', (event) => {
            console.log("SSE newPath event received:", event);
            try {
                const data = JSON.parse(event.data);
                let messageBase = `User '${data.user_username}' `;
                if (data.action === "created") {
                    messageBase += `uploaded a new path background: "${data.board_name}".`;
                }
                else if (data.action === "updated") {
                    messageBase += `updated paths on board: "${data.board_name}".`;
                }
                else if (data.action === "point_added") {
                    messageBase += `added a point to a path on board: "${data.board_name}".`;
                }
                else {
                    messageBase += `saved a path on board: "${data.board_name}".`;
                }
                // Opcjonalnie: link do planszy (UserImage)
                // Zakładając, że `home.html` przyjmuje `?selected=IMAGE_NAME`
                const link = `/?selected=${encodeURIComponent(data.board_name)}`; // Dostosuj URL
                this.showToast(messageBase, "info", 7000, link);
            }
            catch (e) {
                console.error("Error parsing newPath data:", e);
            }
        });
        // Ogólny listener onmessage (opcjonalnie, jeśli chcesz przechwytywać zdarzenia bez określonego typu 'event:')
        // lub komentarze keep-alive (choć zwykle są ignorowane przez EventSource).
        this.eventSource.onmessage = (event) => {
            // Komentarze keep-alive (zaczynające się od ':') nie powinny tu trafiać.
            // Jeśli serwer wysyła zdarzenia bez linii "event: name", trafią one tutaj.
            console.log("SSE Generic message received:", event.data);
        };
    }
    showToast(message, type = 'info', duration = 5000, link) {
        if (!this.toastContainer)
            return;
        const toast = document.createElement('div');
        toast.className = `toast-notification ${type}`;
        let content = message;
        if (link) {
            content = `<a href="${link}" style="color: white; text-decoration: underline;">${message}</a>`;
        }
        toast.innerHTML = content; // Użyj innerHTML, jeśli masz link
        const closeBtn = document.createElement('button');
        closeBtn.className = 'toast-close-btn';
        closeBtn.innerHTML = '×';
        closeBtn.onclick = () => {
            toast.classList.remove('show');
            setTimeout(() => {
                var _a;
                if (toast.parentNode === this.toastContainer) { // Sprawdź, czy wciąż jest dzieckiem
                    (_a = this.toastContainer) === null || _a === void 0 ? void 0 : _a.removeChild(toast);
                }
            }, 500); // Czas na animację wyjścia
        };
        toast.appendChild(closeBtn);
        this.toastContainer.appendChild(toast);
        // Wymuś reflow, aby animacja zadziałała przy dodaniu klasy 'show'
        void toast.offsetWidth;
        toast.classList.add('show');
        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => {
                var _a;
                // Sprawdź, czy element wciąż istnieje i jest dzieckiem kontenera przed usunięciem
                if (toast.parentNode === this.toastContainer) {
                    (_a = this.toastContainer) === null || _a === void 0 ? void 0 : _a.removeChild(toast);
                }
            }, 500); // Czas na animację wyjścia
        }, duration);
    }
    closeConnection() {
        if (this.eventSource) {
            this.eventSource.close();
            console.log("SSE Connection closed by client.");
        }
    }
}
// Inicjalizacja po załadowaniu DOM
// Możesz zdecydować, czy chcesz to inicjować na każdej stronie,
// czy tylko na wybranych (np. sprawdzając istnienie pewnego elementu).
document.addEventListener('DOMContentLoaded', () => {
    // Sprawdź, czy użytkownik jest zalogowany, zanim nawiążesz połączenie SSE,
    // jeśli endpoint SSE wymaga autoryzacji lub jeśli powiadomienia są tylko dla zalogowanych.
    // Możesz to zrobić sprawdzając obecność np. elementu z nazwą użytkownika
    // lub przekazując flagę z Django do szablonu.
    // Prosty przykład: inicjuj zawsze, jeśli jest kontener na toasty
    if (document.getElementById('toast-container')) {
        console.log("Initializing SSE Notifications client...");
        const sseClient = new SSENotifications('/board/events/'); // UŻYJ POPRAWNEGO URL ENDPOINTU SSE
        // Aby móc zamknąć połączenie np. przy wylogowaniu:
        // window.sseClient = sseClient; 
    }
});
//# sourceMappingURL=sseNotifications.js.map

===== File: ./static/main/ts/dist/grid.js =====
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class BoardEditor {
    constructor() {
        this.cellSizePx = 0;
        this.boardState = {
            id: null,
            name: "My New Board",
            rows: 5,
            cols: 5,
            dots: []
        };
        this.availableColors = [
            "#FF0000", "#00FF00", "#0000FF", "#FFFF00", "#FF00FF", "#00FFFF",
            "#FFA500", "#800080", "#A52A2A", "#008000"
        ];
        this.selectedColor = null;
        this.firstDotOfPair = null;
        this.MAX_GRID_DIMENSION_PX = 400;
        this.MIN_CELL_SIZE_PX = 10;
        this.gridContainer = document.getElementById('grid-container');
        this.numRowsInput = document.getElementById('numRows');
        this.numColsInput = document.getElementById('numCols');
        this.boardNameInput = document.getElementById('boardName');
        this.generateGridButton = document.getElementById('generateGridButton');
        this.saveBoardButton = document.getElementById('saveBoardButton');
        this.colorPaletteContainer = document.getElementById('color-palette');
        this.selectedColorDisplay = document.getElementById('selected-color-display');
        this.messagesDiv = document.getElementById('messages');
        this.boardIdInput = document.getElementById('boardId');
        this.saveAsImageButton = document.getElementById('saveAsImageButton');
        const csrfTokenElement = document.querySelector('[name=csrfmiddlewaretoken]');
        this.csrfToken = csrfTokenElement ? csrfTokenElement.value : '';
        this.loadInitialBoardData();
        this.initEventListeners();
        this.populateColorPalette();
        if (!this.boardState.id) {
            this.updateBoardStateFromInputs();
        }
        this.renderGrid();
    }
    loadInitialBoardData() {
        const initialDataScript = document.getElementById('initial-board-data');
        if (initialDataScript && initialDataScript.textContent) {
            try {
                const data = JSON.parse(initialDataScript.textContent);
                if (data && data.id) {
                    this.boardState.id = data.id;
                    this.boardState.name = data.name;
                    this.boardState.rows = data.rows;
                    this.boardState.cols = data.cols;
                    this.boardState.dots = data.dots_config || [];
                    this.boardNameInput.value = this.boardState.name;
                    this.numRowsInput.value = this.boardState.rows.toString();
                    this.numColsInput.value = this.boardState.cols.toString();
                }
            }
            catch (e) {
                console.error("Error parsing initial board data:", e);
            }
        }
    }
    initEventListeners() {
        this.saveAsImageButton.addEventListener('click', () => this.handleSaveAsImage());
        this.generateGridButton.addEventListener('click', () => {
            const oldRows = this.boardState.rows;
            const oldCols = this.boardState.cols;
            const newRows = parseInt(this.numRowsInput.value, 10);
            const newCols = parseInt(this.numColsInput.value, 10);
            if (this.boardState.rows !== newRows || this.boardState.cols !== newCols) {
                this.boardState.dots = this.boardState.dots.filter(dot => dot.row < newRows && dot.col < newCols);
                this.firstDotOfPair = null;
            }
            this.boardState.rows = newRows;
            this.boardState.cols = newCols;
            this.renderGrid();
        });
        this.saveBoardButton.addEventListener('click', () => this.saveBoard());
        this.boardNameInput.addEventListener('input', () => {
            this.boardState.name = this.boardNameInput.value;
            const titleDisplay = document.getElementById('board-title-display');
            if (titleDisplay)
                titleDisplay.textContent = this.boardState.name;
        });
    }
    updateBoardStateFromInputs() {
        this.boardState.name = this.boardNameInput.value;
        this.boardState.rows = parseInt(this.numRowsInput.value, 10) || 5;
        this.boardState.cols = parseInt(this.numColsInput.value, 10) || 5;
    }
    populateColorPalette() {
        this.availableColors.forEach(color => {
            const colorButton = document.createElement('div');
            colorButton.classList.add('color-button');
            colorButton.style.backgroundColor = color;
            colorButton.dataset.color = color;
            colorButton.addEventListener('click', () => this.selectColor(color, colorButton));
            this.colorPaletteContainer.appendChild(colorButton);
        });
    }
    selectColor(color, buttonElement) {
        this.selectedColor = color;
        this.firstDotOfPair = null;
        this.selectedColorDisplay.textContent = color;
        this.selectedColorDisplay.style.color = color;
        document.querySelectorAll('.color-button.selected').forEach(btn => btn.classList.remove('selected'));
        buttonElement.classList.add('selected');
    }
    renderGrid() {
        this.gridContainer.innerHTML = '';
        const numRows = this.boardState.rows;
        const numCols = this.boardState.cols;
        if (numRows <= 0 || numCols <= 0) {
            this.gridContainer.style.width = '0px';
            this.gridContainer.style.height = '0px';
            return;
        }
        let calculatedCellSizePx;
        const cellWidthIfLimitedByCols = this.MAX_GRID_DIMENSION_PX / numCols;
        const cellHeightIfLimitedByRows = this.MAX_GRID_DIMENSION_PX / numRows;
        calculatedCellSizePx = Math.floor(Math.min(cellWidthIfLimitedByCols, cellHeightIfLimitedByRows));
        calculatedCellSizePx = Math.max(calculatedCellSizePx, this.MIN_CELL_SIZE_PX);
        this.cellSizePx = calculatedCellSizePx;
        const totalGridWidth = this.cellSizePx * numCols;
        const totalGridHeight = this.cellSizePx * numRows;
        this.gridContainer.style.width = `${totalGridWidth}px`;
        this.gridContainer.style.height = `${totalGridHeight}px`;
        this.gridContainer.style.gridTemplateRows = `repeat(${numRows}, ${this.cellSizePx}px)`;
        this.gridContainer.style.gridTemplateColumns = `repeat(${numCols}, ${this.cellSizePx}px)`;
        for (let r = 0; r < numRows; r++) {
            for (let c = 0; c < numCols; c++) {
                const cell = document.createElement('div');
                cell.classList.add('grid-cell');
                cell.dataset.row = r.toString();
                cell.dataset.col = c.toString();
                cell.addEventListener('click', () => this.handleCellClick(r, c));
                this.gridContainer.appendChild(cell);
            }
        }
        this.renderDots();
    }
    renderDots() {
        this.gridContainer.querySelectorAll('.dot-visual').forEach(dv => dv.remove());
        this.boardState.dots.forEach(dot => {
            const cell = this.gridContainer.querySelector(`.grid-cell[data-row='${dot.row}'][data-col='${dot.col}']`);
            if (cell) {
                const dotVisual = document.createElement('div');
                dotVisual.classList.add('dot-visual');
                dotVisual.style.backgroundColor = dot.color;
                cell.appendChild(dotVisual);
            }
        });
    }
    handleCellClick(row, col) {
        if (!this.selectedColor) {
            this.showMessage("Please select a color first.", "error");
            return;
        }
        const existingDotIndex = this.boardState.dots.findIndex(d => d.row === row && d.col === col);
        if (existingDotIndex !== -1) {
            const existingDot = this.boardState.dots[existingDotIndex];
            if (existingDot.color === this.selectedColor) {
                this.boardState.dots.splice(existingDotIndex, 1);
                if (this.firstDotOfPair && this.firstDotOfPair.row === row && this.firstDotOfPair.col === col) {
                    this.firstDotOfPair = null;
                }
                this.renderDots();
                this.showMessage(`Dot removed from (${row}, ${col}).`, "info");
            }
            else {
                this.showMessage("Cell is already occupied by a different color.", "error");
            }
            return;
        }
        const dotsOfSelectedColor = this.boardState.dots.filter(d => d.color === this.selectedColor);
        if (dotsOfSelectedColor.length >= 2) {
            this.showMessage(`Already placed two dots for color ${this.selectedColor}. Select a different color or remove existing dots of this color.`, "error");
            return;
        }
        const newDot = { row, col, color: this.selectedColor };
        if (!this.firstDotOfPair) {
            this.boardState.dots.push(newDot);
            this.firstDotOfPair = { row, col };
            this.showMessage(`First dot of color ${this.selectedColor} placed at (${row}, ${col}). Click another empty cell.`, "info");
        }
        else {
            if (this.firstDotOfPair.row === row && this.firstDotOfPair.col === col) { // Prevent placing second dot on the first dot's cell
                this.showMessage("Cannot place the second dot on the same cell as the first.", "error");
                return;
            }
            this.boardState.dots.push(newDot);
            this.showMessage(`Second dot of color ${this.selectedColor} placed at (${row}, ${col}). Pair complete.`, "success");
            this.firstDotOfPair = null;
        }
        this.renderDots();
    }
    saveBoard() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.boardNameInput.value.trim()) {
                this.showMessage("Board name cannot be empty.", "error");
                return;
            }
            this.boardState.name = this.boardNameInput.value.trim();
            const colorCounts = {};
            this.boardState.dots.forEach(dot => {
                colorCounts[dot.color] = (colorCounts[dot.color] || 0) + 1;
            });
            for (const color in colorCounts) {
                if (colorCounts[color] === 1) {
                    this.showMessage(`Color ${color} has only one dot. Please complete the pair or remove it.`, "error");
                    return;
                }
            }
            const payload = {
                id: this.boardState.id,
                name: this.boardState.name,
                rows: this.boardState.rows,
                cols: this.boardState.cols,
                dots_config: this.boardState.dots
            };
            try {
                const response = yield fetch('/board/api/save_board/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': this.csrfToken,
                        'X-Requested-With': 'XMLHttpRequest'
                    },
                    body: JSON.stringify(payload)
                });
                const result = yield response.json();
                if (response.ok) {
                    this.showMessage(result.message || "Board saved successfully!", "success");
                    if (result.board_id) {
                        this.boardState.id = result.board_id;
                        this.boardIdInput.value = result.board_id.toString();
                        const titleDisplay = document.getElementById('board-title-display');
                        if (titleDisplay) {
                            titleDisplay.textContent = this.boardState.name;
                        }
                        else {
                            const h1 = document.querySelector('h1');
                            if (h1)
                                h1.innerHTML = `Edit Board: <span id="board-title-display">${this.boardState.name}</span>`;
                        }
                        if (this.boardState.id && !window.location.pathname.includes(this.boardState.id.toString())) {
                            window.history.pushState({}, '', `/board/${this.boardState.id}/edit/`);
                        }
                    }
                }
                else {
                    let errorMsg = result.message || "Failed to save board.";
                    if (result.errors) {
                        errorMsg += "<ul>";
                        for (const field in result.errors) {
                            result.errors[field].forEach((err) => {
                                errorMsg += `<li>${field}: ${err}</li>`;
                            });
                        }
                        errorMsg += "</ul>";
                    }
                    this.showMessage(errorMsg, "error", false);
                }
            }
            catch (error) {
                console.error("Error saving board:", error);
                this.showMessage("An unexpected error occurred while saving.", "error");
            }
        });
    }
    getBoardAsImageDataURL() {
        return __awaiter(this, arguments, void 0, function* (format = 'image/png') {
            const rows = this.boardState.rows;
            const cols = this.boardState.cols;
            const dots = this.boardState.dots;
            if (rows <= 0 || cols <= 0 || this.cellSizePx <= 0) {
                console.error("Board dimensions or cell size invalid for image generation.");
                return null;
            }
            const canvas = document.createElement('canvas');
            const canvasWidth = cols * this.cellSizePx;
            const canvasHeight = rows * this.cellSizePx;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            const ctx = canvas.getContext('2d');
            if (!ctx) {
                console.error("Could not get 2D context from canvas");
                return null;
            }
            // 1. Draw background (optional)
            ctx.fillStyle = "#FFFFFF"; // White background
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            // 2. Draw grid lines
            ctx.strokeStyle = "#CCCCCC"; // Light grey for grid lines
            ctx.lineWidth = 1;
            for (let r = 0; r <= rows; r++) {
                ctx.beginPath();
                ctx.moveTo(0, r * this.cellSizePx);
                ctx.lineTo(canvas.width, r * this.cellSizePx);
                ctx.stroke();
            }
            for (let c = 0; c <= cols; c++) {
                ctx.beginPath();
                ctx.moveTo(c * this.cellSizePx, 0);
                ctx.lineTo(c * this.cellSizePx, canvas.height);
                ctx.stroke();
            }
            // 3. Draw the colored dots
            const dotRadius = this.cellSizePx * 0.35; // 35% of cell size for dot radius
            dots.forEach(dot => {
                const centerX = dot.col * this.cellSizePx + this.cellSizePx / 2;
                const centerY = dot.row * this.cellSizePx + this.cellSizePx / 2;
                ctx.beginPath();
                ctx.arc(centerX, centerY, dotRadius, 0, 2 * Math.PI, false);
                ctx.fillStyle = dot.color;
                ctx.fill();
                // Optional: add a border to dots
                // ctx.lineWidth = 1;
                // ctx.strokeStyle = '#333333';
                // ctx.stroke();
            });
            return canvas.toDataURL(format);
        });
    }
    handleSaveAsImage() {
        return __awaiter(this, void 0, void 0, function* () {
            this.showMessage("Generating image...", "info", false);
            const imageDataURL = yield this.getBoardAsImageDataURL();
            if (!imageDataURL) {
                this.showMessage("Failed to generate image data.", "error");
                return;
            }
            // Prepare data for backend
            const boardName = this.boardState.name || "Generated Grid Board";
            const fileName = `${boardName.replace(/[^a-zA-Z0-9]/g, '_')}_${Date.now()}.png`;
            const payload = {
                name: boardName, // Name for the UserImage
                image_data_url: imageDataURL,
                filename: fileName // Suggested filename
            };
            try {
                const response = yield fetch('/api/save_grid_as_image/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': this.csrfToken,
                    },
                    body: JSON.stringify(payload)
                });
                const result = yield response.json();
                if (response.ok && result.status === 'success') {
                    this.showMessage(`Board saved as image: ${result.image_name}. You can now use it for path editing.`, "success");
                    // Optionally redirect or update UI
                }
                else {
                    this.showMessage(result.message || "Failed to save board as image on server.", "error");
                }
            }
            catch (error) {
                console.error("Error saving board as image:", error);
                this.showMessage("An error occurred while sending image to server.", "error");
            }
        });
    }
    showMessage(message, type, autoClear = true) {
        this.messagesDiv.innerHTML = `<p class="${type}">${message}</p>`;
        if (autoClear) {
            setTimeout(() => {
                this.messagesDiv.innerHTML = '';
            }, 5000);
        }
    }
}
document.addEventListener('DOMContentLoaded', () => {
    if (document.getElementById('grid-container')) {
        new BoardEditor();
    }
});
//# sourceMappingURL=grid.js.map

===== File: ./static/main/ts/dist/functions.js =====
"use strict";
// functions.ts
// --- Funkcje ---
function initializePageElements() {
    redrawLines();
    document.querySelectorAll('.click-dot').forEach(initializeDot);
    renumberDotsAndListItems();
}
function renumberDotsAndListItems() {
    const dots = document.querySelectorAll('.click-dot');
    dots.forEach((dot, index) => {
        const dotNumberElement = dot.querySelector('.dot-number');
        if (dotNumberElement) {
            dotNumberElement.innerText = (index + 1).toString();
        }
    });
    const listItems = document.querySelectorAll('#coordinates-list .coordinate-item');
    listItems.forEach((item, index) => {
        const pointDisplayNumber = item.querySelector('.point-display-number');
        if (pointDisplayNumber) {
            pointDisplayNumber.innerText = (index + 1).toString();
        }
    });
    redrawLines();
}
function redrawLines() {
    const svg = document.getElementById('connection-lines');
    if (!svg)
        return;
    svg.innerHTML = '';
    const dots = Array.from(document.querySelectorAll('.click-dot'));
    if (dots.length < 2)
        return;
    for (let i = 0; i < dots.length - 1; i++) {
        const dot1 = dots[i];
        const dot2 = dots[i + 1];
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        const x1 = parseFloat(dot1.style.left || '0');
        const y1 = parseFloat(dot1.style.top || '0');
        const x2 = parseFloat(dot2.style.left || '0');
        const y2 = parseFloat(dot2.style.top || '0');
        line.setAttribute('x1', x1.toString());
        line.setAttribute('y1', y1.toString());
        line.setAttribute('x2', x2.toString());
        line.setAttribute('y2', y2.toString());
        line.setAttribute('stroke-width', '2');
        line.setAttribute('stroke', '#ff0000');
        svg.appendChild(line);
    }
}
function createCoordinateListItem(clickId, x, y, isNew = false) {
    const listItem = document.createElement('li');
    listItem.classList.add('coordinate-item');
    if (!isNew && clickId !== null) {
        listItem.setAttribute('data-click-id', clickId.toString());
    }
    const pointNumberSpan = document.createElement('span');
    pointNumberSpan.classList.add('point-display-number');
    const inputX = document.createElement('input');
    inputX.type = 'number';
    inputX.classList.add('coord-x-input');
    inputX.value = x.toFixed(2);
    inputX.step = '0.01';
    inputX.autocomplete = 'off';
    const inputY = document.createElement('input');
    inputY.type = 'number';
    inputY.classList.add('coord-y-input');
    inputY.value = y.toFixed(2);
    inputY.step = '0.01';
    inputY.autocomplete = 'off';
    const updateButton = document.createElement('button');
    updateButton.classList.add('update-coord-btn');
    updateButton.textContent = isNew ? 'Save New' : 'Update';
    if (isNew) {
        updateButton.classList.add('save-new-coord-btn');
    }
    const deleteButton = document.createElement('button');
    deleteButton.classList.add('delete-coord-btn');
    deleteButton.textContent = 'Delete';
    listItem.appendChild(document.createTextNode('Point '));
    listItem.appendChild(pointNumberSpan);
    listItem.appendChild(document.createTextNode(': X '));
    listItem.appendChild(inputX);
    listItem.appendChild(document.createTextNode(' Y '));
    listItem.appendChild(inputY);
    listItem.appendChild(updateButton);
    listItem.appendChild(deleteButton);
    const coordinatesList = document.getElementById('coordinates-list');
    if (coordinatesList) {
        coordinatesList.appendChild(listItem);
    }
    else {
        console.error("Element with ID 'coordinates-list' not found.");
    }
    attachEventListenersToListItem(listItem, isNew);
    return listItem;
}
function attachEventListenersToListItem(listItem, isNewInitially = false) {
    const updateBtn = listItem.querySelector('.update-coord-btn');
    const deleteBtn = listItem.querySelector('.delete-coord-btn');
    const inputX = listItem.querySelector('.coord-x-input');
    const inputY = listItem.querySelector('.coord-y-input');
    let isStillNew = isNewInitially;
    if (!updateBtn || !deleteBtn || !inputX || !inputY) {
        console.error("Could not find all required elements within list item:", listItem);
        return;
    }
    console.log(`[attachEventListenersToListItem] For item data-id=${listItem.dataset.clickId}, X_val=${inputX.value}, Y_val=${inputY.value}`);
    updateBtn.addEventListener('click', function () {
        const currentClickIdStr = listItem.dataset.clickId;
        const currentClickId = currentClickIdStr ? parseInt(currentClickIdStr, 10) : null;
        const newX = parseFloat(inputX.value);
        const newY = parseFloat(inputY.value);
        if (isNaN(newX) || isNaN(newY)) {
            alert('Please enter valid numbers for X and Y.');
            return;
        }
        const requestBody = {
            item_id: selectedImageId,
            item_type: 'user_image',
            x: newX,
            y: newY,
            id: currentClickId
        };
        if (isStillNew || currentClickId === null) {
            fetch('/add-click/', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
                body: JSON.stringify({ image_id: requestBody.item_id, x: newX, y: newY })
            })
                .then(response => response.json())
                .then(data => {
                if (data.success && data.click_id !== undefined) {
                    listItem.setAttribute('data-click-id', data.click_id.toString());
                    updateBtn.textContent = 'Update';
                    if (updateBtn.classList.contains('save-new-coord-btn')) {
                        updateBtn.classList.remove('save-new-coord-btn');
                    }
                    isStillNew = false;
                    createDotOnImage(data.click_id, newX, newY);
                    renumberDotsAndListItems();
                }
                else {
                    alert('Failed to save new point. ' + (data.error || ''));
                }
            }).catch(error => console.error('Error saving new point:', error));
        }
        else {
            fetch('/update-click/', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
                body: JSON.stringify({ id: currentClickId, x: newX, y: newY })
            })
                .then(response => response.json())
                .then(data => {
                if (data.status === 'success') {
                    const dot = document.querySelector(`.click-dot[data-id="${currentClickId}"]`);
                    if (dot) {
                        dot.style.left = newX + 'px';
                        dot.style.top = newY + 'px';
                        redrawLines();
                    }
                }
                else {
                    alert('Failed to update point. ' + (data.message || ''));
                }
            }).catch(error => console.error('Error updating point:', error));
        }
    });
    listItem.addEventListener('mouseenter', () => {
        const clickId = listItem.dataset.clickId;
        if (!clickId)
            return;
        listItem.classList.add('highlighted');
        const dotElement = document.querySelector(`.click-dot[data-id="${clickId}"]`);
        if (dotElement) {
            dotElement.classList.add('highlighted');
        }
    });
    listItem.addEventListener('mouseleave', () => {
        const clickId = listItem.dataset.clickId;
        if (!clickId)
            return;
        listItem.classList.remove('highlighted');
        const dotElement = document.querySelector(`.click-dot[data-id="${clickId}"]`);
        if (dotElement) {
            dotElement.classList.remove('highlighted');
        }
    });
    deleteBtn.addEventListener('click', function () {
        const currentClickIdStr = listItem.dataset.clickId;
        if (isStillNew || !currentClickIdStr) {
            listItem.remove();
            renumberDotsAndListItems();
            return;
        }
        const currentClickId = parseInt(currentClickIdStr, 10);
        fetch('/delete-click/', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
            body: JSON.stringify({ id: currentClickId })
        })
            .then(response => response.json())
            .then(data => {
            if (data.status === 'deleted') {
                listItem.remove();
                const dot = document.querySelector(`.click-dot[data-id="${currentClickId}"]`);
                if (dot)
                    dot.remove();
                renumberDotsAndListItems();
            }
            else {
                alert('Failed to delete point.');
            }
        }).catch(error => console.error('Error deleting point:', error));
    });
    [inputX, inputY].forEach(inputField => {
        inputField.addEventListener('input', function () {
            const currentClickIdStr = listItem.dataset.clickId;
            if (currentClickIdStr && !isStillNew) {
                const currentClickId = parseInt(currentClickIdStr, 10);
                const dot = document.querySelector(`.click-dot[data-id="${currentClickId}"]`);
                if (dot) {
                    let newXFromInput = parseFloat(inputX.value);
                    let newYFromInput = parseFloat(inputY.value);
                    if (!isNaN(newXFromInput) && !isNaN(newYFromInput)) {
                        // --- BEGIN MODIFICATION: Clamp coordinates for live input update ---
                        const mainImageElement = document.getElementById('main-image');
                        let clampedX = newXFromInput;
                        let clampedY = newYFromInput;
                        if (mainImageElement) {
                            const dotWidth = 10; // As per CSS .click-dot width
                            const dotHeight = 10; // As per CSS .click-dot height
                            // Clamp X
                            if (mainImageElement.width < dotWidth) {
                                clampedX = mainImageElement.width / 2;
                            }
                            else {
                                const minXAllowed = dotWidth / 2;
                                const maxXAllowed = mainImageElement.width - (dotWidth / 2);
                                clampedX = Math.max(minXAllowed, Math.min(newXFromInput, maxXAllowed));
                            }
                            // Clamp Y
                            if (mainImageElement.height < dotHeight) {
                                clampedY = mainImageElement.height / 2;
                            }
                            else {
                                const minYAllowed = dotHeight / 2;
                                const maxYAllowed = mainImageElement.height - (dotHeight / 2);
                                clampedY = Math.max(minYAllowed, Math.min(newYFromInput, maxYAllowed));
                            }
                            // Update input field if value was clamped, to give feedback
                            if (clampedX.toFixed(2) !== newXFromInput.toFixed(2) && inputField === inputX) {
                                inputX.value = clampedX.toFixed(2);
                            }
                            if (clampedY.toFixed(2) !== newYFromInput.toFixed(2) && inputField === inputY) {
                                inputY.value = clampedY.toFixed(2);
                            }
                        }
                        else {
                            console.warn("Main image element not found, cannot apply boundary constraints for live input.");
                        }
                        // --- END MODIFICATION ---
                        dot.style.left = clampedX + 'px';
                        dot.style.top = clampedY + 'px';
                        redrawLines();
                    }
                }
            }
        });
    });
}
function initializeCoordinateListInteractions() {
    document.querySelectorAll('#coordinates-list .coordinate-item').forEach(item => {
        const clickId = item.dataset.clickId;
        if (clickId) {
            attachEventListenersToListItem(item, false);
        }
    });
    const addPointToListBtn = document.getElementById('add-point-on-list-btn');
    if (addPointToListBtn) {
        addPointToListBtn.addEventListener('click', () => {
            const mainImage = document.getElementById('main-image');
            const defaultX = mainImage ? mainImage.width / 2 : 50;
            const defaultY = mainImage ? mainImage.height / 2 : 50;
            createCoordinateListItem(null, defaultX, defaultY, true);
            renumberDotsAndListItems();
        });
    }
}
function initializeDot(dot) {
    const image = document.getElementById("main-image");
    dot.addEventListener("mousedown", (e) => {
        if (e.button !== 0)
            return;
        draggedDot = dot;
        e.preventDefault();
        document.addEventListener('mouseup', handleDocumentMouseUp, { once: true });
    });
    const deleteBtn = dot.querySelector('.delete-dot-btn');
    if (deleteBtn) {
        deleteBtn.addEventListener('click', function (e) {
            e.stopPropagation();
            const clickIdStr = dot.dataset.id;
            if (!clickIdStr) {
                console.warn("Dot has no data-id for deletion:", dot);
                return;
            }
            const clickId = parseInt(clickIdStr, 10);
            fetch('/delete-click/', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
                body: JSON.stringify({ id: clickId })
            })
                .then(response => response.json())
                .then(data => {
                if (data.status === 'deleted') {
                    dot.remove();
                    const listItem = document.querySelector(`#coordinates-list .coordinate-item[data-click-id="${clickId}"]`);
                    if (listItem)
                        listItem.remove();
                    renumberDotsAndListItems();
                }
                else {
                    alert('Failed to delete point.');
                }
            }).catch(error => console.error('Error deleting point:', error));
        });
    }
    dot.addEventListener('mouseenter', () => {
        const clickId = dot.dataset.id;
        if (!clickId)
            return;
        dot.classList.add('highlighted');
        const listItem = document.querySelector(`#coordinates-list .coordinate-item[data-click-id="${clickId}"]`);
        if (listItem) {
            listItem.classList.add('highlighted');
        }
    });
    dot.addEventListener('mouseleave', () => {
        const clickId = dot.dataset.id;
        if (!clickId)
            return;
        dot.classList.remove('highlighted');
        const listItem = document.querySelector(`#coordinates-list .coordinate-item[data-click-id="${clickId}"]`);
        if (listItem) {
            listItem.classList.remove('highlighted');
        }
    });
}
function handleDocumentMouseUp() {
    if (!draggedDot)
        return;
    const finalX = parseFloat(draggedDot.style.left || '0');
    const finalY = parseFloat(draggedDot.style.top || '0');
    const clickIdStr = draggedDot.dataset.id;
    if (!clickIdStr) {
        console.error("Dragged dot has no data-id for update:", draggedDot);
        draggedDot = null;
        return;
    }
    const clickId = parseInt(clickIdStr, 10);
    fetch('/update-click/', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
        body: JSON.stringify({ id: clickId, x: finalX, y: finalY })
    })
        .then(response => {
        if (!response.ok) {
            console.error('Position save failed after drag for dot ID:', clickId, response.statusText);
        }
        return response.json();
    })
        .then(data => {
        if (data.status !== 'success') {
            console.warn('Update click response status not success:', data);
        }
    })
        .catch(error => console.error('Error updating position after drag:', error));
    draggedDot = null;
}
function createDotOnImage(clickId, x, y) {
    const container = document.getElementById('image-container');
    if (!container) {
        console.error("Element with ID 'image-container' not found.");
        throw new Error("Image container not found, cannot create dot.");
    }
    const dot = document.createElement('div');
    dot.className = 'click-dot';
    dot.style.left = `${x}px`;
    dot.style.top = `${y}px`;
    dot.setAttribute('data-id', clickId.toString());
    dot.innerHTML = `<span class="dot-number"></span>
                    <button class="delete-dot-btn" title="Delete this point">✖</button>`;
    container.appendChild(dot);
    initializeDot(dot);
    return dot;
}
//# sourceMappingURL=functions.js.map

===== File: ./main/permissions.py =====
# permissions.py
from rest_framework import permissions

class IsOwner(permissions.BasePermission):
    def has_object_permission(self, request, view, obj):
        return obj.user == request.user 

===== File: ./main/forms.py =====
from django import forms
from .models import UserImage, CommonImage

class UserImageForm(forms.ModelForm):
    class Meta:
        model = UserImage
        fields = ['name', 'image']

class CommonImageUploadForm(forms.ModelForm): # New form
    class Meta:
        model = CommonImage
        fields = ['name', 'image', 'description']
        widgets = {
            'description': forms.Textarea(attrs={'rows': 3}),
        }
        help_texts = {
            'name': 'A unique name for this shared image.',
            'image': 'Select the image file.',
            'description': 'Optional: Briefly describe the image.'
        }

class DefineGridForm(forms.Form): # New form for grid definition
    name = forms.CharField(max_length=100, label="Grid Name", help_text="Name for this grid image.")
    columns = forms.IntegerField(min_value=1, max_value=50, initial=5, label="Columns (Vertical Lines)")
    rows = forms.IntegerField(min_value=1, max_value=50, initial=5, label="Rows (Horizontal Lines)")

===== File: ./main/admin.py =====
# main/admin.py
from django.contrib import admin
from .models import UserImage, ImageClick, CommonImage, GameBoard, Reaction # Dodaj Reaction


@admin.register(Reaction)
class ReactionAdmin(admin.ModelAdmin):
    list_display = ('user', 'reaction_type', 'content_object_display', 'timestamp')
    list_filter = ('reaction_type', 'content_type', 'timestamp')
    search_fields = ('user__username',)
    readonly_fields = ('content_object_display',) # Aby uniknąć problemów z GenericForeignKey w edycji

    def content_object_display(self, obj):
        return str(obj.content_object)
    content_object_display.short_description = 'Reacted To'

@admin.register(GameBoard)
class GameBoardAdmin(admin.ModelAdmin):
    list_display = ('name', 'user', 'rows', 'cols', 'get_dots_count', 'get_paths_count')
    list_filter = ('user', 'rows', 'cols')
    search_fields = ('name', 'user__username')
    readonly_fields = ('dots_config_pretty', 'paths_config_pretty') # If you have these methods

    fieldsets = (
        (None, {
            'fields': ('user', 'name', 'rows', 'cols')
        }),
        ('Configuration (Raw JSON - Edit with caution)', {
            'classes': ('collapse',),
            'fields': ('dots_config', 'paths_config'), # Ensure paths_config is here
        }),
        ('Configuration (Formatted View)', { # Assuming you have these helper methods
            'fields': ('dots_config_pretty', 'paths_config_pretty'),
        }),
    )

    def get_dots_count(self, obj):
        if isinstance(obj.dots_config, list):
            return len(obj.dots_config)
        return 0
    get_dots_count.short_description = 'Dots Count'

    def get_paths_count(self, obj):
        if isinstance(obj.paths_config, list): # Check the new paths_config field
            return len(obj.paths_config)
        return 0
    get_paths_count.short_description = 'Paths Count'

    def dots_config_pretty(self, obj):
        import json
        from django.utils.html import format_html
        formatted_json = json.dumps(obj.dots_config, indent=4)
        return format_html("<pre>{}</pre>", formatted_json)
    dots_config_pretty.short_description = 'Dots Config (Formatted)'

    def paths_config_pretty(self, obj):
        import json
        from django.utils.html import format_html
        formatted_json = json.dumps(obj.paths_config, indent=4)
        return format_html("<pre>{}</pre>", formatted_json)
    paths_config_pretty.short_description = 'Paths Config (Formatted)'


@admin.register(UserImage) # Use the decorator for cleaner registration
class UserImageAdmin(admin.ModelAdmin):
    list_display = ('name', 'user', 'image_thumbnail') # Added thumbnail for better display
    list_filter = ('user',)
    search_fields = ('name', 'user__username')
    readonly_fields = ('image_preview',) # For a larger preview in the detail view

    def image_thumbnail(self, obj):
        from django.utils.html import format_html
        if obj.image:
            return format_html('<img src="{}" style="width: 45px; height:45px; object-fit:cover;" />', obj.image.url)
        return "No Image"
    image_thumbnail.short_description = 'Thumbnail'

    def image_preview(self, obj):
        from django.utils.html import format_html
        if obj.image:
            return format_html('<img src="{}" style="max-width: 200px; max-height:200px;" />', obj.image.url)
        return "No Image"
    image_preview.short_description = 'Image Preview'


# --- ImageClick Admin (Optional: can be an inline in UserImageAdmin) ---
@admin.register(ImageClick)
class ImageClickAdmin(admin.ModelAdmin):
    list_display = ('id', 'user', 'image_name', 'x', 'y')
    list_filter = ('user', 'image')
    search_fields = ('image__name', 'user__username')

    def image_name(self, obj):
        return obj.image.name
    image_name.short_description = 'On Image'
    image_name.admin_order_field = 'image__name'


# --- CommonImage Admin ---
@admin.register(CommonImage)
class CommonImageAdmin(admin.ModelAdmin):
    list_display = ('name', 'image_thumbnail', 'description')
    search_fields = ('name', 'description')
    readonly_fields = ('image_preview',)

    def image_thumbnail(self, obj):
        from django.utils.html import format_html
        if obj.image:
            return format_html('<img src="{}" style="width: 45px; height:45px; object-fit:cover;" />', obj.image.url)
        return "No Image"
    image_thumbnail.short_description = 'Thumbnail'

    def image_preview(self, obj):
        from django.utils.html import format_html
        if obj.image:
            return format_html('<img src="{}" style="max-width: 200px; max-height:200px;" />', obj.image.url)
        return "No Image"
    image_preview.short_description = 'Image Preview'

===== File: ./main/signals.py =====
# main/signals.py
from django.db.models.signals import post_save
from django.dispatch import receiver
from .models import GameBoard, UserImage, ImageClick
from .event_queue import broadcast_event

@receiver(post_save, sender=GameBoard)
def game_board_saved_handler(sender, instance: GameBoard, created: bool, **kwargs):
    print(f"SIGNAL [game_board_saved_handler]: Fired for GameBoard ID {instance.id}. CREATED: {created}")
    if created:
        try:
            creator_username = instance.user.username
        except AttributeError:
            creator_username = "UnknownUser"
            print(f"SIGNAL [game_board_saved_handler]: Warning - User or username not found for GameBoard ID {instance.id}")

        print(f"SIGNAL [game_board_saved_handler]: New GameBoard - ID: {instance.id}, Name: {instance.name}")
        event_data = {
            "board_id": instance.id,
            "board_name": instance.name,
            "creator_username": creator_username
        }
        broadcast_event(event_type="newBoard", data=event_data)
    else:
        print(f"SIGNAL [game_board_saved_handler]: GameBoard ID {instance.id} updated, not new. No 'newBoard' SSE event.")

@receiver(post_save, sender=UserImage)
def user_image_saved_handler(sender, instance: UserImage, created: bool, **kwargs): # Zmieniona nazwa handlera dla jasności
    """
    Wysyła zdarzenie 'newPath' GDY UserImage jest tworzony LUB aktualizowany.
    Jeśli jest tworzony, to jest to nowy obrazek do rysowania ścieżek.
    Jeśli jest aktualizowany, zakładamy, że konfiguracja ścieżek mogła się zmienić.
    """
    print(f"SIGNAL [user_image_saved_handler]: Fired for UserImage ID {instance.id}. CREATED: {created}")
    
    try:
        user_username = instance.user.username
    except AttributeError:
        user_username = "UnknownUser"
        print(f"SIGNAL [user_image_saved_handler]: Warning - User for UserImage ID {instance.id} not found.")

    action_type = "created" if created else "updated"
    print(f"SIGNAL [user_image_saved_handler]: UserImage {action_type} - ID: {instance.id}, Name: {instance.name}. Sending 'newPath' event.")
    
    event_data = {
        "path_id": None,  # Dla ogólnego zdarzenia UserImage, nie mamy konkretnego ID ścieżki
        "board_id": instance.id, # ID UserImage traktujemy jako ID planszy
        "board_name": instance.name,
        "user_username": user_username, # Użytkownik, który jest właścicielem/modyfikował
        "action": action_type # Dodatkowa informacja dla frontendu, czy obraz został utworzony czy zaktualizowany
    }
    broadcast_event(event_type="newPath", data=event_data)


@receiver(post_save, sender=ImageClick)
def image_click_created_handler(sender, instance: ImageClick, created: bool, **kwargs):
    """
    Wysyła zdarzenie 'newPath' GDY tworzony jest NOWY ImageClick.
    """
    print(f"SIGNAL [image_click_created_handler]: Fired for ImageClick ID {instance.id}. CREATED: {created}")
    if created: # Tylko przy tworzeniu nowego punktu
        try:
            user_username = instance.user.username
        except AttributeError:
            user_username = "UnknownUser"
            print(f"SIGNAL [image_click_created_handler]: Warning - User for ImageClick ID {instance.id} not found.")
        
        try:
            image_id = instance.image.id
            image_name = instance.image.name
        except AttributeError:
            image_id = None
            image_name = "UnknownImage"
            print(f"SIGNAL [image_click_created_handler]: Warning - Image for ImageClick ID {instance.id} not found.")

        print(f"SIGNAL [image_click_created_handler]: New ImageClick created - ID: {instance.id} on Image ID {image_id}. Sending 'newPath' event.")
        event_data = {
            "path_id": instance.id,
            "board_id": image_id,
            "board_name": image_name,
            "user_username": user_username,
            "action": "point_added" # Specyficzna akcja dla dodania punktu
        }
        broadcast_event(event_type="newPath", data=event_data)

===== File: ./main/models.py =====
from django.db import models
from django.contrib.auth.models import User
import uuid
from django.conf import settings
from django.db.models.signals import post_save
from django.dispatch import receiver
from rest_framework.authtoken.models import Token
from django.core.exceptions import ValidationError
from django.contrib.auth.models import User
from django.contrib.contenttypes.fields import GenericForeignKey
from django.contrib.contenttypes.models import ContentType

class Reaction(models.Model):
    REACTION_CHOICES = [
        ('heart', '❤️'),
        ('gasp', '😮'),
        ('grin', '😄'),
    ]

    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name="reactions")
    reaction_type = models.CharField(max_length=10, choices=REACTION_CHOICES)
    timestamp = models.DateTimeField(auto_now_add=True)

    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)
    object_id = models.PositiveIntegerField()
    content_object = GenericForeignKey('content_type', 'object_id') # Obiekt, na który jest reakcja

    class Meta:
        ordering = ['-timestamp']
        unique_together = ('user', 'content_type', 'object_id') # Użytkownik może mieć tylko jedną reakcję na dany obiekt

    def __str__(self):
        return f"{self.user.username} reacted with {self.get_reaction_type_display()} to {self.content_object}"
    
class UserImage(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='images')
    name = models.CharField(max_length=100, unique=True)
    image = models.ImageField(upload_to='uploads/%Y/%m/%d/')

    def save(self, *args, **kwargs):
        if not self.name:
            self.name = f"{self.user.id}_{uuid.uuid4().hex}"

        super().save(*args, **kwargs)

    def __str__(self):
        return self.name
    
class ImageClick(models.Model):
    image = models.ForeignKey(UserImage, on_delete=models.CASCADE, related_name='clicks')
    user = models.ForeignKey(User, on_delete=models.CASCADE, default=1)
    x = models.FloatField()
    y = models.FloatField()

    def __str__(self):
        return f"Click on {self.image.name} by {self.user} at ({self.x}, {self.y})"

class CommonImage(models.Model):
    name = models.CharField(max_length=100, unique=True, help_text="Descriptive name for the common image.")
    image = models.ImageField(upload_to='common_images/%Y/%m/%d/', help_text="The actual image file.")
    description = models.TextField(blank=True, null=True, help_text="Optional description.")
    def __str__(self):
        return self.name

    class Meta:
        ordering = ['name']
        verbose_name = "Common Image"
    

@receiver(post_save, sender=settings.AUTH_USER_MODEL)
def create_auth_token(sender, instance=None, created=False, **kwargs):
    if created:
        Token.objects.create(user=instance)

class GameBoard(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='game_boards')
    name = models.CharField(max_length=100, default="Untitled Board")
    rows = models.PositiveIntegerField()
    cols = models.PositiveIntegerField()
    dots_config = models.JSONField(default=list, blank=True)

    def __str__(self):
        return f"{self.name} ({self.rows}x{self.cols}) by {self.user.username}"

    def clean(self):
        super().clean()
        if not (1 < self.rows <= 50): # Example limits
            raise ValidationError({'rows': 'Rows must be between 2 and 50.'})
        if not (1 < self.cols <= 50): # Example limits
            raise ValidationError({'cols': 'Columns must be between 2 and 50.'})

        if self.dots_config:
            if not isinstance(self.dots_config, list):
                raise ValidationError({'dots_config': 'Dots configuration must be a list.'})

            dot_colors_count = {}
            occupied_cells = set()

            for dot in self.dots_config:
                if not all(k in dot for k in ['row', 'col', 'color']):
                    raise ValidationError({'dots_config': 'Each dot must have row, col, and color.'})
                if not (0 <= dot['row'] < self.rows and 0 <= dot['col'] < self.cols):
                    raise ValidationError({'dots_config': f"Dot at ({dot['row']},{dot['col']}) is out of bounds."})

                cell = (dot['row'], dot['col'])
                if cell in occupied_cells:
                    raise ValidationError({'dots_config': f"Cell ({dot['row']},{dot['col']}) is occupied by more than one dot."})
                occupied_cells.add(cell)

                dot_colors_count[dot['color']] = dot_colors_count.get(dot['color'], 0) + 1

            for color, count in dot_colors_count.items():
                if count != 2:
                    raise ValidationError({'dots_config': f"Color {color} must be used for exactly two dots. Found {count}."})

    def save(self, *args, **kwargs):
        self.full_clean() # Call clean() before saving
        super().save(*args, **kwargs)


===== File: ./main/templates/rest_framework/api.html =====
{% extends "rest_framework/base.html" %}  {# extend DRF’s base layout #}
{% load i18n %}                            {# for translating strings #}

{# Optionally override the Bootstrap theme – you can point this to your own CSS if you like #}
{% block bootstrap_theme %}
  <link
    rel="stylesheet"
    href="https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css"
    integrity="sha384-7nHVqZgEfT1Z2YKzy+YBmfmhgcKs4JXQgnauVpD6vSBOVTY7TsIseQ3C6E+
    Ai5oX" crossorigin="anonymous"
  >
{% endblock %}

{# You can override other blocks here (e.g. navbar, branding) if you need to customize the header #}

{# Finally, render the standard browsable API content #}
{% block content %}
  {{ block.super }}
{% endblock %}


===== File: ./main/templates/registration/login.html =====
{% extends "game_board/base.html" %}

{% block title %}Login{% endblock %}

{% block content %}
  <h2>Login</h2>
  {% if form.errors %}
    <p style="color: red;">Your username and password didn't match. Please try again.</p>
  {% endif %}

  {% if next %}
    {% if user.is_authenticated %}
      <p>Your account doesn't have access to this page. To proceed,
      please login with an account that has access.</p>
    {% else %}
      <p>Please login to see this page.</p>
    {% endif %}
  {% endif %}

  <form method="post" action="{% url 'login' %}">
    {% csrf_token %}
    <table>
      <tr>
        <td>{{ form.username.label_tag }}</td>
        <td>{{ form.username }}</td>
      </tr>
      <tr>
        <td>{{ form.password.label_tag }}</td>
        <td>{{ form.password }}</td>
      </tr>
    </table>
    <input type="submit" value="Login" class="button">
    <input type="hidden" name="next" value="{{ next }}">
  </form>

  <p>Don't have an account? <a href="{% url 'register' %}">Sign up here</a>.</p> {# <-- ADD THIS LINE #}

{% endblock %}

===== File: ./main/templates/registration/register.html =====
{% extends "game_board/base.html" %} {# Or your project's main base template #}

{% block title %}Sign Up{% endblock %}

{% block content %}
  <h2>Sign Up</h2>
  <form method="post">
    {% csrf_token %}
    {{ form.as_p }} {# This will render the form fields as paragraphs #}
    <button type="submit" class="button">Sign Up</button>
  </form>
  <p>Already have an account? <a href="{% url 'login' %}">Login here</a>.</p>
{% endblock %}

===== File: ./main/templates/game_board/board_list.html =====
{% extends "main/base.html" %}
{% load static %} {# Good practice to include if you might add static files to this template later #}

{% block title %}My Connect-Dots Boards{% endblock %}

{% block head_extra %}
 
{% endblock %}

{% block content %}
    <h2>My Connect-Dots Boards</h2>
    <a href="{% url 'game_board:board_create' %}">Create New Board</a>
    <hr style="margin-bottom: 20px;">

    {% if boards %}
        <ul class="board-list">
            {% for board in boards %}
            <li class="board-item">
                <h3>{{ board.name }}</h3>
                <p>Dimensions: {{ board.rows }} rows × {{ board.cols }} columns</p>
                <p>Dot Pairs: ({{ board.dots_config|length }} dots total)</p>
                {# You could add a small visual preview of the board here if desired #}
                <a href="{% url 'game_board:board_edit' board.id %}">View</a>
                <form action="{% url 'game_board:board_delete' board.id %}" method="post" style="display: inline;" onsubmit="return confirm('Are you sure you want to delete the board \'{{ board.name|escapejs }}\'?');">
                    {% csrf_token %}
                    <button type="submit">Delete</button>
                </form>
            </li>
            {% endfor %}
        </ul>
    {% else %}
        <p class="no-boards-message">You haven't created any Connect-Dots boards yet. <a href="{% url 'game_board:board_create' %}">Create one now!</a></p>
    {% endif %}
{% endblock %}

{% block extra_js %}
<script src="{% static 'main/ts/dist/grid.js' %}"></script>
{% endblock %}



===== File: ./main/templates/game_board/board_editor.html =====
{% extends "main/base.html" %}
{% load static %}

{% block title %}{% if board_instance %}Edit {{ board_instance.name }}{% else %}Create New Board{% endif %}{% endblock %}

{% block head_extra %}
<style>
    #grid-container {
        display: grid;
        border: 1px solid #ccc;
        margin-bottom: 20px;
        user-select: none;
    }
    .grid-cell {
        border: 1px solid #eee;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        transition: background-color 0.2s;
    }
    .grid-cell:hover {
        background-color: #f0f0f0;
    }
    .grid-cell .dot-visual {
        width: 70%;
        height: 70%;
        border-radius: 50%;
        box-shadow: inset 0 0 3px rgba(0,0,0,0.3);
    }
    #color-palette { margin-bottom: 15px; }
    .color-button {
        width: 30px; height: 30px; border: 2px solid #fff;
        margin-right: 5px; cursor: pointer; display: inline-block;
        border-radius: 50%;
    }
    .color-button.selected {
        border-color: #000;
        box-shadow: 0 0 5px #000;
    }
    #messages { margin-top: 10px; }
    .success { color: green; }
    .error { color: red; }
</style>
{% endblock %}

{% block content %}
<h1>{% if board_instance %}Edit Board: <span id="board-title-display">{{ board_instance.name }}</span>{% else %}Create New Board{% endif %}</h1>

{% csrf_token %}
<input type="hidden" id="boardId" value="{{ board_instance.id | default:'' }}">
<script id="initial-board-data" type="application/json">
    {{ initial_board_data_json | safe }}
</script>

<div class="form-group">
    <label for="boardName">Board Name:</label>
    <input type="text" id="boardName" value="{{ board_instance.name | default:'My New Board' }}">
</div>

<div class="form-group">
    <label for="numRows">Rows:</label>
    <input type="number" id="numRows" value="{{ board_instance.rows | default:5 }}" min="2" max="50">
</div>

<div class="form-group">
    <label for="numCols">Columns:</label>
    <input type="number" id="numCols" value="{{ board_instance.cols | default:5 }}" min="2" max="50">
</div>

<button id="generateGridButton" class="button">Generate/Update Grid</button>
<hr>

<h3>Select Color & Place Dots:</h3>
<div id="color-palette">
</div>
<p>Selected Color: <span id="selected-color-display">None</span></p>
<p>Instructions: Select a color, then click two empty cells to place a pair of dots. Click an existing dot of the selected color to remove it.</p>

<div id="grid-container">
</div>


<button id="saveBoardButton" class="button">Save Board</button>
<button id="saveAsImageButton" class="button" >Save as Path Background</button>
<div id="messages"></div>

{% endblock %}

{% block extra_js %}
<script src="{% static 'main/ts/dist/grid.js' %}"></script>
{% endblock %}

===== File: ./main/templates/game_board/base.html =====
{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}Connect The Dots Board Editor{% endblock %}</title>
    <!-- Simple styling, replace with Bootstrap or your preferred CSS framework -->
    <style>
        body { font-family: sans-serif; margin: 20px; background-color: #f4f4f4; }
        nav { margin-bottom: 20px; background-color: #333; padding: 10px; border-radius: 5px; }
        nav a { color: white; margin-right: 15px; text-decoration: none; }
        nav a:hover { text-decoration: underline; }
        .container { background-color: white; padding: 20px; border-radius: 5px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        h1, h2 { color: #333; }
        table { width: 100%; border-collapse: collapse; margin-bottom: 20px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f0f0f0; }
        .button, button {
            background-color: #007bff; color: white; padding: 10px 15px;
            border: none; border-radius: 4px; cursor: pointer; text-decoration: none;
            font-size: 1em; margin-right: 5px;
        }
        .button:hover, button:hover { background-color: #0056b3; }
        .button-danger { background-color: #dc3545; }
        .button-danger:hover { background-color: #c82333; }
        .form-group { margin-bottom: 15px; }
        .form-group label { display: block; margin-bottom: 5px; }
        .form-group input[type="text"], .form-group input[type="number"] {
            width: calc(100% - 22px); padding: 10px; border: 1px solid #ccc; border-radius: 4px;
        }
        .error-message { color: red; font-size: 0.9em; }
    </style>
    {% block head_extra %}{% endblock %}
</head>
<body>
    <nav>
        <a href="{% url 'game_board:board_list' %}">My Boards</a>
        <a href="{% url 'game_board:board_create' %}">Create New Board</a>
        {% if user.is_authenticated %}
            <span>Welcome, {{ user.username }}!</span>
            <a href="{% url 'logout' %}" style="float:right;">Logout</a>
        {% else %}
            <a href="{% url 'login' %}" style="float:right;">Login</a>
        {% endif %}
    </nav>
    <div class="container">
        {% block content %}{% endblock %}
    </div>
    {% block scripts_extra %}{% endblock %}
</body>
</html>

===== File: ./main/templates/main/login.html =====
{% extends "main/base.html" %}
{% load static %}

{% block title %}Login{% endblock title %}

{% block content %}
    <h2>Login</h2>
    <form method="post" action="{% url 'login' %}">
        {% csrf_token %}
        {{ form.as_p }}
        <button type="submit">Login</button>
    </form>
    <p>Don't have an account? <a href="{% url 'register' %}">Register here</a></p>
{% endblock content %}

===== File: ./main/templates/main/upload_common_image.html =====
{% extends "main/base.html" %}
{% load static %}

{% block title %}Upload a Common Path{% endblock title %}

{% block content %}
    <h2>Upload an Path to the Common Library</h2>
    <p>This path will be available for other users to use.</p>
    <form method="POST" enctype="multipart/form-data" action="{% url 'upload_common_image' %}">
        {% csrf_token %}
        {{ form.as_p }}
        <button type="submit">Upload Common Image</button>
    </form>
    <br>
    <a href="{% url 'home' %}">Back to Home</a>
{% endblock content %}

===== File: ./main/templates/main/upload_image.html =====
{% extends "main/base.html" %}
{% load static %}

{% block title %}Upload Path{% endblock title %}

{% block content %}
    <h2>Upload a new path</h2>
    <form method="POST" enctype="multipart/form-data" action="{% url 'upload_image' %}">
        {% csrf_token %}
        {{ form.as_p }}
        <button type="submit">Upload</button>
    </form>
{% endblock content %}

===== File: ./main/templates/main/user_panel.html =====
{% extends "main/base.html" %}
{% load static %}

{% block title %}User Panel - {{ user.username }}{% endblock title %}

{% block content %}
    <h2>Login: {{ user.username }}</h2>

    <h3>Your Personal Paths</h3>
    {% if images %}
    <ul>
        {% for image_obj in images %}
        <li>
            <p>{{ image_obj.name }}</p>
            <img src="{{ image_obj.image.url }}" alt="{{ image_obj.name }}" width="100" height="100">
            <form action="{% url 'user_panel' %}" method="post" style="display: inline-block; margin-right: 10px;">
                {% csrf_token %}
                <input type="hidden" name="image_id_for_rename" value="{{ image_obj.id }}">
                <input type="text" name="name" value="{{ image_obj.name }}" placeholder="New name" required>
                <button type="submit" name="action" value="rename_image">Rename</button>
            </form>
            <a href="{% url 'delete_image' image_obj.id %}" onclick="return confirm('Are you sure you want to delete this image and its points?');" style="display: inline-block;">Delete</a>
        </li>
        {% endfor %}
    </ul>
    {% else %}
    <p>You have not uploaded any paths yet. <a href="{% url 'upload_image' %}">Upload one now.</a></p>
    {% endif %}

    <hr>
    <h3>Upload New Path from Panel</h3>
    <form method="POST" enctype="multipart/form-data" action="{% url 'user_panel' %}">
        {% csrf_token %}
        {{ upload_form.as_p }} {# Assuming you pass 'upload_form' from the view for new uploads #}
        <button type="submit" name="action" value="upload_new_image">Upload New Path</button>
    </form>
    <hr>

    <h3>Change Your Password</h3>
    <form method="post" action="{% url 'change_password' %}">
        {% csrf_token %}
        {{ password_form.as_p }}
        <button type="submit">Change Password</button>
    </form>
{% endblock content %}

===== File: ./main/templates/main/define_grid.html =====
{% extends "main/base.html" %}
{% load static %}

{% block title %}Define New Grid Image{% endblock title %}

{% block content %}
    <h2>Define Your Grid Image</h2>
    <p>Specify the dimensions for your grid. An image representing this grid will be generated and added to your personal images.</p>
    <form method="post" action="{% url 'define_grid' %}">
        {% csrf_token %}
        {{ form.as_p }}
        <button type="submit">Create Grid Image</button>
    </form>
    <br>
    <a href="{% url 'home' %}">Back to Home</a>
{% endblock content %}

===== File: ./main/templates/main/base.html =====
{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}Path Editor{% endblock title %}</title>
    <link rel="stylesheet" href="{% static 'main/css/style.css' %}"> {# Assuming your main CSS is here #}
    {% block extra_css %}{% endblock extra_css %}
    {% block head_extra %}{% endblock head_extra %}
</head>
<body>
    <div id="toast-container"></div>
    <nav>
        <a href="{% url 'home' %}">Home</a>
        {% if user.is_authenticated %}
            <a href="{% url 'user_panel' %}">My Paths</a>
            <a href="{% url 'upload_image' %}">Upload Personal Path</a>
            <a href="{% url 'upload_common_image' %}">Upload Common Path</a>
            <a href="{% url 'game_board:board_list' %}">My Boards</a>
            <a href="{% url 'game_board:board_create' %}">Create New Board</a>
            <a href="{% url 'logout' %}" style="float:right;">Logout </a>
        {% else %}
            <a href="{% url 'login' %}">Login</a>
            {% if not on_register_page %} {# Assuming you have a context variable 'on_register_page' #}
                <a href="{% url 'register' %}">Register</a>
            {% endif %}
        {% endif %}
    </nav>
    <hr>
    <main>
        {% block content %}
        {% endblock content %}
    </main>
    {% block extra_js %}
    {% endblock extra_js %}
    {% if user.is_authenticated %} {# Inicjuj SSE tylko dla zalogowanych użytkowników #}
        <script src="{% static 'main/ts/dist/sseNotifications.js' %}"></script> 
    {% endif %}
</body>
</html>

===== File: ./main/templates/main/home.html =====
{% extends "main/base.html" %}
{% load static %}

{% block title %}Home - Image Path Editor{% endblock title %}

{% block content %}
    <h2>Welcome, {{ user.username }}!</h2>

    {# --- IMAGE SELECTION SECTION --- #}
    {% if not selected_image %}
        <form method="get" action="{% url 'home' %}">
            <label for="image-select">Personal paths:</label>
            <select name="selected" id="image-select" onchange="this.form.submit()">
                <option value="">-- choose an image --</option>
                {% for img in user_images %}
                    <option value="{{ img.name }}">
                        {{ img.name }} (Yours)
                    </option>
                {% endfor %}
            </select>
        </form>
        <a href="{% url 'upload_image' %}">Upload a new personal image</a>

        <hr>
        <h3>Or Use a Common Image:</h3>
        {% if common_images_list %}
            <div class="common-images-grid" style="display: flex; flex-wrap: wrap; gap: 10px;">
                {% for c_img in common_images_list %}
                    <div class="common-image-item" style="border: 1px solid #ccc; padding: 5px; text-align: center;">
                        <p>{{ c_img.name }}</p>
                        {% if c_img.image %}
                        <img src="{{ c_img.image.url }}" alt="{{ c_img.name }}" width="100" height="100" style="object-fit: cover;">
                        <br>
                        <a href="{% url 'use_common_image' c_img.id %}">Use this image</a>
                        {% else %}
                        <p>Image not available</p>
                        {% endif %}
                    </div>
                {% endfor %}
            </div>
        {% else %}
            <p>No common images available at the moment.</p>
        {% endif %}
        <hr>

    {% else %} {# An image IS selected, show the editor #}
        
        <p><a href="{% url 'home' %}">Select a different image</a></p> 
        
        <h3>Selected Path: {{ selected_image.name }}</h3>

        <div id="message-container" style="text-align: center; font-size: 16px; color: blue; display: none;"></div>
        
        <div id="editor-layout">
            <div id="image-option-containter">
                <button id="add-point-on-image-btn">Add Point on Image</button>
                <br>
                <div id="image-container">
                    <svg id="connection-lines" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></svg>
                    <img src="{{ selected_image.image.url }}" id="main-image" alt="{{ selected_image.name }}" />
                    {% for click in selected_image.clicks.all %}
                    <div class="click-dot"
                        data-id="{{ click.id }}"
                        style="left: {{ click.x }}px; top: {{ click.y }}px;">
                        <span class="dot-number"></span>
                        <button class="delete-dot-btn" title="Delete this point">✖</button>
                    </div>
                    {% endfor %}
                </div>
                <br>
                <a href="{% url 'delete_image' selected_image.id %}" onclick="return confirm('Are you sure you want to delete this image and all its points?');">Delete image</a>
            </div>

            <div id="coordinates-list-container">
                <button id="add-point-on-list-btn">Add New Point to List</button>
                <h4>Coordinates of Points:</h4>
                <ul id="coordinates-list">
                    {% for click in selected_image.clicks.all %}
                        <li data-click-id="{{ click.id }}" class="coordinate-item">
                            Point <span class="point-display-number">{{ forloop.counter }}</span>:
                            X<input type="number" class="coord-x-input" value="{{ click.x|floatformat:2 }}" step="1.00" autocomplete="off">
                            Y<input type="number" class="coord-y-input" value="{{ click.y|floatformat:2 }}" step="1.00" autocomplete="off">
                            <button class="update-coord-btn">Update</button>
                            <button class="delete-coord-btn">Delete</button>
                        </li>
                    {% endfor %}
                </ul>
            </div>
        </div>
        <br>
    {% endif %} {# End of 'if selected_image' / 'if not selected_image' logic #}

{% endblock content %}

{% block extra_js %}
    <script>
        const csrfToken = '{{ csrf_token }}';
        const selectedImageId = {{ selected_image.id|default_if_none:"null" }};
        // console.log("[HTML Init Script] selectedImageId:", selectedImageId); // For debugging

        let draggedDot = null;
        let addModeOnClick = false;
    </script>
    <script src="{% static 'main/js/functions.js' %}"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // console.log("[HTML DOMContentLoaded] Event fired. selectedImageId:", selectedImageId); // For debugging

            function initializeEditorComponents() {
                // console.log("[HTML initializeEditorComponents] Called."); // For debugging
                // This function assumes elements like #main-image are present.
                if (typeof initializePageElements === 'function') {
                    initializePageElements();
                } else {
                    console.error("initializePageElements is not defined. Check functions.js");
                }
                if (typeof initializeCoordinateListInteractions === 'function') {
                    initializeCoordinateListInteractions();
                } else {
                    console.error("initializeCoordinateListInteractions is not defined. Check functions.js");
                }
            }

            if (selectedImageId) { // If an image is selected, its HTML (including #main-image) should be rendered
                const mainImageElement = document.getElementById('main-image');
                if (mainImageElement) {
                    // console.log("[HTML DOMContentLoaded] main-image found."); // For debugging
                    if (mainImageElement.complete) {
                        // console.log("[HTML DOMContentLoaded] main-image already complete. Initializing editor."); // For debugging
                        initializeEditorComponents();
                    } else {
                        // console.log("[HTML DOMContentLoaded] main-image not complete. Adding load listener."); // For debugging
                        mainImageElement.addEventListener('load', () => {
                            // console.log("[HTML DOMContentLoaded] main-image LOAD event. Initializing editor."); // For debugging
                            initializeEditorComponents();
                        });
                    }
                } else {
                    // This case should ideally not happen if selectedImageId is true,
                    // as it implies the editor block in HTML wasn't rendered.
                    console.warn("[HTML DOMContentLoaded] selectedImageId is set, but #main-image not found.");
                }
            } else { // No image selected, editor part is not rendered
                // console.log("[HTML DOMContentLoaded] No selectedImageId. Editor components not initialized."); // For debugging
                const addPointOnImageBtn = document.getElementById('add-point-on-image-btn');
                const addPointToListBtn = document.getElementById('add-point-on-list-btn');
                if(addPointOnImageBtn) addPointOnImageBtn.disabled = true;
                if(addPointToListBtn) addPointToListBtn.disabled = true;
            }
            
            // Event listeners that should be active regardless of initial image selection,
            // but their internal logic might depend on editor elements existing.
            
            const addPointOnImageBtn = document.getElementById('add-point-on-image-btn');
            const messageContainer = document.getElementById('message-container');
            if (addPointOnImageBtn) {
                addPointOnImageBtn.addEventListener('click', () => {
                    addModeOnClick = !addModeOnClick;
                    const mainImgElem = document.getElementById('main-image'); // Needs to exist
                    if (addModeOnClick) {
                        addPointOnImageBtn.textContent = "Stop Adding on Image";
                        if(messageContainer) {
                            messageContainer.innerText = "Click anywhere on the image to place a new point.";
                            messageContainer.style.display = "block";
                        }
                        if(mainImgElem) mainImgElem.style.cursor = 'crosshair';
                    } else {
                        addPointOnImageBtn.textContent = "Add Point on Image";
                        if(messageContainer) messageContainer.style.display = "none";
                        if(mainImgElem) mainImgElem.style.cursor = 'default';
                    }
                });
            }

            const mainImageEventTarget = document.getElementById('main-image'); // Get target for click
            if (mainImageEventTarget) {
                mainImageEventTarget.addEventListener('click', function (e) {
                    if (!addModeOnClick || !selectedImageId) return;
                    const rect = e.target.getBoundingClientRect();
                    const x = parseFloat((e.clientX - rect.left).toFixed(2));
                    const y = parseFloat((e.clientY - rect.top).toFixed(2));
                    fetch('/add-click/', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
                        body: JSON.stringify({ image_id: selectedImageId, x: x, y: y })
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            if (typeof createDotOnImage === 'function' && 
                                typeof createCoordinateListItem === 'function' &&
                                typeof renumberDotsAndListItems === 'function') {
                                createDotOnImage(data.click_id, x, y);
                                createCoordinateListItem(data.click_id, x, y, false);
                                renumberDotsAndListItems();
                            } else {
                                console.error("One or more functions (createDotOnImage, createCoordinateListItem, renumberDotsAndListItems) are not defined.");
                            }
                        } else {
                            console.error("Failed to add click via image click", data);
                        }
                    });
                });
            }
            
            document.addEventListener("mousemove", (e) => {
                if (!draggedDot) return;
                const mainImageForMove = document.getElementById('main-image');
                if (!mainImageForMove) return; 
                
                const imageRect = mainImageForMove.getBoundingClientRect();
                let newLeft = e.clientX - imageRect.left;
                let newTop = e.clientY - imageRect.top;

                const boundaryMaxLeft = mainImageForMove.width;
                const boundaryMinLeft = 0;
                const boundaryMaxTop = mainImageForMove.height;
                const boundaryMinTop = 0;
                
                // Keep entire dot within image boundaries
                newLeft = Math.max(boundaryMinLeft, Math.min(newLeft, boundaryMaxLeft));
                newTop = Math.max(boundaryMinTop, Math.min(newTop, boundaryMaxTop));   

                draggedDot.style.left = newLeft + "px";
                draggedDot.style.top = newTop + "px";

                if (typeof redrawLines === 'function') {
                    redrawLines();
                } else {
                    console.error("redrawLines is not defined.");
                }

                const clickId = draggedDot.dataset.id;
                const listItem = document.querySelector(`#coordinates-list .coordinate-item[data-click-id="${clickId}"]`);
                if (listItem) {
                    listItem.querySelector('.coord-x-input').value = parseFloat(newLeft).toFixed(2);
                    listItem.querySelector('.coord-y-input').value = parseFloat(newTop).toFixed(2);
                }
            });

        }); // End of DOMContentLoaded
    </script>
{% endblock extra_js %}

===== File: ./main/templates/main/register.html =====
{% extends "main/base.html" %}
{% load static %}

{% block title %}Register{% endblock title %}

{% block content %}
    <h2>Register</h2>
    <form method="post" action="{% url 'register' %}">
        {% csrf_token %}
        {{ form.as_p }}
        <button type="submit">Register</button>
    </form>
    <p>Already have an account? <a href="{% url 'login' %}">Login here</a></p>
{% endblock content %}

===== File: ./main/tests.py =====
import os
import uuid
from io import BytesIO
from PIL import Image as PILImage
from django.test import TestCase
from django.urls import reverse
from django.contrib.auth.models import User
from django.core.files.uploadedfile import SimpleUploadedFile
from django.conf import settings
from rest_framework.test import APIClient
from rest_framework import status
from rest_framework.authtoken.models import Token
from .models import UserImage, ImageClick

def create_test_image_file(name="test_image.png", ext="png", size=(50, 50), color="red"):
    file_obj = BytesIO()
    image = PILImage.new("RGB", size=size, color=color)
    image.save(file_obj, format=ext.upper())
    file_obj.seek(0)
    return SimpleUploadedFile(name, file_obj.read(), content_type=f"image/{ext}")

class BaseSetupTestCase(TestCase):
    @classmethod
    def setUpTestData(cls):
        cls.user1_data = {'username': 'user1', 'password': 'password123'}
        cls.user1 = User.objects.create_user(**cls.user1_data)
        cls.user2_data = {'username': 'user2', 'password': 'password456'}
        cls.user2 = User.objects.create_user(**cls.user2_data)
        cls.image_u1 = UserImage.objects.create(
            user=cls.user1,
            name="image_user1",
            image=create_test_image_file("img_u1.png")
        )
        cls.image_u2 = UserImage.objects.create(
            user=cls.user2,
            name="image_user2",
            image=create_test_image_file("img_u2.png")
        )
        cls.click_u1_img_u1 = ImageClick.objects.create(
            image=cls.image_u1,
            user=cls.user1,
            x=10.0,
            y=20.0
        )

    def setUp(self):
        self.client = APIClient()

    @classmethod
    def tearDownClass(cls):
        for img_obj in UserImage.objects.all():
            if img_obj.image and hasattr(img_obj.image, 'path'):
                if os.path.exists(img_obj.image.path):
                    try:
                        os.remove(img_obj.image.path)
                        img_dir = os.path.dirname(img_obj.image.path)
                        if not os.listdir(img_dir):
                            os.rmdir(img_dir)
                            month_dir = os.path.dirname(img_dir)
                            if not os.listdir(month_dir):
                                os.rmdir(month_dir)
                                year_dir = os.path.dirname(month_dir)
                                if not os.listdir(year_dir):
                                    os.rmdir(year_dir)
                    except OSError:
                        pass
        super().tearDownClass()

class ModelTests(BaseSetupTestCase):

    def test_userimage_creation(self):
        self.assertEqual(self.image_u1.user, self.user1)
        self.assertEqual(self.image_u1.name, "image_user1")
        self.assertTrue(self.image_u1.image.name.startswith('uploads/'))
        self.assertEqual(str(self.image_u1), "image_user1")

    def test_imageclick_creation(self):
        self.assertEqual(self.click_u1_img_u1.image, self.image_u1)
        self.assertEqual(self.click_u1_img_u1.user, self.user1)
        self.assertEqual(self.click_u1_img_u1.x, 10.0)
        self.assertEqual(str(self.click_u1_img_u1), f"Click on {self.image_u1.name} by {self.user1.username} at (10.0, 20.0)")

    def test_user_image_relation(self):
        self.assertIn(self.image_u1, self.user1.images.all())

    def test_image_click_relation(self):
        self.assertIn(self.click_u1_img_u1, self.image_u1.clicks.all())

class WebAuthTests(BaseSetupTestCase):

    def test_home_page_requires_login(self):
        response = self.client.get(reverse('home'))
        self.assertEqual(response.status_code, status.HTTP_302_FOUND)
        self.assertIn(reverse('login'), response.url)

    def test_user_login_and_logout(self):
        login_response = self.client.post(reverse('login'), self.user1_data)
        self.assertEqual(login_response.status_code, status.HTTP_302_FOUND)
        self.assertEqual(login_response.url, '/')
            
        home_response = self.client.get(reverse('home'))
        self.assertEqual(home_response.status_code, status.HTTP_200_OK)
        self.assertContains(home_response, self.user1.username)
        logout_response = self.client.get(reverse('logout'))
        self.assertEqual(logout_response.status_code, status.HTTP_302_FOUND)
        self.assertIn(reverse(settings.LOGOUT_REDIRECT_URL.strip('/')), logout_response.url)
        home_response_after_logout = self.client.get(reverse('home'))
        self.assertEqual(home_response_after_logout.status_code, status.HTTP_302_FOUND)

    def test_user_sees_only_own_images_on_home(self):
        self.client.login(username=self.user1_data['username'], password=self.user1_data['password'])
        response = self.client.get(reverse('home'))
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertContains(response, self.image_u1.name)
        self.assertNotContains(response, self.image_u2.name)

    def test_user_cannot_delete_others_image_via_web(self):
        self.client.login(username=self.user1_data['username'], password=self.user1_data['password'])
        delete_url = reverse('delete_image', args=[self.image_u2.id])
        response = self.client.post(delete_url)
        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)
        self.assertTrue(UserImage.objects.filter(id=self.image_u2.id).exists())

class WebCRUDTests(BaseSetupTestCase):

    def setUp(self):
        super().setUp()
        self.client.login(username=self.user1_data['username'], password=self.user1_data['password'])

    def test_upload_new_image(self):
        initial_image_count = UserImage.objects.filter(user=self.user1).count()
        base_file_name = "web_upload"
        image_file = create_test_image_file(f"{base_file_name}.jpg", ext="jpeg")
        data = {
            'name': 'My Web Uploaded Image',
            'image': image_file
        }
        response = self.client.post(reverse('upload_image'), data, format='multipart')
        self.assertEqual(response.status_code, status.HTTP_302_FOUND)
        self.assertEqual(response.url, reverse('home'))
        self.assertEqual(UserImage.objects.filter(user=self.user1).count(), initial_image_count + 1)
        new_image = UserImage.objects.get(user=self.user1, name='My Web Uploaded Image')
        self.assertIn(base_file_name, new_image.image.name)
        self.assertTrue(new_image.image.name.lower().endswith(".jpg"))
    

    def test_add_click_via_ajax(self):
        initial_click_count = ImageClick.objects.filter(image=self.image_u1, user=self.user1).count()
        click_data = {
            'image_id': self.image_u1.id,
            'x': 30.5,
            'y': 40.5
        }
        response = self.client.post(reverse('add_click'), click_data, format='json')
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        response_data = response.json()
        self.assertTrue(response_data['success'])
        self.assertIn('click_id', response_data)
        self.assertEqual(ImageClick.objects.filter(image=self.image_u1, user=self.user1).count(), initial_click_count + 1)
        new_click = ImageClick.objects.get(id=response_data['click_id'])
        self.assertEqual(new_click.x, 30.5)

    def test_delete_click_via_ajax(self):
        self.assertTrue(ImageClick.objects.filter(id=self.click_u1_img_u1.id).exists())
        click_id_to_delete = self.click_u1_img_u1.id
        
        delete_data = {'id': click_id_to_delete}
        response = self.client.post(reverse('delete_click'), delete_data, format='json')
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.json()['status'], 'deleted')
        self.assertFalse(ImageClick.objects.filter(id=click_id_to_delete).exists())

    def test_user_cannot_delete_others_click_via_ajax(self):
        click_u2 = ImageClick.objects.create(image=self.image_u2, user=self.user2, x=5, y=5)
        self.client.login(username=self.user1_data['username'], password=self.user1_data['password'])
        delete_data = {'id': click_u2.id}
        response = self.client.post(reverse('delete_click'), delete_data, format='json')
        
        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)
        self.assertTrue(ImageClick.objects.filter(id=click_u2.id).exists())

class APITests(BaseSetupTestCase):

    def setUp(self):
        super().setUp()
        self.user1_token = Token.objects.get(user=self.user1)
        self.user2_token = Token.objects.get(user=self.user2)
        self.client.credentials(HTTP_AUTHORIZATION=f'Token {self.user1_token.key}')

    def test_api_list_images_requires_authentication(self):
        self.client.credentials()
        response = self.client.get(reverse('userimage-list'))
        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)

    def test_api_list_images_returns_only_own_images(self):
        response = self.client.get(reverse('userimage-list'))
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data), UserImage.objects.filter(user=self.user1).count())
        self.assertEqual(response.data[0]['name'], self.image_u1.name)
        for item in response.data:
            self.assertNotEqual(item['name'], self.image_u2.name)

    def test_api_create_image(self):
        initial_count = UserImage.objects.filter(user=self.user1).count()
        image_file = create_test_image_file("api_upload.gif", ext="gif")
        unique_name = f"API Test Image {self.user1.username} {uuid.uuid4().hex}"
        data = {'name': unique_name, 'image': image_file}
        
        response = self.client.post(reverse('userimage-list'), data, format='multipart')
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertEqual(UserImage.objects.filter(user=self.user1).count(), initial_count + 1)
        self.assertEqual(response.data['name'], unique_name)
        self.assertEqual(response.data['user'], self.user1.id)

    def test_api_retrieve_own_image_detail(self):
        response = self.client.get(reverse('userimage-detail', args=[self.image_u1.id]))
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['name'], self.image_u1.name)

    def test_api_cannot_retrieve_others_image_detail(self):
        response = self.client.get(reverse('userimage-detail', args=[self.image_u2.id]))
        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)

    def test_api_delete_own_image(self):
        image_to_delete = UserImage.objects.create(user=self.user1, name="to_delete_api", image=create_test_image_file())
        response = self.client.delete(reverse('userimage-detail', args=[image_to_delete.id]))
        self.assertEqual(response.status_code, status.HTTP_204_NO_CONTENT)
        self.assertFalse(UserImage.objects.filter(id=image_to_delete.id).exists())

    def test_api_cannot_delete_others_image(self):
        response = self.client.delete(reverse('userimage-detail', args=[self.image_u2.id]))
        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)
        self.assertTrue(UserImage.objects.filter(id=self.image_u2.id).exists())

    def test_api_create_image_invalid_data(self):
        data = {'name': ''}
        response = self.client.post(reverse('userimage-list'), data, format='json')
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertIn('image', response.data)
        self.assertIn('name', response.data)

    def test_api_list_clicks_returns_only_own_clicks(self):
        ImageClick.objects.create(image=self.image_u2, user=self.user2, x=1, y=1)
        response = self.client.get(reverse('imageclick-list'))
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data), ImageClick.objects.filter(user=self.user1).count())
        self.assertEqual(response.data[0]['id'], self.click_u1_img_u1.id)

    def test_api_create_click_on_own_image(self):
        initial_count = ImageClick.objects.filter(user=self.user1).count()
        data = {
            'image': self.image_u1.id,
            'x': 55.0,
            'y': 65.0
        }
        response = self.client.post(reverse('imageclick-list'), data, format='json')
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertEqual(ImageClick.objects.filter(user=self.user1).count(), initial_count + 1)
        self.assertEqual(response.data['x'], 55.0)
        self.assertEqual(response.data['user'], self.user1.id)

    def test_api_delete_own_click(self):
        click_to_delete = ImageClick.objects.create(image=self.image_u1, user=self.user1, x=1, y=1)
        response = self.client.delete(reverse('imageclick-detail', args=[click_to_delete.id]))
        self.assertEqual(response.status_code, status.HTTP_204_NO_CONTENT)
        self.assertFalse(ImageClick.objects.filter(id=click_to_delete.id).exists())

    def test_api_cannot_delete_others_click(self):
        click_u2 = ImageClick.objects.create(image=self.image_u2, user=self.user2, x=1, y=1)
        response = self.client.delete(reverse('imageclick-detail', args=[click_u2.id]))
        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)
        self.assertTrue(ImageClick.objects.filter(id=click_u2.id).exists())

===== File: ./main/urls.py =====
# main/urls.py
from django.urls import path, include
# from django.conf import settings # Not needed here if MEDIA_URL is handled at project level
# from django.conf.urls.static import static # Not needed here
# from django.contrib.auth import views as auth_views # Auth views usually at project level
from rest_framework.routers import DefaultRouter
from . import views

router = DefaultRouter()
router.register(r'images', views.UserImageViewSet)
router.register(r'clicks', views.ImageClickViewSet)

# Keep app_name if you use it for these non-board URLs, or remove if not needed.
# app_name = 'main' # Example, if you namespace these

urlpatterns = [
    path('', views.home, name='home'),
    path('register/', views.register, name='register'),
    path('add-click/', views.add_click, name='add_click'),
    path('user-panel/', views.user_panel, name='user_panel'),
    path('delete-click/', views.delete_click, name='delete_click'),
    path('record-click/', views.record_click, name='record_click'),
    path('update-click/', views.update_click, name='update_click'),
    path('upload-image/', views.upload_image, name='upload_image'),
    path('change-password/', views.change_password, name='change_password'),
    path('delete/<int:image_id>/', views.delete_image, name='delete_image'),
    path('use-common-image/<int:common_image_id>/', views.use_common_image, name='use_common_image'),
    path('upload-common-image/', views.upload_common_image, name='upload_common_image'),
    path('stream/', views.sse_notifications_view, name='sse_stream'),
    path('', include(router.urls)), # For your DRF viewsets
    # REMOVE THE FOLLOWING BOARD URLS FROM HERE:
    # path('define-grid/', views.define_grid, name='define_grid'), # Ensure this view exists if uncommented
    # path('create/', views.board_editor_view, name='board_create'),
    # path('<int:board_id>/edit/', views.board_editor_view, name='board_edit'),
    # path('<int:board_id>/delete/', views.board_delete_view, name='board_delete'),
    # path('api/save_board/', views.save_board_api_view, name='save_board_api'),
    # path('api/board/<int:board_id>/', views.get_board_data_api_view, name='get_board_data_api'),
]

# urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT) # Usually handled at project level

===== File: ./main/urls_board.py =====
# main/urls_board.py
from django.urls import path
from . import views # Assuming your board views are in main/views.py

app_name = 'game_board' # You can keep this namespace if you like, or change it

urlpatterns = [
    path('', views.board_list_view, name='board_list'), # Assuming this view exists in main.views
    path('create/', views.board_editor_view, name='board_create'),
    path('events/', views.sse_notifications_view, name='sse_board_events'),
    path('<int:board_id>/edit/', views.board_editor_view, name='board_edit'),
    path('<int:board_id>/delete/', views.board_delete_view, name='board_delete'),
    # API endpoint
    path('api/save_board/', views.save_board_api_view, name='save_board_api'),
    path('api/board/<int:board_id>/', views.get_board_data_api_view, name='get_board_data_api'),
]

===== File: ./main/event_queue.py =====
# main/event_queue.py
import queue
import threading
import json
import uuid

_client_queues = {}  # Dictionary: {client_id: queue.Queue}
_client_queues_lock = threading.Lock()

def add_client_queue():
    client_id = str(uuid.uuid4())
    q = queue.Queue(maxsize=100)
    with _client_queues_lock:
        _client_queues[client_id] = q
    print(f"SSE [event_queue]: Client queue added (ID: {client_id}). Total queues: {len(_client_queues)}")
    return client_id, q

def remove_client_queue(client_id: str):
    with _client_queues_lock:
        if client_id in _client_queues:
            del _client_queues[client_id]
            print(f"SSE [event_queue]: Client queue removed (ID: {client_id}). Total queues: {len(_client_queues)}")
        else:
            print(f"SSE [event_queue]: Attempted to remove non-existent client queue (ID: {client_id}).")

def broadcast_event(event_type: str, data: dict):
    if not isinstance(event_type, str) or not isinstance(data, dict):
        print(f"SSE [event_queue] ERROR: Invalid event_type or data for broadcast. Type: {event_type}, Data: {data}")
        return

    sse_formatted_message = f"event: {event_type}\ndata: {json.dumps(data)}\n\n"
    print(f"SSE [event_queue]: Broadcasting event - Type: {event_type}, Data: {json.dumps(data)}")

    current_client_ids = []
    with _client_queues_lock:
        current_client_ids = list(_client_queues.keys())

    if not current_client_ids:
        print("SSE [event_queue]: No active client queues to broadcast to.")
        return

    print(f"SSE [event_queue]: Number of client queues to broadcast to: {len(current_client_ids)}")

    for client_id in current_client_ids:
        with _client_queues_lock:
            q = _client_queues.get(client_id)
        
        if q:
            try:
                print(f"SSE [event_queue]: Attempting to put message in queue for client_id: {client_id}")
                q.put_nowait(sse_formatted_message)
                print(f"SSE [event_queue]: Message put in queue for client_id: {client_id} successfully")
            except queue.Full:
                print(f"SSE [event_queue] WARNING: Client queue full for event '{event_type}' (Client ID: {client_id}). Message dropped for this client.")
            except Exception as e:
                print(f"SSE [event_queue] ERROR: Failed to put message in queue for client_id {client_id}: {e}")
        else:
            print(f"SSE [event_queue] WARNING: Queue for client_id {client_id} not found during broadcast (race condition?).")

===== File: ./main/serializers.py =====
from rest_framework import serializers
from .models import UserImage, ImageClick

class ImageClickSerializer(serializers.ModelSerializer):
    class Meta:
        model = ImageClick
        fields = ['id', 'user', 'x', 'y', 'image']

class UserImageSerializer(serializers.ModelSerializer):
    clicks = ImageClickSerializer(many=True, read_only=True)
    user = serializers.PrimaryKeyRelatedField(read_only=True)
    def get_queryset(self):
        # 🔐 Zwracaj tylko obrazy danego użytkownika
        return UserImage.objects.filter(user=self.request.user)

    def perform_create(self, serializer):
        # 🔐 Ustaw właściciela obrazu automatycznie
        serializer.save(user=self.request.user)
    class Meta:
        model = UserImage
        fields = ['id', 'user', 'name', 'image', 'clicks']


===== File: ./main/views.py =====
# main/views.py
from django.contrib.auth.decorators import login_required
from django.contrib.auth.forms import UserCreationForm, PasswordChangeForm
from django.contrib.auth import login, logout, update_session_auth_hash
from django.shortcuts import render, redirect, get_object_or_404
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from django.core.files.base import ContentFile
from django.db import transaction 
from django.conf import settings
from django.core.exceptions import ValidationError
from django.core.files.base import ContentFile
from django.contrib.contenttypes.models import ContentType
from django.views.decorators.http import require_POST
from django.http import StreamingHttpResponse
from rest_framework import viewsets, serializers
from rest_framework.permissions import IsAuthenticated
from PIL import Image as PILImage, ImageDraw, ImageFont # Dodaj ImageFont, jeśli chcesz numery
from .models import ImageClick, UserImage, CommonImage, Reaction, GameBoard, UserImage # Dodaj Reaction
from .serializers import UserImageSerializer, ImageClickSerializer
from .forms import UserImageForm, CommonImageUploadForm 
from .permissions import IsOwner
from .forms import DefineGridForm
from .event_queue import add_client_queue, remove_client_queue
import json
import io
import base64
import re
import time
import queue # For queue.Queue and queue.Empty

@login_required
@require_POST # Reakcje to tworzenie danych
def add_reaction_view(request):
    try:
        data = json.loads(request.body.decode('utf-8'))
        object_type_str = data.get('object_type') # np. 'gameboard' lub 'userimage'
        object_id = data.get('object_id')
        reaction_type_key = data.get('reaction_type') # np. 'heart', 'gasp', 'grin'
    except json.JSONDecodeError:
        return JsonResponse({'status': 'error', 'message': 'Invalid JSON.'}, status=400)

    if not all([object_type_str, object_id, reaction_type_key]):
        return JsonResponse({'status': 'error', 'message': 'Missing required data.'}, status=400)

    # Mapowanie stringu object_type na model Django
    if object_type_str == 'gameboard':
        model = GameBoard
    elif object_type_str == 'userimage':
        model = UserImage
    # Dodaj inne modele, jeśli chcesz na nich reagować
    else:
        return JsonResponse({'status': 'error', 'message': 'Invalid object type.'}, status=400)

    try:
        content_object_instance = model.objects.get(pk=object_id)
        content_type_instance = ContentType.objects.get_for_model(content_object_instance)
    except model.DoesNotExist:
        return JsonResponse({'status': 'error', 'message': 'Object not found.'}, status=404)
    except Exception as e:
        return JsonResponse({'status': 'error', 'message': f'Error fetching object: {str(e)}'}, status=500)

    # Sprawdzenie, czy reaction_type jest prawidłowy
    valid_reaction_types = [choice[0] for choice in Reaction.REACTION_CHOICES]
    if reaction_type_key not in valid_reaction_types:
        return JsonResponse({'status': 'error', 'message': 'Invalid reaction type.'}, status=400)

    # Logika "jedna reakcja na obiekt od użytkownika"
    # Jeśli chcesz pozwolić na zmianę reakcji, to:
    # 1. Spróbuj pobrać istniejącą reakcję.
    # 2. Jeśli istnieje i jest inna, zaktualizuj ją.
    # 3. Jeśli istnieje i jest taka sama, możesz ją usunąć (toggle) lub nic nie robić.
    # 4. Jeśli nie istnieje, utwórz nową.

    # Uproszczona logika: usuń poprzednią reakcję użytkownika na ten obiekt (jeśli istnieje) i dodaj nową.
    # To efektywnie pozwala zmienić reakcję.
    Reaction.objects.filter(
        user=request.user,
        content_type=content_type_instance,
        object_id=content_object_instance.pk
    ).delete()

    try:
        reaction = Reaction.objects.create(
            user=request.user,
            reaction_type=reaction_type_key,
            content_type=content_type_instance,
            object_id=content_object_instance.pk
        )
        
        # Po pomyślnym zapisaniu reakcji, wyślij zdarzenie SSE
        # Potrzebujemy informacji o obiekcie, na który zareagowano
        reacted_object_name = ""
        if isinstance(content_object_instance, GameBoard):
            reacted_object_name = content_object_instance.name
        elif isinstance(content_object_instance, UserImage):
            reacted_object_name = content_object_instance.name
        
        # Zdarzenie SSE o nowej reakcji
        # (logika broadcast_event jest w main/event_queue.py)
        from .event_queue import broadcast_event # Upewnij się, że ten import jest dostępny
        broadcast_event(
            event_type="newReaction",
            data={
                "reaction_id": reaction.id,
                "reaction_type": reaction.reaction_type, # klucz np. 'heart'
                "reaction_display": reaction.get_reaction_type_display(), # emotka np. '❤️'
                "user_username": request.user.username,
                "object_type": object_type_str,
                "object_id": content_object_instance.pk,
                "object_name": reacted_object_name
            }
        )

        return JsonResponse({
            'status': 'success',
            'message': 'Reaction added.',
            'reaction_id': reaction.id,
            'reaction_type': reaction.reaction_type
        })
    except Exception as e: # Np. błąd unikalności, jeśli nie usuwasz starej reakcji
        return JsonResponse({'status': 'error', 'message': f'Could not save reaction: {str(e)}'}, status=400)

# @login_required # Odkomentuj, jeśli chcesz autoryzacji
def sse_notifications_view(request):
    client_id, client_q = add_client_queue()
    print(f"SSE VIEW: Client connected (ID: {client_id}) from {request.META.get('REMOTE_ADDR')}")

    def event_stream_generator(client_id_for_generator, queue_for_generator):
        print(f"SSE VIEW [Generator]: Started for client ID: {client_id_for_generator}")
        try:
            yield ":sse-connection-established client_id={}\n\n".format(client_id_for_generator)
            last_keep_alive = time.time()

            while True:
                current_time = time.time()
                if current_time - last_keep_alive > 15:
                    yield ":keep-alive\n\n"
                    last_keep_alive = current_time

                try:
                    message = queue_for_generator.get(timeout=1) 
                    yield message
                    queue_for_generator.task_done()
                except queue.Empty:
                    continue
                except Exception as e_inner_q:
                    print(f"SSE VIEW [Generator] ERROR (queue get) for client ID {client_id_for_generator}: {e_inner_q}")
                    break 

        except GeneratorExit:
            print(f"SSE VIEW [Generator]: Client ID {client_id_for_generator} disconnected (GeneratorExit).")
        except Exception as e_outer_gen:
            print(f"SSE VIEW [Generator] ERROR (outer) for client ID {client_id_for_generator}: {e_outer_gen}")
        finally:
            print(f"SSE VIEW [Generator]: Cleaning up for client ID: {client_id_for_generator}.")
            remove_client_queue(client_id_for_generator)

    response = StreamingHttpResponse(event_stream_generator(client_id, client_q), content_type='text/event-stream')
    response['Cache-Control'] = 'no-cache, no-store, must-revalidate'
    response['Pragma'] = 'no-cache'
    response['Expires'] = '0'
    response['X-Accel-Buffering'] = 'no'
    return response

@login_required
@require_POST # Ensure this view only accepts POST requests
def save_grid_as_image_view(request):
    try:
        data = json.loads(request.body.decode('utf-8'))
    except json.JSONDecodeError:
        return JsonResponse({'status': 'error', 'message': 'Invalid JSON.'}, status=400)

    image_data_url = data.get('image_data_url')
    image_name = data.get('name', 'Generated Grid Image')
    filename = data.get('filename', 'grid_image.png')

    if not image_data_url:
        return JsonResponse({'status': 'error', 'message': 'Missing image data URL.'}, status=400)

    try:
        # Decode the base64 data URL
        # format: data:[<mime_type>][;base64],<data>
        header, encoded_data = image_data_url.split(',', 1)
        # mime_type = header.split(';')[0].split(':')[1] # e.g. image/png

        # Basic validation for filename (you might want more robust sanitization)
        safe_filename = re.sub(r'[^\w\.\-]', '_', filename)

        image_data_binary = base64.b64decode(encoded_data)
        image_content_file = ContentFile(image_data_binary, name=safe_filename)

        # Create a UserImage instance (or your equivalent model for path editing backgrounds)
        # Ensure unique name if your UserImage.name must be unique
        unique_image_name = image_name
        counter = 1
        while UserImage.objects.filter(user=request.user, name=unique_image_name).exists():
            unique_image_name = f"{image_name}_{counter}"
            counter += 1
        
        user_image = UserImage(user=request.user, name=unique_image_name)
        user_image.image.save(safe_filename, image_content_file, save=True) # save=True will commit to DB

        return JsonResponse({
            'status': 'success',
            'message': 'Grid image saved successfully.',
            'image_id': user_image.id,
            'image_name': user_image.name,
            'image_url': user_image.image.url
        })

    except (TypeError, ValueError) as e: # Catch base64 decoding errors
        return JsonResponse({'status': 'error', 'message': f'Invalid image data format: {str(e)}'}, status=400)
    except Exception as e:
        # Log the exception e
        return JsonResponse({'status': 'error', 'message': f'An unexpected error occurred: {str(e)}'}, status=500)

@login_required
def board_list_view(request):
    boards = GameBoard.objects.filter(user=request.user).order_by('-id')
    return render(request, 'game_board/board_list.html', {'boards': boards})

@login_required
def board_editor_view(request, board_id=None):
    board_instance = None
    initial_board_data_json = "null" # Default for new board

    if board_id:
        board_instance = get_object_or_404(GameBoard, pk=board_id, user=request.user)
        initial_board_data = {
            "id": board_instance.id,
            "name": board_instance.name,
            "rows": board_instance.rows,
            "cols": board_instance.cols,
            "dots_config": board_instance.dots_config
        }
        initial_board_data_json = json.dumps(initial_board_data)


    # This view primarily serves the HTML structure.
    # The actual board creation/editing logic happens via API calls from TypeScript.
    # However, you might pre-populate some form fields if editing.
    context = {
        'board_instance': board_instance,
        'initial_board_data_json': initial_board_data_json,
    }
    return render(request, 'game_board/board_editor.html', context)


@login_required
@require_POST # Ensures this view only accepts POST requests
def save_board_api_view(request):
    try:
        data = json.loads(request.body.decode('utf-8'))
    except json.JSONDecodeError:
        return JsonResponse({'status': 'error', 'message': 'Invalid JSON'}, status=400)

    board_id = data.get('id')
    name = data.get('name', 'Untitled Board')
    rows = data.get('rows')
    cols = data.get('cols')
    dots_config = data.get('dots_config', [])

    if not all([name, isinstance(rows, int), isinstance(cols, int), isinstance(dots_config, list)]):
        return JsonResponse({'status': 'error', 'message': 'Missing or invalid data fields.'}, status=400)

    try:
        if board_id:
            # Update existing board
            board = get_object_or_404(GameBoard, pk=board_id, user=request.user)
            board.name = name
            board.rows = rows
            board.cols = cols
            board.dots_config = dots_config
            board.save() # This will call full_clean()
            return JsonResponse({'status': 'success', 'message': 'Board updated successfully.', 'board_id': board.id})
        else:
            # Create new board
            board = GameBoard(user=request.user, name=name, rows=rows, cols=cols, dots_config=dots_config)
            board.save() # This will call full_clean()
            return JsonResponse({'status': 'success', 'message': 'Board created successfully.', 'board_id': board.id}, status=201)
    except ValidationError as e:
        return JsonResponse({'status': 'error', 'message': 'Validation Error', 'errors': e.message_dict}, status=400)
    except Exception as e:
        # Log the exception e
        return JsonResponse({'status': 'error', 'message': f'An unexpected error occurred: {str(e)}'}, status=500)


@login_required
def get_board_data_api_view(request, board_id):
    board = get_object_or_404(GameBoard, pk=board_id, user=request.user)
    data = {
        "id": board.id,
        "name": board.name,
        "rows": board.rows,
        "cols": board.cols,
        "dots_config": board.dots_config
    }
    return JsonResponse(data)


@login_required
@require_POST # Use POST for destructive actions
def board_delete_view(request, board_id):
    board = get_object_or_404(GameBoard, pk=board_id, user=request.user)
    board.delete()
    # If called via AJAX, return JSON. If via form, redirect.
    if request.headers.get('x-requested-with') == 'XMLHttpRequest':
        return JsonResponse({'status': 'success', 'message': 'Board deleted successfully.'})
    return redirect('game_board:board_list')

class UserImageViewSet(viewsets.ModelViewSet):
    queryset = UserImage.objects.all()  # Add this back
    serializer_class = UserImageSerializer
    permission_classes = [IsAuthenticated, IsOwner]

    def get_queryset(self):
        user = self.request.user
        if user.is_authenticated:
            return UserImage.objects.filter(user=user)
        return UserImage.objects.none() 
    
    def perform_create(self, serializer):
        serializer.save(user=self.request.user)

class ImageClickViewSet(viewsets.ModelViewSet):
    queryset = ImageClick.objects.all()  # Add this back
    serializer_class = ImageClickSerializer
    permission_classes = [IsAuthenticated, IsOwner]

    def get_queryset(self):
        user = self.request.user
        if user.is_authenticated:
            return ImageClick.objects.filter(user=user)
        return ImageClick.objects.none() # Or handle unauthenticated access

    def perform_create(self, serializer):
        image_instance = serializer.validated_data.get('image')
        if image_instance.user != self.request.user:
            raise serializers.ValidationError("You can only add clicks to your own images.")
        serializer.save(user=self.request.user, image=image_instance)

    def perform_update(self, serializer):
        if 'image' in serializer.validated_data:
            image_instance = serializer.validated_data.get('image')
            if image_instance.user != self.request.user:
                raise serializers.ValidationError("You can only associate clicks with your own images.")
        serializer.save()


@csrf_exempt
@login_required
def add_click(request):
    if request.method == "POST":
        data = json.loads(request.body)
        image_id = data['image_id']
        x = float(data['x'])
        y = float(data['y'])

        image = get_object_or_404(UserImage, id=image_id, user=request.user)
        click = ImageClick.objects.create(image=image, user=request.user, x=x, y=y)

        return JsonResponse({
            'success': True,
            'click_id': click.id
        })
    return JsonResponse({'success': False})

@csrf_exempt
@login_required
def delete_click(request):
    if request.method == 'POST':
        data = json.loads(request.body)
        try:
            click = ImageClick.objects.get(id=data['id'], user=request.user)
            click.delete()
            return JsonResponse({'status': 'deleted'})
        except ImageClick.DoesNotExist:
            return JsonResponse({'status': 'not found'}, status=404)

@csrf_exempt
@login_required
def update_click(request):
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            click = ImageClick.objects.get(id=data['id'], user=request.user) # Check ownership
            
            click.x = data['x']
            click.y = data['y']
            click.save()
            return JsonResponse({'status': 'success'})
        except ImageClick.DoesNotExist:
            return JsonResponse({'status': 'not found or forbidden'}, status=404)
        except Exception as e:
            return JsonResponse({'status': 'error', 'message': str(e)})
    return JsonResponse({'status': 'invalid request'}, status=400)

@login_required
def record_click(request):
    if request.method == "POST":
        image_id = request.POST.get('image_id')
        x = request.POST.get('x')
        y = request.POST.get('y')

        image = get_object_or_404(UserImage, id=image_id, user=request.user)
        click = ImageClick.objects.create(image=image, user=request.user, x=x, y=y) # Assign current user
        return JsonResponse({'status': 'ok'})

    return JsonResponse({'status': 'error'}, status=400)

@login_required
@transaction.atomic # Ensures that if any part fails, the whole operation is rolled back
def use_common_image(request, common_image_id):
    common_image = get_object_or_404(CommonImage, id=common_image_id)
    
    new_image_name_base = common_image.name
    new_image_name = new_image_name_base
    counter = 1
    while UserImage.objects.filter(user=request.user, name=new_image_name).exists():
        new_image_name = f"{new_image_name_base}_{counter}"
        counter += 1

    user_image = UserImage(
        user=request.user,
        name=new_image_name
    )

    try:
        with open(common_image.image.path, 'rb') as f:
            image_content = ContentFile(f.read(), name=common_image.image.name.split('/')[-1]) # Get original filename
            user_image.image.save(image_content.name, image_content, save=True) # Save the file to UserImage
        
        return redirect(f"{settings.LOGIN_REDIRECT_URL}?selected={user_image.name}")
    except IOError as e:
        print(f"Error copying common image file: {e}") # Log this properly
        return redirect('home') # Or wherever appropriate

@login_required
def home(request):
    user_images_list = UserImage.objects.filter(user=request.user) # Ensure this is the variable name
    common_images_list = CommonImage.objects.all()
    selected = request.GET.get('selected')
    selected_image = user_images_list.filter(name=selected).first() if selected else None
    return render(request, 'main/home.html', {
        'user_images': user_images_list,
        'common_images_list': common_images_list,   
        'selected_image': selected_image,
    })

def register(request):
    if request.method == 'POST':
        form = UserCreationForm(request.POST)
        if form.is_valid():
            user = form.save()
            login(request, user)
            return redirect('/')
    else:
        form = UserCreationForm()
    return render(request, 'main/register.html', {'form': form})

@login_required
def upload_image(request):
    if request.method == 'POST':
        form = UserImageForm(request.POST, request.FILES)
        if form.is_valid():
            user_image = form.save(commit=False)
            user_image.user = request.user
            user_image.save()
            return redirect('home')
    else:
        form = UserImageForm()
    return render(request, 'main/upload_image.html', {'form': form})

@login_required
def upload_common_image(request):
    if request.method == 'POST':
        form = CommonImageUploadForm(request.POST, request.FILES)
        if form.is_valid():
            common_image = form.save(commit=False)
            common_image.save()
            return redirect('home') # Or to a page showing common images
    else:
        form = CommonImageUploadForm()
    return render(request, 'main/upload_common_image.html', {'form': form})

@login_required
def user_panel(request):
    images = UserImage.objects.filter(user=request.user)
    if request.method == 'POST':
        image_id_to_update = request.POST.get('image_id_for_rename') # Assuming a distinct field name for clarity
        if image_id_to_update:
            image_instance = get_object_or_404(UserImage, id=image_id_to_update, user=request.user)
            form = UserImageForm(request.POST, request.FILES, instance=image_instance)
        else:
            form = UserImageForm(request.POST, request.FILES)
        
        if form.is_valid():
            image = form.save(commit=False)
            image.user = request.user
            image.save()
            return redirect('user_panel')
    else:
        form = UserImageForm() # Form for uploading a new image / or empty form for rename if not POST

    password_form = PasswordChangeForm(user=request.user)
    
    return render(request, 'main/user_panel.html', {
        'images': images,
        'upload_form': form, # Renamed for clarity in template if needed
        'password_form': password_form,
    })

@login_required
def change_password(request):
    if request.method == 'POST':
        password_form = PasswordChangeForm(user=request.user, data=request.POST)
        if password_form.is_valid():
            password_form.save()
            update_session_auth_hash(request, password_form.user)
            return redirect('user_panel')
    else:
        password_form = PasswordChangeForm(user=request.user)
    
    images = UserImage.objects.filter(user=request.user)
    upload_form = UserImageForm() # Or maintain state if it was a multi-purpose page
    return render(request, 'main/user_panel.html', {
        'images': images,
        'upload_form': upload_form,
        'password_form': password_form, # This will have errors
    })

@login_required
def delete_image(request, image_id):
    image = get_object_or_404(UserImage, id=image_id, user=request.user)
    image.image.delete()
    image.delete()
    return redirect('user_panel')

===== File: ./main/migrations/0001_initial.py =====
# Generated by Django 4.2.20 on 2025-06-08 16:07

from django.conf import settings
from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='CommonImage',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(help_text='Descriptive name for the common image.', max_length=100, unique=True)),
                ('image', models.ImageField(help_text='The actual image file.', upload_to='common_images/%Y/%m/%d/')),
                ('description', models.TextField(blank=True, help_text='Optional description.', null=True)),
            ],
            options={
                'verbose_name': 'Common Image',
                'ordering': ['name'],
            },
        ),
        migrations.CreateModel(
            name='UserImage',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=100, unique=True)),
                ('image', models.ImageField(upload_to='uploads/%Y/%m/%d/')),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='images', to=settings.AUTH_USER_MODEL)),
            ],
        ),
        migrations.CreateModel(
            name='ImageClick',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('x', models.FloatField()),
                ('y', models.FloatField()),
                ('image', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='clicks', to='main.userimage')),
                ('user', models.ForeignKey(default=1, on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),
            ],
        ),
        migrations.CreateModel(
            name='GameBoard',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(default='Untitled Board', max_length=100)),
                ('rows', models.PositiveIntegerField()),
                ('cols', models.PositiveIntegerField()),
                ('dots_config', models.JSONField(blank=True, default=list)),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='game_boards', to=settings.AUTH_USER_MODEL)),
            ],
        ),
    ]


===== File: ./main/migrations/__init__.py =====


===== File: ./main/__init__.py =====


===== File: ./main/apps.py =====
from django.apps import AppConfig

class MainConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'main'

    def ready(self):
        import main.models # Or 'import main.signals' if you put the signal handler there
        print("MainConfig.ready() called - Attempting to import signals...")
        try:
            import main.signals
            print("MainConfig.ready(): main.signals imported successfully.")
        except ImportError as e:
            print(f"MainConfig.ready() ERROR: Could not import main.signals - {e}")

# class GameBoardConfig(AppConfig):
#     default_auto_field = 'django.db.models.BigAutoField'
#     name = 'game_board'


===== File: ./manage.py =====
#!/usr/bin/env python
import os
import sys

if __name__ == "__main__":
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "login_required_project.settings")
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError("Couldn't import Django.") from exc
    execute_from_command_line(sys.argv)
