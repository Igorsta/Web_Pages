===== PROJECT STRUCTURE =====
.
â”œâ”€â”€ db.sqlite3
â”œâ”€â”€ login_required_project
â”‚Â Â  â”œâ”€â”€ __init__.py
â”‚Â Â  â”œâ”€â”€ settings.py
â”‚Â Â  â”œâ”€â”€ urls.py
â”‚Â Â  â””â”€â”€ wsgi.py
â”œâ”€â”€ main
â”‚Â Â  â”œâ”€â”€ __init__.py
â”‚Â Â  â”œâ”€â”€ admin.py
â”‚Â Â  â”œâ”€â”€ apps.py
â”‚Â Â  â”œâ”€â”€ event_queue.py
â”‚Â Â  â”œâ”€â”€ forms.py
â”‚Â Â  â”œâ”€â”€ models.py
â”‚Â Â  â”œâ”€â”€ permissions.py
â”‚Â Â  â”œâ”€â”€ serializers.py
â”‚Â Â  â”œâ”€â”€ signals.py
â”‚Â Â  â”œâ”€â”€ templates
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ game_board
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ base.html
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ board_editor.html
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ board_list.html
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ main
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ base.html
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ define_grid.html
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ home.html
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ login.html
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ register.html
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ upload_common_image.html
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ upload_image.html
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ user_panel.html
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ registration
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ login.html
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ register.html
â”‚Â Â  â”‚Â Â  â””â”€â”€ rest_framework
â”‚Â Â  â”‚Â Â      â””â”€â”€ api.html
â”‚Â Â  â”œâ”€â”€ tests.py
â”‚Â Â  â”œâ”€â”€ urls.py
â”‚Â Â  â”œâ”€â”€ urls_board.py
â”‚Â Â  â””â”€â”€ views.py
â”œâ”€â”€ manage.py
â”œâ”€â”€ package-lock.json
â”œâ”€â”€ package.json
â”œâ”€â”€ project_dump.txt
â”œâ”€â”€ script.sh
â””â”€â”€ tsconfig.json

7 directories, 38 files


===== File: ./login_required_project/urls.py =====
from django.contrib import admin
from django.urls import path, include
from django.contrib.auth import views as auth_views
from django.conf import settings
from django.conf.urls.static import static
from rest_framework.authtoken import views as authtoken_views 
from main import views as main_views

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('main.urls')),
    path('login/', auth_views.LoginView.as_view(template_name='main/login.html'), name='login'),
    path('logout/', auth_views.LogoutView.as_view(), name='logout'),
    path('api/', include('main.urls')),
    path('api-auth/', include('rest_framework.urls', namespace='rest_framework')),
    path('api-token-auth/', authtoken_views.obtain_auth_token, name='api_token_auth'),
    path('board/', include('main.urls_board')),
    path('api/save_grid_as_image/', main_views.save_grid_as_image_view, name='save_grid_as_image_api'), # NEW
    path('sse/notifications/', main_views.sse_notifications_view, name='sse_global_notifications'), # ADD THIS LINE
    path('api/add_reaction/', main_views.add_reaction_view, name='add_reaction_api'),
]

urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

===== File: ./login_required_project/settings.py =====
from pathlib import Path
import os

BASE_DIR = Path(__file__).resolve().parent.parent

SECRET_KEY = 'django-insecure-testkey'

DEBUG = True

ALLOWED_HOSTS = []

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'rest_framework',
    'rest_framework.authtoken',
    'main.apps.MainConfig',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'login_required_project.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [BASE_DIR / 'templates'],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [ 
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'login_required_project.wsgi.application'

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}

AUTH_PASSWORD_VALIDATORS = []

LANGUAGE_CODE = 'en-us'
TIME_ZONE = 'UTC'
USE_I18N = True
USE_TZ = True

STATIC_URL = 'static/'

STATICFILES_DIRS = [
    os.path.join(BASE_DIR, 'static'),
]

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

LOGIN_URL = '/login/'
LOGIN_REDIRECT_URL = '/'
LOGOUT_REDIRECT_URL = '/login/'

MEDIA_URL = '/media/'
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')

REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework.authentication.TokenAuthentication', 
        'rest_framework.authentication.SessionAuthentication', 
        
    ],
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated', 
    ],
}

===== File: ./login_required_project/__init__.py =====


===== File: ./login_required_project/wsgi.py =====
import os
from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'login_required_project.settings')
application = get_wsgi_application()


===== File: ./static/main/css/style.css =====
body {
    font-family: sans-serif;
    margin: 20px;
}
a {
    margin-right: 10px;
}
h2, h3 {
    color: #333;
}
form select, form button, #add-point-on-image-btn, #add-point-on-list-btn {
    padding: 8px;
    margin: 5px 0;
    border-radius: 4px;
    border: 1px solid #ccc;
}
#image-container {
    position: relative;
    display: inline-block;
    border: 1px solid #ddd;
    margin-top: 10px;
    margin-bottom: 10px;
}
.click-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background-color: red;
    position: absolute;
    cursor: move;
    /* Dla lepszego pozycjonowania wzglÄ™dem kursora */
    transform: translate(-50%, -50%); 
}
.dot-number {
    position: absolute;
    top: -15px; /* nieco wyÅ¼ej */
    left: 50%;
    transform: translateX(-50%);
    color: blue; /* zmieniony kolor dla odrÃ³Å¼nienia */
    font-weight: bold;
    font-size: 12px;
    text-shadow: 0 0 2px white; /* dla lepszej czytelnoÅ›ci na obrazie */
    pointer-events: none;
    user-select: none;
}
.delete-dot-btn {
    position: absolute;
    top: -8px; /* dostosuj pozycjÄ™ */
    right: -18px; /* dostosuj pozycjÄ™ */
    background: rgba(255, 255, 255, 0.7);
    border: 1px solid #aaa;
    color: red;
    font-size: 12px; /* mniejszy */
    width: 16px; /* mniejszy */
    height: 16px; /* mniejszy */
    line-height: 14px; /* wyÅ›rodkowanie X */
    text-align: center;
    border-radius: 50%;
    cursor: pointer;
    padding: 0;
}
#connection-lines line {
    stroke-dasharray: 3,3; /* Kreskowane linie */
    stroke-linecap: round;
}
#coordinates-list-container {
    padding: 10px;
    border: 1px solid #ccc;
    border-radius: 5px;
    background-color: #f9f9f9;
    max-width: 400px; /* Ograniczenie szerokoÅ›ci */
}
#coordinates-list {
    list-style-type: none;
    padding-left: 0;
}
#coordinates-list li {
    padding: 8px 0;
    border-bottom: 1px dashed #eee;
    display: flex; /* Dla lepszego uÅ‚oÅ¼enia elementÃ³w */
    align-items: center; /* WyÅ›rodkowanie w pionie */
}
#coordinates-list li:last-child {
    border-bottom: none;
}
.coordinate-item input[type="number"] {
    margin: 0 5px;
    padding: 4px;
    border: 1px solid #ccc;
    border-radius: 3px;
    width: 70px; /* nieco szersze */
}
.coordinate-item button {
    margin-left: 8px;
    padding: 4px 8px;
    font-size: 12px;
    border-radius: 3px;
    cursor: pointer;
}
.update-coord-btn {
    background-color: #e0e0e0;
    border: 1px solid #aaa;
}
.delete-coord-btn {
    background-color: #fdd;
    border: 1px solid #d99;
    color: #900;
}
#message-container {
    padding: 10px;
    margin-bottom: 10px;
    border-radius: 4px;
    background-color: #e7f3fe;
    border: 1px solid #d0e3f0;
}
#editor-layout {
    display: flex; /* Enables flexbox layout */
    align-items: flex-start; /* Aligns items to the top of the container */
    gap: 20px; /* Optional: adds space between the image and the list */
    margin-top: 10px; /* Optional: space above the layout */
    margin-bottom: 10px; /* Optional: space below the layout */
}
.click-dot.highlighted,
.click-dot:hover { /* Dodatkowe podÅ›wietlenie dla samej kropki */
    background-color: yellow; /* Lub inny kolor wyrÃ³Å¼nienia */
    box-shadow: 0 0 5px 2px orange; /* Opcjonalny cieÅ„ */
    z-index: 10; /* Aby byÅ‚a nad innymi elementami, jeÅ›li siÄ™ nakÅ‚adajÄ… */
}

#coordinates-list .coordinate-item.highlighted,
#coordinates-list .coordinate-item:hover { /* Dodatkowe podÅ›wietlenie dla samego elementu listy */
    background-color: #e6f7ff; /* Jasnoniebieskie tÅ‚o */
    font-weight: bold; /* Pogrubienie tekstu */
}

#image-container {
    position: relative;
    display: inline-block; /* Or 'block' if you want it to take full available width before shrinking */
    border: 1px solid #ddd;
    margin-top: 10px;
    margin-bottom: 10px;
    /* REMOVE fixed width and height from here */
    /* width: 400px; */
    /* height: 400px; */
    /* Add this to make the container shrink-to-fit the image */
    line-height: 0; /* Fixes potential extra space below inline-block images */
}

#main-image {
    display: block; /* Or inline-block */
    max-width: 400px;   /* Image will not exceed 400px width */
    max-height: 400px;  /* Image will not exceed 400px height */      /* Allow height to adjust based on width and aspect ratio */
    width: auto;
    height: auto;
    /* These (width: auto; height: auto;) are often default for <img> but good to be explicit */
}

#image-container #connection-lines { /* Be more specific if #connection-lines is used elsewhere */
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
}

#toast-container {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 9999; /* Aby byÅ‚y na wierzchu */
    width: 300px; /* MoÅ¼esz dostosowaÄ‡ */
}

.toast-notification {
    background-color: #333;
    color: white;
    padding: 15px;
    margin-bottom: 10px;
    border-radius: 5px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    opacity: 0;
    transform: translateX(100%);
    transition: opacity 0.5s ease, transform 0.5s ease;
    font-size: 0.9em;
}

.toast-notification.show {
    opacity: 1;
    transform: translateX(0);
}

.toast-notification .toast-close-btn {
    float: right;
    background: none;
    border: none;
    color: #aaa;
    font-size: 1.2em;
    line-height: 1;
    cursor: pointer;
    margin-left: 10px;
}
.toast-notification .toast-close-btn:hover {
    color: white;
}

===== File: ./static/main/js/functions.js =====
function initializePageElements() {
    redrawLines();
    document.querySelectorAll('.click-dot').forEach(initializeDot);
    renumberDotsAndListItems();
}

function renumberDotsAndListItems() {
    const dots = document.querySelectorAll('.click-dot');
    dots.forEach((dot, index) => {
        const dotNumberElement = dot.querySelector('.dot-number');
        if (dotNumberElement) dotNumberElement.innerText = index + 1;
    });

    const listItems = document.querySelectorAll('#coordinates-list .coordinate-item');
    listItems.forEach((item, index) => {
        const pointDisplayNumber = item.querySelector('.point-display-number');
        if (pointDisplayNumber) pointDisplayNumber.innerText = index + 1;
    });
    redrawLines();
}

function redrawLines() {
    const svg = document.getElementById('connection-lines');
    if (!svg) return;
    svg.innerHTML = '';

    const dots = Array.from(document.querySelectorAll('.click-dot'));
    if (dots.length < 2) return;

    for(let i = 0; i < dots.length - 1; i++) {
        const dot1 = dots[i];
        const dot2 = dots[i + 1];
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        const x1 = parseFloat(dot1.style.left); // Kropka jest juÅ¼ wyÅ›rodkowana przez transform
        const y1 = parseFloat(dot1.style.top);
        const x2 = parseFloat(dot2.style.left);
        const y2 = parseFloat(dot2.style.top);

        line.setAttribute('x1', x1);
        line.setAttribute('y1', y1);
        line.setAttribute('x2', x2);
        line.setAttribute('y2', y2);
        line.setAttribute('stroke-width', '2');
        line.setAttribute('stroke', '#ff0000');
        svg.appendChild(line);
    }
}

function createCoordinateListItem(clickId, x, y, isNew = false) {
    const listItem = document.createElement('li');
    listItem.classList.add('coordinate-item');
    if (!isNew && clickId) {
        listItem.setAttribute('data-click-id', clickId);
    }

    const pointNumberSpan = document.createElement('span');
    pointNumberSpan.classList.add('point-display-number');

    const inputX = document.createElement('input');
    inputX.type = 'number';
    inputX.classList.add('coord-x-input');
    inputX.value = parseFloat(x).toFixed(2);
    inputX.step = '0.01';

    const inputY = document.createElement('input');
    inputY.type = 'number';
    inputY.classList.add('coord-y-input');
    inputY.value = parseFloat(y).toFixed(2);
    inputY.step = '0.01';

    const updateButton = document.createElement('button');
    updateButton.classList.add('update-coord-btn');
    updateButton.textContent = isNew ? 'Save New' : 'Update';
    if (isNew) {
        updateButton.classList.add('save-new-coord-btn');
    }

    const deleteButton = document.createElement('button');
    deleteButton.classList.add('delete-coord-btn');
    deleteButton.textContent = 'Delete';

    listItem.appendChild(document.createTextNode('Point'));
    listItem.appendChild(pointNumberSpan);
    listItem.appendChild(document.createTextNode(': X'));
    listItem.appendChild(inputX);
    listItem.appendChild(document.createTextNode('Y'));
    listItem.appendChild(inputY);
    listItem.appendChild(updateButton);
    listItem.appendChild(deleteButton);

    document.getElementById('coordinates-list').appendChild(listItem);
    attachEventListenersToListItem(listItem, isNew); // Przekazuj tylko isNew
    return listItem;
}

function attachEventListenersToListItem(listItem, isNewInitially = false) {
    const updateBtn = listItem.querySelector('.update-coord-btn');
    const deleteBtn = listItem.querySelector('.delete-coord-btn');
    const inputX = listItem.querySelector('.coord-x-input');
    const inputY = listItem.querySelector('.coord-y-input');
    let isStillNew = isNewInitially; // Flaga do Å›ledzenia, czy element jest nowy

    console.log(`[attachEventListenersToListItem] For item data-id=${listItem.dataset.clickId}, X_val=${inputX.value}, Y_val=${inputY.value}`);

    updateBtn.addEventListener('click', function() {
        const currentClickId = listItem.dataset.clickId;
        const newX = parseFloat(inputX.value);
        const newY = parseFloat(inputY.value);

        if (isNaN(newX) || isNaN(newY)) {
            alert('Please enter valid numbers for X and Y.');
            return;
        }

        if (isStillNew || !currentClickId) { // Zapis nowego punktu
            fetch('/add-click/', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
                body: JSON.stringify({ image_id: selectedImageId, x: newX, y: newY })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    listItem.setAttribute('data-click-id', data.click_id);
                    updateBtn.textContent = 'Update';
                    updateBtn.classList.remove('save-new-coord-btn');
                    isStillNew = false; // JuÅ¼ nie jest nowy
                    createDotOnImage(data.click_id, newX, newY);
                    renumberDotsAndListItems();
                } else { alert('Failed to save new point.'); }
            });
        } else { // Aktualizacja istniejÄ…cego punktu
            fetch('/update-click/', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
                body: JSON.stringify({ id: currentClickId, x: newX, y: newY })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    const dot = document.querySelector(`.click-dot[data-id="${currentClickId}"]`);
                    if (dot) {
                        dot.style.left = newX + 'px';
                        dot.style.top = newY + 'px';
                        redrawLines();
                    }
                } else { alert('Failed to update point.'); }
            });
        }

    });

    listItem.addEventListener('mouseenter', () => {
        const clickId = listItem.dataset.clickId;
        if (!clickId) return; // Nie podÅ›wietlaj, jeÅ›li to nowy, niezapisany element

        listItem.classList.add('highlighted'); // PodÅ›wietl sam element listy
        const dotElement = document.querySelector(`.click-dot[data-id="${clickId}"]`);
        if (dotElement) {
            dotElement.classList.add('highlighted');
        }
    });

    listItem.addEventListener('mouseleave', () => {
        const clickId = listItem.dataset.clickId;
        if (!clickId) return;

        listItem.classList.remove('highlighted'); // UsuÅ„ podÅ›wietlenie z elementu listy
        const dotElement = document.querySelector(`.click-dot[data-id="${clickId}"]`);
        if (dotElement) {
            dotElement.classList.remove('highlighted');
        }
    });

    deleteBtn.addEventListener('click', function() {
        const currentClickId = listItem.dataset.clickId;
        if (isStillNew || !currentClickId) {
            listItem.remove();
            renumberDotsAndListItems();
            return;
        }

        fetch('/delete-click/', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
            body: JSON.stringify({ id: currentClickId })
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'deleted') {
                listItem.remove();
                const dot = document.querySelector(`.click-dot[data-id="${currentClickId}"]`);
                if (dot) dot.remove();
                renumberDotsAndListItems();
            } else { alert('Failed to delete point.'); }
        });
    });

    [inputX, inputY].forEach(input => {
        input.addEventListener('input', function() { // ZMIANA: 'input' zamiast 'change'
            const currentClickId = listItem.dataset.clickId;
            if (currentClickId && !isStillNew) { // UÅ¼yj flagi isStillNew
                const dot = document.querySelector(`.click-dot[data-id="${currentClickId}"]`);
                if (dot) {
                    let newXFromInput = parseFloat(inputX.value); // Use inputX from outer scope
                    let newYFromInput = parseFloat(inputY.value);
                    const mainImageForMove = document.getElementById('main-image');
                    if (!mainImageForMove) return; 
                    
                    const imageRect = mainImageForMove.getBoundingClientRect();

                    const boundaryMaxLeft = mainImageForMove.width;
                    const boundaryMinLeft = 0;
                    const boundaryMaxTop = mainImageForMove.height;
                    const boundaryMinTop = 0;
                    
                    // Keep entire dot within image boundaries
                    newXFromInput = Math.max(boundaryMinLeft, Math.min(newXFromInput, boundaryMaxLeft));
                    newYFromInput = Math.max(boundaryMinTop, Math.min(newYFromInput, boundaryMaxTop));   

                    newXFromInput = Math.max(0, newXFromInput);
                    newYFromInput = Math.max(0, newYFromInput)

                    if (!isNaN(newXFromInput) && !isNaN(newYFromInput)) {
                        dot.style.left = newXFromInput + 'px';
                        dot.style.top = newYFromInput + 'px';
                        inputX.value = newXFromInput;
                        inputY.value = newYFromInput;
                        redrawLines(); // PrzesuÅ„ linie Å‚Ä…czÄ…ce punkty
                    }
                }
            }
        });
    });
}

function initializeCoordinateListInteractions() {
    document.querySelectorAll('#coordinates-list .coordinate-item').forEach(item => {
        const clickId = item.dataset.clickId;
        if (clickId) {
                attachEventListenersToListItem(item, false);
        }
    });

    const addPointToListBtn = document.getElementById('add-point-on-list-btn');
    if (addPointToListBtn) {
        addPointToListBtn.addEventListener('click', () => {
            const mainImage = document.getElementById('main-image');
            const defaultX = mainImage ? mainImage.width / 2 : 50;
            const defaultY = mainImage ? mainImage.height / 2 : 50;
            createCoordinateListItem(null, defaultX, defaultY, true);
            renumberDotsAndListItems();
        });
    }
}

function initializeDot(dot) {
    const image = document.getElementById("main-image");
    if (!image) return;

    let offsetX = 0, offsetY = 0;

    dot.addEventListener("mousedown", (e) => {
        if (e.button !== 0) return;
        draggedDot = dot; // Ustaw aktualnie przeciÄ…ganÄ… kropkÄ™
        const rect = dot.getBoundingClientRect();
        offsetX = e.clientX - rect.left;
        offsetY = e.clientY - rect.top;
        
        e.preventDefault();
        document.addEventListener('mouseup', handleDocumentMouseUp, { once: true });
    });

    dot.querySelector('.delete-dot-btn').addEventListener('click', function (e) {
        const clickId = dot.dataset.id;
        if (confirm('Are you sure you want to delete this point?')) {
            fetch('/delete-click/', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
                body: JSON.stringify({ id: clickId })
            }).then(response => response.json()).then(data => {
                if (data.status === 'deleted') {
                    dot.remove();
                    const listItem = document.querySelector(`#coordinates-list .coordinate-item[data-click-id="${clickId}"]`);
                    if (listItem) listItem.remove();
                    renumberDotsAndListItems();
                }
            });
        }
    });

    dot.addEventListener('mouseenter', () => {
        const clickId = dot.dataset.id;
        if (!clickId) return;

        dot.classList.add('highlighted'); // PodÅ›wietl samÄ… kropkÄ™
        const listItem = document.querySelector(`#coordinates-list .coordinate-item[data-click-id="${clickId}"]`);
        if (listItem) {
            listItem.classList.add('highlighted');
        }
    });

    dot.addEventListener('mouseleave', () => {
        const clickId = dot.dataset.id;
        if (!clickId) return;

        dot.classList.remove('highlighted'); // UsuÅ„ podÅ›wietlenie z kropki
        const listItem = document.querySelector(`#coordinates-list .coordinate-item[data-click-id="${clickId}"]`);
        if (listItem) {
            listItem.classList.remove('highlighted');
        }
    });
}

function handleDocumentMouseUp() {
    if (!draggedDot) return;

    const finalX = parseFloat(draggedDot.style.left);
    const finalY = parseFloat(draggedDot.style.top);

    fetch('/update-click/', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
        body: JSON.stringify({ id: draggedDot.dataset.id, x: finalX, y: finalY })
    }).then(response => {
        if (!response.ok) console.error('Position save failed after drag for dot ID:', draggedDot.dataset.id);
    });
    draggedDot = null; // ZakoÅ„cz przeciÄ…ganie
}

function createDotOnImage(clickId, x, y) {
    const container = document.getElementById('image-container');
    const dot = document.createElement('div');
    dot.className = 'click-dot';
    dot.style.left = `${x}px`;
    dot.style.top = `${y}px`;
    dot.setAttribute('data-id', clickId);
    dot.innerHTML = `<span class="dot-number"></span>
                    <button class="delete-dot-btn" title="Delete this point">âœ–</button>`;
    container.appendChild(dot);
    initializeDot(dot);
    return dot;
}


===== File: ./static/main/ts/src/sseNotifications.ts =====
// static/main/ts/src/sseNotifications.ts

// --- Interfejsy dla danych przychodzÄ…cych z SSE ---
interface BoardEventData {
    board_id: number;
    board_name: string;
    creator_username: string;
}

interface PathEventData {
    path_id: number | null;
    board_id: number; // W tym kontekÅ›cie to UserImage.id lub GameBoard.id
    board_name: string;
    user_username: string;
    action?: "created" | "updated" | "point_added"; // Typy akcji dla Å›cieÅ¼ek/obrazÃ³w
}

interface ReactionEventData {
    reaction_id: number;
    reaction_type: string; // np. 'heart', 'gasp', 'grin'
    reaction_display: string; // np. 'â¤ï¸', 'ðŸ˜®', 'ðŸ˜„'
    user_username: string;
    object_type: string; // 'gameboard' lub 'userimage'
    object_id: number;
    object_name: string;
}

class SSENotifications {
    private eventSource: EventSource | null = null;
    private toastContainer: HTMLElement | null = null;
    private sseEndpointUrl: string;

    constructor(endpointUrl: string = '/board/events/') { // UÅ»YJ URL swojego endpointu SSE
        this.sseEndpointUrl = endpointUrl;
        this.toastContainer = document.getElementById('toast-container');

        if (this.toastContainer) {
            console.log("Toast container found. Proceeding with SSE connection.");
            this.connect();
        } else {
            console.warn("Toast container with ID 'toast-container' not found. SSE Notifications will not be visually displayed as toasts.");
            // Mimo to moÅ¼na prÃ³bowaÄ‡ siÄ™ poÅ‚Ä…czyÄ‡, jeÅ›li powiadomienia majÄ… inne efekty
            // lub jeÅ›li kontener jest dodawany dynamicznie pÃ³Åºniej (choÄ‡ to mniej typowe).
            // this.connect(); // Odkomentuj, jeÅ›li nadal chcesz siÄ™ Å‚Ä…czyÄ‡ bez wizualnych toastÃ³w
        }
    }

    private connect(): void {
        if (this.eventSource && (this.eventSource.readyState === EventSource.OPEN || this.eventSource.readyState === EventSource.CONNECTING)) {
            console.log("SSE connection already open or connecting.");
            return;
        }

        console.log(`Attempting to connect to SSE endpoint: ${this.sseEndpointUrl}`);
        try {
            this.eventSource = new EventSource(this.sseEndpointUrl);
        } catch (e) {
            console.error("Error creating EventSource (e.g., invalid URL or security policy):", e);
            this.showToast("Could not establish notification service. Check URL or network.", "error", 10000);
            return;
        }


        this.eventSource.onopen = (event) => {
            console.log("SSE Connection opened.", event);
            // MoÅ¼esz tu wyÅ›wietliÄ‡ powiadomienie o poÅ‚Ä…czeniu, jeÅ›li chcesz
            // this.showToast("Connected to real-time notifications.", "info");
        };

        this.eventSource.onerror = (errorEvent) => {
            console.error("SSE Error Event:", errorEvent);
            // EventSource automatycznie prÃ³buje ponownie nawiÄ…zaÄ‡ poÅ‚Ä…czenie.
            // MoÅ¼emy wyÅ›wietliÄ‡ informacjÄ™ o problemie.
            if (this.eventSource) {
                if (this.eventSource.readyState === EventSource.CLOSED) {
                    this.showToast("Notification service disconnected. Attempting to reconnect...", "error", 10000);
                    // MoÅ¼na by sprÃ³bowaÄ‡ this.connect() po jakimÅ› czasie, ale EventSource robi to samo.
                } else if (this.eventSource.readyState === EventSource.CONNECTING) {
                    this.showToast("Notification service having trouble connecting...", "error", 10000);
                }
            }
        };

        this.eventSource.addEventListener('newBoard', (event) => {
            console.log("SSE 'newBoard' event received:", event);
            try {
                const data = JSON.parse((event as MessageEvent).data) as BoardEventData;
                const message = `User '${data.creator_username}' created a new board: "${data.board_name}".`;
                const link = `/board/${data.board_id}/edit/`; // Dostosuj URL, jeÅ›li jest inny
                this.showToast(message, "success", 7000, link);
            } catch (e) {
                console.error("Error parsing newBoard data:", e, (event as MessageEvent).data);
            }
        });

        this.eventSource.addEventListener('newPath', (event) => {
            console.log("SSE 'newPath' event received:", event);
            try {
                const data = JSON.parse((event as MessageEvent).data) as PathEventData;
                let messageBase = `User '${data.user_username}' `;
                let objectName = data.board_name || "a board/image"; // Fallback

                if (data.action === "created") {
                    messageBase += `uploaded a new path background: "${objectName}".`;
                } else if (data.action === "updated") {
                    messageBase += `updated paths on: "${objectName}".`;
                } else if (data.action === "point_added") {
                    messageBase += `added a point to a path on: "${objectName}".`;
                } else { // DomyÅ›lny komunikat, jeÅ›li brak 'action' lub jest nieznane
                    messageBase += `interacted with: "${objectName}".`;
                }
                
                // Link do UserImage (ktÃ³ry dziaÅ‚a jako plansza dla Å›cieÅ¼ek)
                // ZakÅ‚adamy, Å¼e board_id w tym zdarzeniu to UserImage.id
                const link = `/?selected=${encodeURIComponent(objectName)}`;
                this.showToast(messageBase, "info", 7000, link);
            } catch (e) {
                console.error("Error parsing newPath data:", e, (event as MessageEvent).data);
            }
        });

        this.eventSource.addEventListener('newReaction', (event) => {
            console.log("SSE 'newReaction' event received:", event);
            try {
                const data = JSON.parse((event as MessageEvent).data) as ReactionEventData;
                const message = `User '${data.user_username}' reacted with ${data.reaction_display} to "${data.object_name}".`;
                
                this.showToast(message, "info", 5000); // Toasty dla reakcji mogÄ… byÄ‡ krÃ³tsze i bez linku

                // Aktualizacja UI dla reakcji
                this.updateReactionsDisplay(
                    data.object_type,
                    data.object_id,
                    data.reaction_type,
                    data.user_username,
                    data.reaction_display
                );
            } catch (e) {
                console.error("Error parsing newReaction data:", e, (event as MessageEvent).data);
            }
        });

        this.eventSource.onmessage = (event) => {
            // To bÄ™dzie przechwytywaÄ‡ wiadomoÅ›ci bez okreÅ›lonego "event: name"
            // oraz komentarze, jeÅ›li serwer je wysyÅ‚a bez poprzedzajÄ…cego dwukropka (co nie powinno mieÄ‡ miejsca dla keep-alive)
            if (event.data.startsWith(":")) { // Ignoruj komentarze keep-alive, jeÅ›li tu dotrÄ…
                console.log("SSE keep-alive or comment received in onmessage:", event.data);
                return;
            }
            console.log("SSE Generic message received:", event.data);
            // MoÅ¼esz chcieÄ‡ wyÅ›wietliÄ‡ to jako ogÃ³lne powiadomienie, jeÅ›li serwer moÅ¼e wysyÅ‚aÄ‡ takie komunikaty
            // this.showToast(`Notification: ${event.data}`, "info");
        };
    }

    public showToast(
        message: string, 
        type: 'info' | 'success' | 'error' = 'info', 
        duration: number = 5000, 
        link?: string
    ): void {
        if (!this.toastContainer) {
            console.warn("Toast container not found, cannot show toast for:", message);
            return;
        }

        const toast = document.createElement('div');
        toast.className = `toast-notification ${type}`; // np. "toast-notification success"
        
        let toastContentHTML = '';
        // Sanitize message before putting into innerHTML if it comes directly from user input elsewhere.
        // For now, assuming messages are safe or constructed server-side/client-side from known parts.
        const escapedMessage = message.replace(/&/g, "&").replace(/</g, "<").replace(/>/g, ">").replace(/"/g, """).replace(/'/g, "'");

        if (link) {
            // Ensure link is also somewhat safe or from a trusted source
            const safeLink = link.startsWith('/') ? link : '#'; // Basic check for relative links
            toastContentHTML = `<a href="${safeLink}" style="color: white; text-decoration: underline;">${escapedMessage}</a>`;
        } else {
            toastContentHTML = escapedMessage;
        }
        
        const messageSpan = document.createElement('span');
        messageSpan.innerHTML = toastContentHTML; // Use innerHTML because link might be present
        toast.appendChild(messageSpan);

        const closeBtn = document.createElement('button');
        closeBtn.className = 'toast-close-btn';
        closeBtn.type = 'button'; // Good practice for buttons not submitting forms
        closeBtn.innerHTML = 'Ã—'; // 'Ã—' character
        closeBtn.setAttribute('aria-label', 'Close notification');
        
        let toastRemoved = false; // Flaga, aby uniknÄ…Ä‡ wielokrotnego usuwania

        const removeToast = () => {
            if (toastRemoved) return;
            toastRemoved = true;
            toast.classList.remove('show');
            // Poczekaj na zakoÅ„czenie animacji CSS przed usuniÄ™ciem elementu z DOM
            toast.addEventListener('transitionend', () => {
                if (toast.parentNode === this.toastContainer) {
                    this.toastContainer?.removeChild(toast);
                }
            }, { once: true }); // Listener zostanie automatycznie usuniÄ™ty po pierwszym wywoÅ‚aniu
            // Fallback, gdyby transitionend siÄ™ nie odpaliÅ‚o (np. brak animacji)
            setTimeout(() => {
                 if (toast.parentNode === this.toastContainer) {
                    this.toastContainer?.removeChild(toast);
                }
            }, 550); // nieco dÅ‚uÅ¼ej niÅ¼ czas trwania animacji
        };

        closeBtn.onclick = removeToast;
        toast.appendChild(closeBtn);

        this.toastContainer.appendChild(toast);

        // WymuÅ› reflow, aby animacja CSS zadziaÅ‚aÅ‚a przy dodaniu klasy 'show'
        void toast.offsetWidth; 
        toast.classList.add('show');

        // Automatyczne usuniÄ™cie toasta po okreÅ›lonym czasie
        setTimeout(removeToast, duration);
    }

    // Szkielet metody do aktualizacji UI z reakcjami
    public updateReactionsDisplay(
        objectType: string, 
        objectId: number, 
        reactionTypeKey: string, // np. 'heart'
        reactingUsername: string,
        reactionDisplayIcon: string // np. 'â¤ï¸'
    ): void {
        console.log(`UI Update Triggered: User '${reactingUsername}' reacted with ${reactionDisplayIcon} on ${objectType} ID ${objectId}`);
        
        const reactionContainer = document.querySelector(
            `.reactions-container[data-object-type="${objectType}"][data-object-id="${objectId}"]`
        );

        if (!reactionContainer) {
            // console.warn(`UI Update: Reaction container not found for ${objectType} ${objectId}`);
            return;
        }

        // ZnajdÅº lub utwÃ³rz element dla konkretnego typu reakcji
        let reactionTypeDiv = reactionContainer.querySelector(`.reaction-type-display[data-reaction-type="${reactionTypeKey}"]`) as HTMLElement;
        
        if (!reactionTypeDiv) {
            reactionTypeDiv = document.createElement('span');
            reactionTypeDiv.className = 'reaction-type-display';
            reactionTypeDiv.dataset.reactionType = reactionTypeKey;
            
            const emojiSpan = document.createElement('span');
            emojiSpan.className = 'reaction-emoji';
            emojiSpan.textContent = reactionDisplayIcon;
            
            const countSpan = document.createElement('span');
            countSpan.className = 'reaction-count';
            countSpan.textContent = '0'; // Inicjalizuj z 0, backend powinien byÄ‡ ÅºrÃ³dÅ‚em prawdy o liczbie

            reactionTypeDiv.appendChild(emojiSpan);
            reactionTypeDiv.appendChild(document.createTextNode(' ')); // Spacja
            reactionTypeDiv.appendChild(countSpan);
            
            // TODO: Dodaj logikÄ™ do przechowywania listy uÅ¼ytkownikÃ³w, np. w data-users tooltip
            reactionTypeDiv.dataset.users = reactingUsername;

            reactionContainer.appendChild(reactionTypeDiv);
            // Dodaj trochÄ™ marginesu miÄ™dzy typami reakcji
            reactionTypeDiv.style.marginRight = "10px";

        } else {
            // UÅ¼ytkownik juÅ¼ zareagowaÅ‚, lub inny uÅ¼ytkownik dodaÅ‚ ten sam typ reakcji
            // TODO: Zaktualizuj listÄ™ uÅ¼ytkownikÃ³w w data-users
            const users = reactionTypeDiv.dataset.users ? reactionTypeDiv.dataset.users.split(',') : [];
            if (!users.includes(reactingUsername)) { // Dodaj tylko jeÅ›li jeszcze nie ma
                users.push(reactingUsername);
                reactionTypeDiv.dataset.users = users.join(',');
            }
        }
        
        // Aktualizuj licznik - UWAGA: Ta logika jest uproszczona.
        // Idealnie, serwer powinien zwracaÄ‡ caÅ‚kowitÄ… liczbÄ™ reakcji danego typu,
        // a frontend tylko jÄ… wyÅ›wietlaÄ‡, zamiast inkrementowaÄ‡.
        // PoniÅ¼sza logika zakÅ‚ada, Å¼e kaÅ¼de zdarzenie 'newReaction' to nowa unikalna reakcja.
        const countSpan = reactionTypeDiv.querySelector('.reaction-count') as HTMLSpanElement;
        if (countSpan) {
            let currentCount = parseInt(countSpan.textContent || "0", 10);
            // To jest problematyczne: jeÅ›li wielu uÅ¼ytkownikÃ³w reaguje, ten licznik bÄ™dzie rÃ³sÅ‚
            // dla kaÅ¼dego klienta niezaleÅ¼nie przy kaÅ¼dym zdarzeniu.
            // Lepiej, Å¼eby SSE wysyÅ‚aÅ‚o aktualnÄ… Å‚Ä…cznÄ… liczbÄ™ reakcji.
            // Na razie, dla prostoty, zaÅ‚Ã³Å¼my, Å¼e zdarzenie oznacza +1.
            // W rzeczywistoÅ›ci, to SSE powinno wysÅ‚aÄ‡ {"total_hearts": 5, "total_gasps": 2} itd.
            // Albo, `updateReactionsDisplay` powinno byÄ‡ bardziej idempotentne.
            countSpan.textContent = (currentCount + 1).toString(); // UPROSZCZENIE - wymaga poprawy
        }

        // Ustawienie tooltipa z listÄ… uÅ¼ytkownikÃ³w
        const usersWhoReacted = reactionTypeDiv.dataset.users || "";
        reactionTypeDiv.title = usersWhoReacted ? `Reacted by: ${usersWhoReacted}` : "";

    }

    public closeConnection(): void {
        if (this.eventSource) {
            this.eventSource.close();
            console.log("SSE Connection closed by client.");
        }
    }
}

// Inicjalizacja po zaÅ‚adowaniu DOM
document.addEventListener('DOMContentLoaded', () => {
    // SprawdÅº, czy element #toast-container istnieje, zanim zainicjujesz SSENotifications
    if (document.getElementById('toast-container')) {
        console.log("Initializing SSE Notifications client...");
        // Upewnij siÄ™, Å¼e URL jest poprawny dla Twojego projektu (np. z Django {% url ... %})
        // PoniÅ¼ej jest przykÅ‚ad, jak moÅ¼na by go przekazaÄ‡ z szablonu Django, jeÅ›li jest dynamiczny
        // const sseUrlElement = document.getElementById('sse-url-data');
        // const sseUrl = sseUrlElement ? sseUrlElement.dataset.url : '/board/events/';
        
        const sseClient = new SSENotifications('/board/events/'); // ZASTÄ„P URL, JEÅšLI POTRZEBA

        // Opcjonalnie: udostÄ™pnij sseClient globalnie, jeÅ›li potrzebujesz go wywoÅ‚ywaÄ‡ z innych miejsc
        // (np. window.sseClient = sseClient; - uÅ¼ywaj ostroÅ¼nie)
    } else {
        console.log("No #toast-container found, SSE notifications will not have a visual display area via this script.");
    }
});

===== File: ./static/main/ts/src/functions.ts =====
// functions.ts

// Deklaracje typÃ³w dla zmiennych globalnych (zakÅ‚adamy, Å¼e sÄ… zdefiniowane gdzie indziej)
declare const csrfToken: string;
declare const selectedImageId: number | null;
declare let draggedDot: HTMLElement | null;

// --- Interfejsy dla danych z serwera (opcjonalne, ale dobre dla typowania) ---
interface ClickData {
    id: number;
    x?: number;
    y?: number;
    col_index?: number;
    row_index?: number;
   
}

interface AddClickResponse {
    success: boolean;
    click_id?: number;
    is_grid_click?: boolean;
    error?: string;
}

interface UpdateClickResponse {
    status: 'success' | 'error' | 'not found or forbidden';
    message?: string;
}

interface DeleteClickResponse {
    status: 'deleted' | 'not found' | 'error';
}


// --- Funkcje ---

function initializePageElements(): void {
    redrawLines();
    document.querySelectorAll<HTMLElement>('.click-dot').forEach(initializeDot);
    renumberDotsAndListItems();
}

function renumberDotsAndListItems(): void {
    const dots = document.querySelectorAll<HTMLElement>('.click-dot');
    dots.forEach((dot, index) => {
        const dotNumberElement = dot.querySelector<HTMLSpanElement>('.dot-number');
        if (dotNumberElement) {
            dotNumberElement.innerText = (index + 1).toString();
        }
    });

    const listItems = document.querySelectorAll<HTMLLIElement>('#coordinates-list .coordinate-item');
    listItems.forEach((item, index) => {
        const pointDisplayNumber = item.querySelector<HTMLSpanElement>('.point-display-number');
        if (pointDisplayNumber) {
            pointDisplayNumber.innerText = (index + 1).toString();
        }
    });
    redrawLines();
}

function redrawLines(): void {
    const svg = document.getElementById('connection-lines') as SVGElement | null;
    if (!svg) return;
    svg.innerHTML = '';

    const dots = Array.from(document.querySelectorAll<HTMLElement>('.click-dot'));
    if (dots.length < 2) return;

    for (let i = 0; i < dots.length - 1; i++) {
        const dot1 = dots[i];
        const dot2 = dots[i + 1];
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');

       
        const x1 = parseFloat(dot1.style.left || '0');
        const y1 = parseFloat(dot1.style.top || '0');
        const x2 = parseFloat(dot2.style.left || '0');
        const y2 = parseFloat(dot2.style.top || '0');

        line.setAttribute('x1', x1.toString());
        line.setAttribute('y1', y1.toString());
        line.setAttribute('x2', x2.toString());
        line.setAttribute('y2', y2.toString());
        line.setAttribute('stroke-width', '2');
        line.setAttribute('stroke', '#ff0000');
        svg.appendChild(line);
    }
}

function createCoordinateListItem(clickId: number | null, x: number, y: number, isNew: boolean = false): HTMLLIElement {
    const listItem = document.createElement('li');
    listItem.classList.add('coordinate-item');
    if (!isNew && clickId !== null) {
        listItem.setAttribute('data-click-id', clickId.toString());
    }

    const pointNumberSpan = document.createElement('span');
    pointNumberSpan.classList.add('point-display-number');

    const inputX = document.createElement('input');
    inputX.type = 'number';
    inputX.classList.add('coord-x-input');
    inputX.value = x.toFixed(2);
    inputX.step = '0.01';
    inputX.autocomplete = 'off';


    const inputY = document.createElement('input');
    inputY.type = 'number';
    inputY.classList.add('coord-y-input');
    inputY.value = y.toFixed(2);
    inputY.step = '0.01';
    inputY.autocomplete = 'off';

    const updateButton = document.createElement('button');
    updateButton.classList.add('update-coord-btn');
    updateButton.textContent = isNew ? 'Save New' : 'Update';
    if (isNew) {
        updateButton.classList.add('save-new-coord-btn');
    }

    const deleteButton = document.createElement('button');
    deleteButton.classList.add('delete-coord-btn');
    deleteButton.textContent = 'Delete';

    listItem.appendChild(document.createTextNode('Point '));
    listItem.appendChild(pointNumberSpan);
    listItem.appendChild(document.createTextNode(': X '));
    listItem.appendChild(inputX);
    listItem.appendChild(document.createTextNode(' Y '));
    listItem.appendChild(inputY);
    listItem.appendChild(updateButton);
    listItem.appendChild(deleteButton);

    const coordinatesList = document.getElementById('coordinates-list');
    if (coordinatesList) {
        coordinatesList.appendChild(listItem);
    } else {
        console.error("Element with ID 'coordinates-list' not found.");
    }
    
    attachEventListenersToListItem(listItem, isNew);
    return listItem;
}

function attachEventListenersToListItem(listItem: HTMLLIElement, isNewInitially: boolean = false): void {
    const updateBtn = listItem.querySelector<HTMLButtonElement>('.update-coord-btn');
    const deleteBtn = listItem.querySelector<HTMLButtonElement>('.delete-coord-btn');
    const inputX = listItem.querySelector<HTMLInputElement>('.coord-x-input');
    const inputY = listItem.querySelector<HTMLInputElement>('.coord-y-input');
    let isStillNew = isNewInitially;

    if (!updateBtn || !deleteBtn || !inputX || !inputY) {
        console.error("Could not find all required elements within list item:", listItem);
        return;
    }

    console.log(`[attachEventListenersToListItem] For item data-id=${listItem.dataset.clickId}, X_val=${inputX.value}, Y_val=${inputY.value}`);

    updateBtn.addEventListener('click', function() {
        const currentClickIdStr = listItem.dataset.clickId;
        const currentClickId = currentClickIdStr ? parseInt(currentClickIdStr, 10) : null;
        const newX = parseFloat(inputX.value);
        const newY = parseFloat(inputY.value);

        if (isNaN(newX) || isNaN(newY)) {
            alert('Please enter valid numbers for X and Y.');
            return;
        }

        const requestBody = {
            item_id: selectedImageId,
            item_type: 'user_image', 
            x: newX,
            y: newY,
            id: currentClickId
        };
        
        if (isStillNew || currentClickId === null) {
            fetch('/add-click/', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
                body: JSON.stringify({ image_id: requestBody.item_id, x: newX, y: newY })
            })
            .then(response => response.json() as Promise<AddClickResponse>)
            .then(data => {
                if (data.success && data.click_id !== undefined) {
                    listItem.setAttribute('data-click-id', data.click_id.toString());
                    updateBtn.textContent = 'Update';
                    if (updateBtn.classList.contains('save-new-coord-btn')) {
                        updateBtn.classList.remove('save-new-coord-btn');
                    }
                    isStillNew = false;
                    createDotOnImage(data.click_id, newX, newY);
                    renumberDotsAndListItems();
                } else { 
                    alert('Failed to save new point. ' + (data.error || '')); 
                }
            }).catch(error => console.error('Error saving new point:', error));
        } else {
            fetch('/update-click/', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
                body: JSON.stringify({ id: currentClickId, x: newX, y: newY })
            })
            .then(response => response.json() as Promise<UpdateClickResponse>)
            .then(data => {
                if (data.status === 'success') {
                    const dot = document.querySelector<HTMLElement>(`.click-dot[data-id="${currentClickId}"]`);
                    if (dot) {
                        dot.style.left = newX + 'px';
                        dot.style.top = newY + 'px';
                        redrawLines();
                    }
                } else { 
                    alert('Failed to update point. ' + (data.message || ''));
                }
            }).catch(error => console.error('Error updating point:', error));
        }
    });

    listItem.addEventListener('mouseenter', () => {
        const clickId = listItem.dataset.clickId;
        if (!clickId) return;

        listItem.classList.add('highlighted');
        const dotElement = document.querySelector<HTMLElement>(`.click-dot[data-id="${clickId}"]`);
        if (dotElement) {
            dotElement.classList.add('highlighted');
        }
    });

    listItem.addEventListener('mouseleave', () => {
        const clickId = listItem.dataset.clickId;
        if (!clickId) return;

        listItem.classList.remove('highlighted');
        const dotElement = document.querySelector<HTMLElement>(`.click-dot[data-id="${clickId}"]`);
        if (dotElement) {
            dotElement.classList.remove('highlighted');
        }
    });

    deleteBtn.addEventListener('click', function() {
        const currentClickIdStr = listItem.dataset.clickId;
        
        if (isStillNew || !currentClickIdStr) {
            listItem.remove();
           
           
           
            renumberDotsAndListItems();
            return;
        }
        const currentClickId = parseInt(currentClickIdStr, 10);

        fetch('/delete-click/', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
            body: JSON.stringify({ id: currentClickId })
        })
        .then(response => response.json() as Promise<DeleteClickResponse>)
        .then(data => {
            if (data.status === 'deleted') {
                listItem.remove();
                const dot = document.querySelector<HTMLElement>(`.click-dot[data-id="${currentClickId}"]`);
                if (dot) dot.remove();
                renumberDotsAndListItems();
            } else { 
                alert('Failed to delete point.'); 
            }
        }).catch(error => console.error('Error deleting point:', error));
    });

    [inputX, inputY].forEach(inputField => {
        inputField.addEventListener('input', function() {
            const currentClickIdStr = listItem.dataset.clickId;
            if (currentClickIdStr && !isStillNew) {
                const currentClickId = parseInt(currentClickIdStr, 10);
                const dot = document.querySelector<HTMLElement>(`.click-dot[data-id="${currentClickId}"]`);
                
                if (dot) {
                    let newXFromInput = parseFloat(inputX.value);
                    let newYFromInput = parseFloat(inputY.value);

                    if (!isNaN(newXFromInput) && !isNaN(newYFromInput)) {
                        // --- BEGIN MODIFICATION: Clamp coordinates for live input update ---
                        const mainImageElement = document.getElementById('main-image') as HTMLImageElement | null;
                        let clampedX = newXFromInput;
                        let clampedY = newYFromInput;

                        if (mainImageElement) {
                            const dotWidth = 10; // As per CSS .click-dot width
                            const dotHeight = 10; // As per CSS .click-dot height

                            // Clamp X
                            if (mainImageElement.width < dotWidth) {
                                clampedX = mainImageElement.width / 2;
                            } else {
                                const minXAllowed = dotWidth / 2;
                                const maxXAllowed = mainImageElement.width - (dotWidth / 2);
                                clampedX = Math.max(minXAllowed, Math.min(newXFromInput, maxXAllowed));
                            }

                            // Clamp Y
                            if (mainImageElement.height < dotHeight) {
                                clampedY = mainImageElement.height / 2;
                            } else {
                                const minYAllowed = dotHeight / 2;
                                const maxYAllowed = mainImageElement.height - (dotHeight / 2);
                                clampedY = Math.max(minYAllowed, Math.min(newYFromInput, maxYAllowed));
                            }
                            
                            // Update input field if value was clamped, to give feedback
                            if (clampedX.toFixed(2) !== newXFromInput.toFixed(2) && inputField === inputX) {
                                inputX.value = clampedX.toFixed(2);
                            }
                            if (clampedY.toFixed(2) !== newYFromInput.toFixed(2) && inputField === inputY) {
                                inputY.value = clampedY.toFixed(2);
                            }
                        } else {
                             console.warn("Main image element not found, cannot apply boundary constraints for live input.");
                        }
                        // --- END MODIFICATION ---

                        dot.style.left = clampedX + 'px';
                        dot.style.top = clampedY + 'px';
                        redrawLines();
                    }
                }
            }
        });
    });
}

function initializeCoordinateListInteractions(): void {
    document.querySelectorAll<HTMLLIElement>('#coordinates-list .coordinate-item').forEach(item => {
        const clickId = item.dataset.clickId;
        if (clickId) {
            attachEventListenersToListItem(item, false);
        }
    });

    const addPointToListBtn = document.getElementById('add-point-on-list-btn');
    if (addPointToListBtn) {
        addPointToListBtn.addEventListener('click', () => {
            const mainImage = document.getElementById('main-image') as HTMLImageElement | null;
           
            const defaultX = mainImage ? mainImage.width / 2 : 50;
            const defaultY = mainImage ? mainImage.height / 2 : 50;
            
            createCoordinateListItem(null, defaultX, defaultY, true);
            renumberDotsAndListItems();
        });
    }
}


function initializeDot(dot: HTMLElement): void {
    const image = document.getElementById("main-image") as HTMLImageElement | null;
   
   

    dot.addEventListener("mousedown", (e: MouseEvent) => {
        if (e.button !== 0) return;
       
       

        draggedDot = dot;
       
        e.preventDefault();
        document.addEventListener('mouseup', handleDocumentMouseUp, { once: true });
    });

    const deleteBtn = dot.querySelector<HTMLButtonElement>('.delete-dot-btn');
    if (deleteBtn) {
        deleteBtn.addEventListener('click', function (e: MouseEvent) {
            e.stopPropagation();
            const clickIdStr = dot.dataset.id;
            if (!clickIdStr) {
                console.warn("Dot has no data-id for deletion:", dot);
               
               
                return;
            }
            const clickId = parseInt(clickIdStr, 10);

           
            fetch('/delete-click/', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
                body: JSON.stringify({ id: clickId })
            })
            .then(response => response.json() as Promise<DeleteClickResponse>)
            .then(data => {
                if (data.status === 'deleted') {
                    dot.remove();
                    const listItem = document.querySelector<HTMLLIElement>(`#coordinates-list .coordinate-item[data-click-id="${clickId}"]`);
                    if (listItem) listItem.remove();
                    renumberDotsAndListItems();
                } else {
                    alert('Failed to delete point.');
                }
            }).catch(error => console.error('Error deleting point:', error));
        });
    }

    dot.addEventListener('mouseenter', () => {
        const clickId = dot.dataset.id;
        if (!clickId) return;
        dot.classList.add('highlighted');
        const listItem = document.querySelector<HTMLLIElement>(`#coordinates-list .coordinate-item[data-click-id="${clickId}"]`);
        if (listItem) {
            listItem.classList.add('highlighted');
        }
    });

    dot.addEventListener('mouseleave', () => {
        const clickId = dot.dataset.id;
        if (!clickId) return;
        dot.classList.remove('highlighted');
        const listItem = document.querySelector<HTMLLIElement>(`#coordinates-list .coordinate-item[data-click-id="${clickId}"]`);
        if (listItem) {
            listItem.classList.remove('highlighted');
        }
    });
}


function handleDocumentMouseUp(): void {
    if (!draggedDot) return;

    const finalX = parseFloat(draggedDot.style.left || '0');
    const finalY = parseFloat(draggedDot.style.top || '0');
    const clickIdStr = draggedDot.dataset.id;

    if (!clickIdStr) {
        console.error("Dragged dot has no data-id for update:", draggedDot);
        draggedDot = null;
        return;
    }
    const clickId = parseInt(clickIdStr, 10);

    fetch('/update-click/', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
        body: JSON.stringify({ id: clickId, x: finalX, y: finalY })
    })
    .then(response => {
        if (!response.ok) {
            console.error('Position save failed after drag for dot ID:', clickId, response.statusText);
           
        }
        return response.json() as Promise<UpdateClickResponse>;
    })
    .then(data => {
        if (data.status !== 'success') {
            console.warn('Update click response status not success:', data);
        }
    })
    .catch(error => console.error('Error updating position after drag:', error));
    
    draggedDot = null;
}

function createDotOnImage(clickId: number, x: number, y: number): HTMLElement {
    const container = document.getElementById('image-container');
    if (!container) {
        console.error("Element with ID 'image-container' not found.");
       
        throw new Error("Image container not found, cannot create dot.");
    }
    const dot = document.createElement('div');
    dot.className = 'click-dot';
    dot.style.left = `${x}px`;
    dot.style.top = `${y}px`;
    dot.setAttribute('data-id', clickId.toString());
    dot.innerHTML = `<span class="dot-number"></span>
                    <button class="delete-dot-btn" title="Delete this point">âœ–</button>`;
    container.appendChild(dot);
    initializeDot(dot);
    return dot;
}

===== File: ./static/main/ts/src/grid.ts =====
interface Dot {
    row: number;
    col: number;
    color: string;
}

interface BoardState {
    id: number | null;
    name: string;
    rows: number;
    cols: number;
    dots: Dot[];
}

class BoardEditor {
    private gridContainer: HTMLElement;
    private numRowsInput: HTMLInputElement;
    private numColsInput: HTMLInputElement;
    private boardNameInput: HTMLInputElement;
    private generateGridButton: HTMLButtonElement;
    private saveBoardButton: HTMLButtonElement;
    private saveAsImageButton: HTMLButtonElement;
    private colorPaletteContainer: HTMLElement;
    private selectedColorDisplay: HTMLElement;
    private messagesDiv: HTMLElement;
    private csrfToken: string;
    private boardIdInput: HTMLInputElement;
    private cellSizePx: number = 0;

    private boardState: BoardState = {
        id: null,
        name: "My New Board",
        rows: 5,
        cols: 5,
        dots: []
    };

    private availableColors: string[] = [
        "#FF0000", "#00FF00", "#0000FF", "#FFFF00", "#FF00FF", "#00FFFF",
        "#FFA500", "#800080", "#A52A2A", "#008000"
    ];
    private selectedColor: string | null = null;
    private firstDotOfPair: { row: number, col: number } | null = null;
    private readonly MAX_GRID_DIMENSION_PX = 400;
    private readonly MIN_CELL_SIZE_PX = 10;


    constructor() {
        this.gridContainer = document.getElementById('grid-container')!;
        this.numRowsInput = document.getElementById('numRows') as HTMLInputElement;
        this.numColsInput = document.getElementById('numCols') as HTMLInputElement;
        this.boardNameInput = document.getElementById('boardName') as HTMLInputElement;
        this.generateGridButton = document.getElementById('generateGridButton') as HTMLButtonElement;
        this.saveBoardButton = document.getElementById('saveBoardButton') as HTMLButtonElement;
        this.colorPaletteContainer = document.getElementById('color-palette')!;
        this.selectedColorDisplay = document.getElementById('selected-color-display')!;
        this.messagesDiv = document.getElementById('messages')!;
        this.boardIdInput = document.getElementById('boardId') as HTMLInputElement;
        this.saveAsImageButton = document.getElementById('saveAsImageButton') as HTMLButtonElement;

        const csrfTokenElement = document.querySelector('[name=csrfmiddlewaretoken]') as HTMLInputElement;
        this.csrfToken = csrfTokenElement ? csrfTokenElement.value : '';

        this.loadInitialBoardData();
        this.initEventListeners();
        this.populateColorPalette();
        if (!this.boardState.id) {
            this.updateBoardStateFromInputs();
        }
        this.renderGrid();
    }

    private loadInitialBoardData(): void {
        const initialDataScript = document.getElementById('initial-board-data');
        if (initialDataScript && initialDataScript.textContent) {
            try {
                const data = JSON.parse(initialDataScript.textContent);
                if (data && data.id) {
                    this.boardState.id = data.id;
                    this.boardState.name = data.name;
                    this.boardState.rows = data.rows;
                    this.boardState.cols = data.cols;
                    this.boardState.dots = data.dots_config || [];

                    this.boardNameInput.value = this.boardState.name;
                    this.numRowsInput.value = this.boardState.rows.toString();
                    this.numColsInput.value = this.boardState.cols.toString();
                }
            } catch (e) {
                console.error("Error parsing initial board data:", e);
            }
        }
    }

    private initEventListeners(): void {
        this.saveAsImageButton.addEventListener('click', () => this.handleSaveAsImage());
        
        this.generateGridButton.addEventListener('click', () => {
            const oldRows = this.boardState.rows;
            const oldCols = this.boardState.cols;
            const newRows = parseInt(this.numRowsInput.value, 10);
            const newCols = parseInt(this.numColsInput.value, 10);

            if (this.boardState.rows !== newRows || this.boardState.cols !== newCols) {
                 this.boardState.dots = this.boardState.dots.filter(dot =>
                    dot.row < newRows && dot.col < newCols
                );
                this.firstDotOfPair = null;
            }
            this.boardState.rows = newRows;
            this.boardState.cols = newCols;
            this.renderGrid();
        });

        this.saveBoardButton.addEventListener('click', () => this.saveBoard());

        this.boardNameInput.addEventListener('input', () => {
            this.boardState.name = this.boardNameInput.value;
             const titleDisplay = document.getElementById('board-title-display');
             if(titleDisplay) titleDisplay.textContent = this.boardState.name;
        });
    }

    private updateBoardStateFromInputs(): void {
        this.boardState.name = this.boardNameInput.value;
        this.boardState.rows = parseInt(this.numRowsInput.value, 10) || 5;
        this.boardState.cols = parseInt(this.numColsInput.value, 10) || 5;
    }

    private populateColorPalette(): void {
        this.availableColors.forEach(color => {
            const colorButton = document.createElement('div');
            colorButton.classList.add('color-button');
            colorButton.style.backgroundColor = color;
            colorButton.dataset.color = color;
            colorButton.addEventListener('click', () => this.selectColor(color, colorButton));
            this.colorPaletteContainer.appendChild(colorButton);
        });
    }

    private selectColor(color: string, buttonElement: HTMLElement): void {
        this.selectedColor = color;
        this.firstDotOfPair = null;
        this.selectedColorDisplay.textContent = color;
        this.selectedColorDisplay.style.color = color;

        document.querySelectorAll('.color-button.selected').forEach(btn => btn.classList.remove('selected'));
        buttonElement.classList.add('selected');
    }

    private renderGrid(): void {
        this.gridContainer.innerHTML = '';

        const numRows = this.boardState.rows;
        const numCols = this.boardState.cols;

        if (numRows <= 0 || numCols <= 0) {
            this.gridContainer.style.width = '0px';
            this.gridContainer.style.height = '0px';
            return;
        }

        let calculatedCellSizePx: number;
        const cellWidthIfLimitedByCols = this.MAX_GRID_DIMENSION_PX / numCols;
        const cellHeightIfLimitedByRows = this.MAX_GRID_DIMENSION_PX / numRows;
        calculatedCellSizePx = Math.floor(Math.min(cellWidthIfLimitedByCols, cellHeightIfLimitedByRows));
        calculatedCellSizePx = Math.max(calculatedCellSizePx, this.MIN_CELL_SIZE_PX);
        this.cellSizePx = calculatedCellSizePx;

        const totalGridWidth = this.cellSizePx * numCols;
        const totalGridHeight = this.cellSizePx * numRows;

        this.gridContainer.style.width = `${totalGridWidth}px`;
        this.gridContainer.style.height = `${totalGridHeight}px`;

        this.gridContainer.style.gridTemplateRows = `repeat(${numRows}, ${this.cellSizePx}px)`;
        this.gridContainer.style.gridTemplateColumns = `repeat(${numCols}, ${this.cellSizePx}px)`;

        for (let r = 0; r < numRows; r++) {
            for (let c = 0; c < numCols; c++) {
                const cell = document.createElement('div');
                cell.classList.add('grid-cell');
                cell.dataset.row = r.toString();
                cell.dataset.col = c.toString();
                cell.addEventListener('click', () => this.handleCellClick(r, c));
                this.gridContainer.appendChild(cell);
            }
        }
        this.renderDots();
    }

    private renderDots(): void {
        this.gridContainer.querySelectorAll('.dot-visual').forEach(dv => dv.remove());

        this.boardState.dots.forEach(dot => {
            const cell = this.gridContainer.querySelector(`.grid-cell[data-row='${dot.row}'][data-col='${dot.col}']`);
            if (cell) {
                const dotVisual = document.createElement('div');
                dotVisual.classList.add('dot-visual');
                dotVisual.style.backgroundColor = dot.color;
                cell.appendChild(dotVisual);
            }
        });
    }

    private handleCellClick(row: number, col: number): void {
        if (!this.selectedColor) {
            this.showMessage("Please select a color first.", "error");
            return;
        }

        const existingDotIndex = this.boardState.dots.findIndex(d => d.row === row && d.col === col);

        if (existingDotIndex !== -1) {
            const existingDot = this.boardState.dots[existingDotIndex];
            if (existingDot.color === this.selectedColor) {
                this.boardState.dots.splice(existingDotIndex, 1);
                if (this.firstDotOfPair && this.firstDotOfPair.row === row && this.firstDotOfPair.col === col) {
                    this.firstDotOfPair = null;
                }
                this.renderDots();
                this.showMessage(`Dot removed from (${row}, ${col}).`, "info");
            } else {
                 this.showMessage("Cell is already occupied by a different color.", "error");
            }
            return;
        }

        const dotsOfSelectedColor = this.boardState.dots.filter(d => d.color === this.selectedColor);

        if (dotsOfSelectedColor.length >= 2) {
            this.showMessage(`Already placed two dots for color ${this.selectedColor}. Select a different color or remove existing dots of this color.`, "error");
            return;
        }

        const newDot: Dot = { row, col, color: this.selectedColor };

        if (!this.firstDotOfPair) {
            this.boardState.dots.push(newDot);
            this.firstDotOfPair = { row, col };
            this.showMessage(`First dot of color ${this.selectedColor} placed at (${row}, ${col}). Click another empty cell.`, "info");
        } else {
            if (this.firstDotOfPair.row === row && this.firstDotOfPair.col === col) { // Prevent placing second dot on the first dot's cell
                this.showMessage("Cannot place the second dot on the same cell as the first.", "error");
                return;
            }
            this.boardState.dots.push(newDot);
            this.showMessage(`Second dot of color ${this.selectedColor} placed at (${row}, ${col}). Pair complete.`, "success");
            this.firstDotOfPair = null;
        }
        this.renderDots();
    }

    private async saveBoard(): Promise<void> {
        if (!this.boardNameInput.value.trim()) {
            this.showMessage("Board name cannot be empty.", "error");
            return;
        }
        this.boardState.name = this.boardNameInput.value.trim();

        const colorCounts: { [key: string]: number } = {};
        this.boardState.dots.forEach(dot => {
            colorCounts[dot.color] = (colorCounts[dot.color] || 0) + 1;
        });

        for (const color in colorCounts) {
            if (colorCounts[color] === 1) {
                 this.showMessage(`Color ${color} has only one dot. Please complete the pair or remove it.`, "error");
                 return;
            }
        }

        const payload = {
            id: this.boardState.id,
            name: this.boardState.name,
            rows: this.boardState.rows,
            cols: this.boardState.cols,
            dots_config: this.boardState.dots
        };

        try {
            const response = await fetch('/board/api/save_board/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': this.csrfToken,
                    'X-Requested-With': 'XMLHttpRequest'
                },
                body: JSON.stringify(payload)
            });

            const result = await response.json();

            if (response.ok) {
                this.showMessage(result.message || "Board saved successfully!", "success");
                if (result.board_id) {
                    this.boardState.id = result.board_id;
                    this.boardIdInput.value = result.board_id.toString();
                    const titleDisplay = document.getElementById('board-title-display');
                    if(titleDisplay) {
                         titleDisplay.textContent = this.boardState.name;
                    } else {
                        const h1 = document.querySelector('h1');
                        if(h1) h1.innerHTML = `Edit Board: <span id="board-title-display">${this.boardState.name}</span>`;
                    }
                    if (this.boardState.id && !window.location.pathname.includes(this.boardState.id.toString())) {
                         window.history.pushState({}, '', `/board/${this.boardState.id}/edit/`);
                    }
                }
            } else {
                let errorMsg = result.message || "Failed to save board.";
                if (result.errors) {
                    errorMsg += "<ul>";
                    for (const field in result.errors) {
                        result.errors[field].forEach((err: string) => {
                            errorMsg += `<li>${field}: ${err}</li>`;
                        });
                    }
                    errorMsg += "</ul>";
                }
                this.showMessage(errorMsg, "error", false);
            }
        } catch (error) {
            console.error("Error saving board:", error);
            this.showMessage("An unexpected error occurred while saving.", "error");
        }
    }

    public async getBoardAsImageDataURL(format: 'image/png' | 'image/jpeg' = 'image/png'): Promise<string | null> {
        const rows = this.boardState.rows;
        const cols = this.boardState.cols;
        const dots = this.boardState.dots;

        if (rows <= 0 || cols <= 0 || this.cellSizePx <= 0) {
            console.error("Board dimensions or cell size invalid for image generation.");
            return null;
        }

        const canvas = document.createElement('canvas');
        const canvasWidth = cols * this.cellSizePx;
        const canvasHeight = rows * this.cellSizePx;
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        const ctx = canvas.getContext('2d');
        if (!ctx) {
            console.error("Could not get 2D context from canvas");
            return null;
        }

        // 1. Draw background (optional)
        ctx.fillStyle = "#FFFFFF"; // White background
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // 2. Draw grid lines
        ctx.strokeStyle = "#CCCCCC"; // Light grey for grid lines
        ctx.lineWidth = 1;

        for (let r = 0; r <= rows; r++) {
            ctx.beginPath();
            ctx.moveTo(0, r * this.cellSizePx);
            ctx.lineTo(canvas.width, r * this.cellSizePx);
            ctx.stroke();
        }
        for (let c = 0; c <= cols; c++) {
            ctx.beginPath();
            ctx.moveTo(c * this.cellSizePx, 0);
            ctx.lineTo(c * this.cellSizePx, canvas.height);
            ctx.stroke();
        }

        // 3. Draw the colored dots
        const dotRadius = this.cellSizePx * 0.35; // 35% of cell size for dot radius
        dots.forEach(dot => {
            const centerX = dot.col * this.cellSizePx + this.cellSizePx / 2;
            const centerY = dot.row * this.cellSizePx + this.cellSizePx / 2;

            ctx.beginPath();
            ctx.arc(centerX, centerY, dotRadius, 0, 2 * Math.PI, false);
            ctx.fillStyle = dot.color;
            ctx.fill();
            // Optional: add a border to dots
            // ctx.lineWidth = 1;
            // ctx.strokeStyle = '#333333';
            // ctx.stroke();
        });

        return canvas.toDataURL(format);
    }

    public async handleSaveAsImage(): Promise<void> {
        this.showMessage("Generating image...", "info", false);
        const imageDataURL = await this.getBoardAsImageDataURL();

        if (!imageDataURL) {
            this.showMessage("Failed to generate image data.", "error");
            return;
        }

        // Prepare data for backend
        const boardName = this.boardState.name || "Generated Grid Board";
        const fileName = `${boardName.replace(/[^a-zA-Z0-9]/g, '_')}_${Date.now()}.png`;

        const payload = {
            name: boardName,       // Name for the UserImage
            image_data_url: imageDataURL,
            filename: fileName     // Suggested filename
        };

        try {
            const response = await fetch('/api/save_grid_as_image/', { // NEW ENDPOINT
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': this.csrfToken,
                },
                body: JSON.stringify(payload)
            });

            const result = await response.json();
            if (response.ok && result.status === 'success') {
                this.showMessage(`Board saved as image: ${result.image_name}. You can now use it for path editing.`, "success");
                // Optionally redirect or update UI
            } else {
                this.showMessage(result.message || "Failed to save board as image on server.", "error");
            }
        } catch (error) {
            console.error("Error saving board as image:", error);
            this.showMessage("An error occurred while sending image to server.", "error");
        }
    }

    private showMessage(message: string, type: 'success' | 'error' | 'info', autoClear: boolean = true): void {
        this.messagesDiv.innerHTML = `<p class="${type}">${message}</p>`;
        if (autoClear) {
            setTimeout(() => {
                this.messagesDiv.innerHTML = '';
            }, 5000);
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    if (document.getElementById('grid-container')) {
        new BoardEditor();
    }
});

===== File: ./static/main/ts/dist/sseNotifications.js =====
"use strict";
// static/main/ts/src/sseNotifications.ts
class SSENotifications {
    constructor(endpointUrl = '/board/events/') {
        this.eventSource = null;
        this.toastContainer = null;
        this.sseEndpointUrl = endpointUrl;
        this.toastContainer = document.getElementById('toast-container');
        // Inicjuj tylko jeÅ›li kontener istnieje
        if (this.toastContainer) {
            this.connect();
        }
        else {
            console.warn("Toast container not found. SSE Notifications will not be displayed visually.");
            // Mimo to moÅ¼na prÃ³bowaÄ‡ siÄ™ poÅ‚Ä…czyÄ‡, jeÅ›li powiadomienia majÄ… inne efekty
            // this.connect(); 
        }
    }
    connect() {
        if (this.eventSource && (this.eventSource.readyState === EventSource.OPEN || this.eventSource.readyState === EventSource.CONNECTING)) {
            console.log("SSE connection already open or connecting.");
            return;
        }
        console.log(`Attempting to connect to SSE endpoint: ${this.sseEndpointUrl}`);
        this.eventSource = new EventSource(this.sseEndpointUrl);
        this.eventSource.onopen = (event) => {
            console.log("SSE Connection opened.", event);
            // MoÅ¼esz tu wyÅ›wietliÄ‡ powiadomienie o poÅ‚Ä…czeniu, jeÅ›li chcesz
            // this.showToast("Connected to real-time notifications.", "info");
        };
        this.eventSource.onerror = (error) => {
            console.error("SSE Error:", error);
            // MoÅ¼esz sprÃ³bowaÄ‡ zamknÄ…Ä‡ i ponownie otworzyÄ‡ poÅ‚Ä…czenie po jakimÅ› czasie,
            // EventSource domyÅ›lnie prÃ³buje siÄ™ poÅ‚Ä…czyÄ‡ ponownie.
            if (this.eventSource) {
                this.showToast("Notification service error. Reconnecting...", "error", 10000);
                // DomyÅ›lne ponowne poÅ‚Ä…czenie EventSource powinno zadziaÅ‚aÄ‡.
                // JeÅ›li readyState to EventSource.CLOSED, moÅ¼na by sprÃ³bowaÄ‡ this.eventSource.close(); a potem this.connect();
            }
        };
        // Listener dla konkretnego zdarzenia "newBoard"
        this.eventSource.addEventListener('newBoard', (event) => {
            console.log("SSE newBoard event received:", event);
            try {
                const data = JSON.parse(event.data);
                const message = `User '${data.creator_username}' created a new board: "${data.board_name}".`;
                // Opcjonalnie: link do planszy
                const link = `/board/${data.board_id}/edit/`; // Dostosuj URL, jeÅ›li jest inny
                this.showToast(message, "success", 7000, link);
            }
            catch (e) {
                console.error("Error parsing newBoard data:", e);
            }
        });
        // Listener dla konkretnego zdarzenia "newPath"
        this.eventSource.addEventListener('newPath', (event) => {
            console.log("SSE newPath event received:", event);
            try {
                const data = JSON.parse(event.data);
                let messageBase = `User '${data.user_username}' `;
                if (data.action === "created") {
                    messageBase += `uploaded a new path background: "${data.board_name}".`;
                }
                else if (data.action === "updated") {
                    messageBase += `updated paths on board: "${data.board_name}".`;
                }
                else if (data.action === "point_added") {
                    messageBase += `added a point to a path on board: "${data.board_name}".`;
                }
                else {
                    messageBase += `saved a path on board: "${data.board_name}".`;
                }
                // Opcjonalnie: link do planszy (UserImage)
                // ZakÅ‚adajÄ…c, Å¼e `home.html` przyjmuje `?selected=IMAGE_NAME`
                const link = `/?selected=${encodeURIComponent(data.board_name)}`; // Dostosuj URL
                this.showToast(messageBase, "info", 7000, link);
            }
            catch (e) {
                console.error("Error parsing newPath data:", e);
            }
        });
        // OgÃ³lny listener onmessage (opcjonalnie, jeÅ›li chcesz przechwytywaÄ‡ zdarzenia bez okreÅ›lonego typu 'event:')
        // lub komentarze keep-alive (choÄ‡ zwykle sÄ… ignorowane przez EventSource).
        this.eventSource.onmessage = (event) => {
            // Komentarze keep-alive (zaczynajÄ…ce siÄ™ od ':') nie powinny tu trafiaÄ‡.
            // JeÅ›li serwer wysyÅ‚a zdarzenia bez linii "event: name", trafiÄ… one tutaj.
            console.log("SSE Generic message received:", event.data);
        };
    }
    showToast(message, type = 'info', duration = 5000, link) {
        if (!this.toastContainer)
            return;
        const toast = document.createElement('div');
        toast.className = `toast-notification ${type}`;
        let content = message;
        if (link) {
            content = `<a href="${link}" style="color: white; text-decoration: underline;">${message}</a>`;
        }
        toast.innerHTML = content; // UÅ¼yj innerHTML, jeÅ›li masz link
        const closeBtn = document.createElement('button');
        closeBtn.className = 'toast-close-btn';
        closeBtn.innerHTML = 'Ã—';
        closeBtn.onclick = () => {
            toast.classList.remove('show');
            setTimeout(() => {
                var _a;
                if (toast.parentNode === this.toastContainer) { // SprawdÅº, czy wciÄ…Å¼ jest dzieckiem
                    (_a = this.toastContainer) === null || _a === void 0 ? void 0 : _a.removeChild(toast);
                }
            }, 500); // Czas na animacjÄ™ wyjÅ›cia
        };
        toast.appendChild(closeBtn);
        this.toastContainer.appendChild(toast);
        // WymuÅ› reflow, aby animacja zadziaÅ‚aÅ‚a przy dodaniu klasy 'show'
        void toast.offsetWidth;
        toast.classList.add('show');
        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => {
                var _a;
                // SprawdÅº, czy element wciÄ…Å¼ istnieje i jest dzieckiem kontenera przed usuniÄ™ciem
                if (toast.parentNode === this.toastContainer) {
                    (_a = this.toastContainer) === null || _a === void 0 ? void 0 : _a.removeChild(toast);
                }
            }, 500); // Czas na animacjÄ™ wyjÅ›cia
        }, duration);
    }
    closeConnection() {
        if (this.eventSource) {
            this.eventSource.close();
            console.log("SSE Connection closed by client.");
        }
    }
}
// Inicjalizacja po zaÅ‚adowaniu DOM
// MoÅ¼esz zdecydowaÄ‡, czy chcesz to inicjowaÄ‡ na kaÅ¼dej stronie,
// czy tylko na wybranych (np. sprawdzajÄ…c istnienie pewnego elementu).
document.addEventListener('DOMContentLoaded', () => {
    // SprawdÅº, czy uÅ¼ytkownik jest zalogowany, zanim nawiÄ…Å¼esz poÅ‚Ä…czenie SSE,
    // jeÅ›li endpoint SSE wymaga autoryzacji lub jeÅ›li powiadomienia sÄ… tylko dla zalogowanych.
    // MoÅ¼esz to zrobiÄ‡ sprawdzajÄ…c obecnoÅ›Ä‡ np. elementu z nazwÄ… uÅ¼ytkownika
    // lub przekazujÄ…c flagÄ™ z Django do szablonu.
    // Prosty przykÅ‚ad: inicjuj zawsze, jeÅ›li jest kontener na toasty
    if (document.getElementById('toast-container')) {
        console.log("Initializing SSE Notifications client...");
        const sseClient = new SSENotifications('/board/events/'); // UÅ»YJ POPRAWNEGO URL ENDPOINTU SSE
        // Aby mÃ³c zamknÄ…Ä‡ poÅ‚Ä…czenie np. przy wylogowaniu:
        // window.sseClient = sseClient; 
    }
});
//# sourceMappingURL=sseNotifications.js.map

===== File: ./static/main/ts/dist/grid.js =====
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class BoardEditor {
    constructor() {
        this.cellSizePx = 0;
        this.boardState = {
            id: null,
            name: "My New Board",
            rows: 5,
            cols: 5,
            dots: []
        };
        this.availableColors = [
            "#FF0000", "#00FF00", "#0000FF", "#FFFF00", "#FF00FF", "#00FFFF",
            "#FFA500", "#800080", "#A52A2A", "#008000"
        ];
        this.selectedColor = null;
        this.firstDotOfPair = null;
        this.MAX_GRID_DIMENSION_PX = 400;
        this.MIN_CELL_SIZE_PX = 10;
        this.gridContainer = document.getElementById('grid-container');
        this.numRowsInput = document.getElementById('numRows');
        this.numColsInput = document.getElementById('numCols');
        this.boardNameInput = document.getElementById('boardName');
        this.generateGridButton = document.getElementById('generateGridButton');
        this.saveBoardButton = document.getElementById('saveBoardButton');
        this.colorPaletteContainer = document.getElementById('color-palette');
        this.selectedColorDisplay = document.getElementById('selected-color-display');
        this.messagesDiv = document.getElementById('messages');
        this.boardIdInput = document.getElementById('boardId');
        this.saveAsImageButton = document.getElementById('saveAsImageButton');
        const csrfTokenElement = document.querySelector('[name=csrfmiddlewaretoken]');
        this.csrfToken = csrfTokenElement ? csrfTokenElement.value : '';
        this.loadInitialBoardData();
        this.initEventListeners();
        this.populateColorPalette();
        if (!this.boardState.id) {
            this.updateBoardStateFromInputs();
        }
        this.renderGrid();
    }
    loadInitialBoardData() {
        const initialDataScript = document.getElementById('initial-board-data');
        if (initialDataScript && initialDataScript.textContent) {
            try {
                const data = JSON.parse(initialDataScript.textContent);
                if (data && data.id) {
                    this.boardState.id = data.id;
                    this.boardState.name = data.name;
                    this.boardState.rows = data.rows;
                    this.boardState.cols = data.cols;
                    this.boardState.dots = data.dots_config || [];
                    this.boardNameInput.value = this.boardState.name;
                    this.numRowsInput.value = this.boardState.rows.toString();
                    this.numColsInput.value = this.boardState.cols.toString();
                }
            }
            catch (e) {
                console.error("Error parsing initial board data:", e);
            }
        }
    }
    initEventListeners() {
        this.saveAsImageButton.addEventListener('click', () => this.handleSaveAsImage());
        this.generateGridButton.addEventListener('click', () => {
            const oldRows = this.boardState.rows;
            const oldCols = this.boardState.cols;
            const newRows = parseInt(this.numRowsInput.value, 10);
            const newCols = parseInt(this.numColsInput.value, 10);
            if (this.boardState.rows !== newRows || this.boardState.cols !== newCols) {
                this.boardState.dots = this.boardState.dots.filter(dot => dot.row < newRows && dot.col < newCols);
                this.firstDotOfPair = null;
            }
            this.boardState.rows = newRows;
            this.boardState.cols = newCols;
            this.renderGrid();
        });
        this.saveBoardButton.addEventListener('click', () => this.saveBoard());
        this.boardNameInput.addEventListener('input', () => {
            this.boardState.name = this.boardNameInput.value;
            const titleDisplay = document.getElementById('board-title-display');
            if (titleDisplay)
                titleDisplay.textContent = this.boardState.name;
        });
    }
    updateBoardStateFromInputs() {
        this.boardState.name = this.boardNameInput.value;
        this.boardState.rows = parseInt(this.numRowsInput.value, 10) || 5;
        this.boardState.cols = parseInt(this.numColsInput.value, 10) || 5;
    }
    populateColorPalette() {
        this.availableColors.forEach(color => {
            const colorButton = document.createElement('div');
            colorButton.classList.add('color-button');
            colorButton.style.backgroundColor = color;
            colorButton.dataset.color = color;
            colorButton.addEventListener('click', () => this.selectColor(color, colorButton));
            this.colorPaletteContainer.appendChild(colorButton);
        });
    }
    selectColor(color, buttonElement) {
        this.selectedColor = color;
        this.firstDotOfPair = null;
        this.selectedColorDisplay.textContent = color;
        this.selectedColorDisplay.style.color = color;
        document.querySelectorAll('.color-button.selected').forEach(btn => btn.classList.remove('selected'));
        buttonElement.classList.add('selected');
    }
    renderGrid() {
        this.gridContainer.innerHTML = '';
        const numRows = this.boardState.rows;
        const numCols = this.boardState.cols;
        if (numRows <= 0 || numCols <= 0) {
            this.gridContainer.style.width = '0px';
            this.gridContainer.style.height = '0px';
            return;
        }
        let calculatedCellSizePx;
        const cellWidthIfLimitedByCols = this.MAX_GRID_DIMENSION_PX / numCols;
        const cellHeightIfLimitedByRows = this.MAX_GRID_DIMENSION_PX / numRows;
        calculatedCellSizePx = Math.floor(Math.min(cellWidthIfLimitedByCols, cellHeightIfLimitedByRows));
        calculatedCellSizePx = Math.max(calculatedCellSizePx, this.MIN_CELL_SIZE_PX);
        this.cellSizePx = calculatedCellSizePx;
        const totalGridWidth = this.cellSizePx * numCols;
        const totalGridHeight = this.cellSizePx * numRows;
        this.gridContainer.style.width = `${totalGridWidth}px`;
        this.gridContainer.style.height = `${totalGridHeight}px`;
        this.gridContainer.style.gridTemplateRows = `repeat(${numRows}, ${this.cellSizePx}px)`;
        this.gridContainer.style.gridTemplateColumns = `repeat(${numCols}, ${this.cellSizePx}px)`;
        for (let r = 0; r < numRows; r++) {
            for (let c = 0; c < numCols; c++) {
                const cell = document.createElement('div');
                cell.classList.add('grid-cell');
                cell.dataset.row = r.toString();
                cell.dataset.col = c.toString();
                cell.addEventListener('click', () => this.handleCellClick(r, c));
                this.gridContainer.appendChild(cell);
            }
        }
        this.renderDots();
    }
    renderDots() {
        this.gridContainer.querySelectorAll('.dot-visual').forEach(dv => dv.remove());
        this.boardState.dots.forEach(dot => {
            const cell = this.gridContainer.querySelector(`.grid-cell[data-row='${dot.row}'][data-col='${dot.col}']`);
            if (cell) {
                const dotVisual = document.createElement('div');
                dotVisual.classList.add('dot-visual');
                dotVisual.style.backgroundColor = dot.color;
                cell.appendChild(dotVisual);
            }
        });
    }
    handleCellClick(row, col) {
        if (!this.selectedColor) {
            this.showMessage("Please select a color first.", "error");
            return;
        }
        const existingDotIndex = this.boardState.dots.findIndex(d => d.row === row && d.col === col);
        if (existingDotIndex !== -1) {
            const existingDot = this.boardState.dots[existingDotIndex];
            if (existingDot.color === this.selectedColor) {
                this.boardState.dots.splice(existingDotIndex, 1);
                if (this.firstDotOfPair && this.firstDotOfPair.row === row && this.firstDotOfPair.col === col) {
                    this.firstDotOfPair = null;
                }
                this.renderDots();
                this.showMessage(`Dot removed from (${row}, ${col}).`, "info");
            }
            else {
                this.showMessage("Cell is already occupied by a different color.", "error");
            }
            return;
        }
        const dotsOfSelectedColor = this.boardState.dots.filter(d => d.color === this.selectedColor);
        if (dotsOfSelectedColor.length >= 2) {
            this.showMessage(`Already placed two dots for color ${this.selectedColor}. Select a different color or remove existing dots of this color.`, "error");
            return;
        }
        const newDot = { row, col, color: this.selectedColor };
        if (!this.firstDotOfPair) {
            this.boardState.dots.push(newDot);
            this.firstDotOfPair = { row, col };
            this.showMessage(`First dot of color ${this.selectedColor} placed at (${row}, ${col}). Click another empty cell.`, "info");
        }
        else {
            if (this.firstDotOfPair.row === row && this.firstDotOfPair.col === col) { // Prevent placing second dot on the first dot's cell
                this.showMessage("Cannot place the second dot on the same cell as the first.", "error");
                return;
            }
            this.boardState.dots.push(newDot);
            this.showMessage(`Second dot of color ${this.selectedColor} placed at (${row}, ${col}). Pair complete.`, "success");
            this.firstDotOfPair = null;
        }
        this.renderDots();
    }
    saveBoard() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.boardNameInput.value.trim()) {
                this.showMessage("Board name cannot be empty.", "error");
                return;
            }
            this.boardState.name = this.boardNameInput.value.trim();
            const colorCounts = {};
            this.boardState.dots.forEach(dot => {
                colorCounts[dot.color] = (colorCounts[dot.color] || 0) + 1;
            });
            for (const color in colorCounts) {
                if (colorCounts[color] === 1) {
                    this.showMessage(`Color ${color} has only one dot. Please complete the pair or remove it.`, "error");
                    return;
                }
            }
            const payload = {
                id: this.boardState.id,
                name: this.boardState.name,
                rows: this.boardState.rows,
                cols: this.boardState.cols,
                dots_config: this.boardState.dots
            };
            try {
                const response = yield fetch('/board/api/save_board/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': this.csrfToken,
                        'X-Requested-With': 'XMLHttpRequest'
                    },
                    body: JSON.stringify(payload)
                });
                const result = yield response.json();
                if (response.ok) {
                    this.showMessage(result.message || "Board saved successfully!", "success");
                    if (result.board_id) {
                        this.boardState.id = result.board_id;
                        this.boardIdInput.value = result.board_id.toString();
                        const titleDisplay = document.getElementById('board-title-display');
                        if (titleDisplay) {
                            titleDisplay.textContent = this.boardState.name;
                        }
                        else {
                            const h1 = document.querySelector('h1');
                            if (h1)
                                h1.innerHTML = `Edit Board: <span id="board-title-display">${this.boardState.name}</span>`;
                        }
                        if (this.boardState.id && !window.location.pathname.includes(this.boardState.id.toString())) {
                            window.history.pushState({}, '', `/board/${this.boardState.id}/edit/`);
                        }
                    }
                }
                else {
                    let errorMsg = result.message || "Failed to save board.";
                    if (result.errors) {
                        errorMsg += "<ul>";
                        for (const field in result.errors) {
                            result.errors[field].forEach((err) => {
                                errorMsg += `<li>${field}: ${err}</li>`;
                            });
                        }
                        errorMsg += "</ul>";
                    }
                    this.showMessage(errorMsg, "error", false);
                }
            }
            catch (error) {
                console.error("Error saving board:", error);
                this.showMessage("An unexpected error occurred while saving.", "error");
            }
        });
    }
    getBoardAsImageDataURL() {
        return __awaiter(this, arguments, void 0, function* (format = 'image/png') {
            const rows = this.boardState.rows;
            const cols = this.boardState.cols;
            const dots = this.boardState.dots;
            if (rows <= 0 || cols <= 0 || this.cellSizePx <= 0) {
                console.error("Board dimensions or cell size invalid for image generation.");
                return null;
            }
            const canvas = document.createElement('canvas');
            const canvasWidth = cols * this.cellSizePx;
            const canvasHeight = rows * this.cellSizePx;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            const ctx = canvas.getContext('2d');
            if (!ctx) {
                console.error("Could not get 2D context from canvas");
                return null;
            }
            // 1. Draw background (optional)
            ctx.fillStyle = "#FFFFFF"; // White background
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            // 2. Draw grid lines
            ctx.strokeStyle = "#CCCCCC"; // Light grey for grid lines
            ctx.lineWidth = 1;
            for (let r = 0; r <= rows; r++) {
                ctx.beginPath();
                ctx.moveTo(0, r * this.cellSizePx);
                ctx.lineTo(canvas.width, r * this.cellSizePx);
                ctx.stroke();
            }
            for (let c = 0; c <= cols; c++) {
                ctx.beginPath();
                ctx.moveTo(c * this.cellSizePx, 0);
                ctx.lineTo(c * this.cellSizePx, canvas.height);
                ctx.stroke();
            }
            // 3. Draw the colored dots
            const dotRadius = this.cellSizePx * 0.35; // 35% of cell size for dot radius
            dots.forEach(dot => {
                const centerX = dot.col * this.cellSizePx + this.cellSizePx / 2;
                const centerY = dot.row * this.cellSizePx + this.cellSizePx / 2;
                ctx.beginPath();
                ctx.arc(centerX, centerY, dotRadius, 0, 2 * Math.PI, false);
                ctx.fillStyle = dot.color;
                ctx.fill();
                // Optional: add a border to dots
                // ctx.lineWidth = 1;
                // ctx.strokeStyle = '#333333';
                // ctx.stroke();
            });
            return canvas.toDataURL(format);
        });
    }
    handleSaveAsImage() {
        return __awaiter(this, void 0, void 0, function* () {
            this.showMessage("Generating image...", "info", false);
            const imageDataURL = yield this.getBoardAsImageDataURL();
            if (!imageDataURL) {
                this.showMessage("Failed to generate image data.", "error");
                return;
            }
            // Prepare data for backend
            const boardName = this.boardState.name || "Generated Grid Board";
            const fileName = `${boardName.replace(/[^a-zA-Z0-9]/g, '_')}_${Date.now()}.png`;
            const payload = {
                name: boardName, // Name for the UserImage
                image_data_url: imageDataURL,
                filename: fileName // Suggested filename
            };
            try {
                const response = yield fetch('/api/save_grid_as_image/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': this.csrfToken,
                    },
                    body: JSON.stringify(payload)
                });
                const result = yield response.json();
                if (response.ok && result.status === 'success') {
                    this.showMessage(`Board saved as image: ${result.image_name}. You can now use it for path editing.`, "success");
                    // Optionally redirect or update UI
                }
                else {
                    this.showMessage(result.message || "Failed to save board as image on server.", "error");
                }
            }
            catch (error) {
                console.error("Error saving board as image:", error);
                this.showMessage("An error occurred while sending image to server.", "error");
            }
        });
    }
    showMessage(message, type, autoClear = true) {
        this.messagesDiv.innerHTML = `<p class="${type}">${message}</p>`;
        if (autoClear) {
            setTimeout(() => {
                this.messagesDiv.innerHTML = '';
            }, 5000);
        }
    }
}
document.addEventListener('DOMContentLoaded', () => {
    if (document.getElementById('grid-container')) {
        new BoardEditor();
    }
});
//# sourceMappingURL=grid.js.map

===== File: ./static/main/ts/dist/functions.js =====
"use strict";
// functions.ts
// --- Funkcje ---
function initializePageElements() {
    redrawLines();
    document.querySelectorAll('.click-dot').forEach(initializeDot);
    renumberDotsAndListItems();
}
function renumberDotsAndListItems() {
    const dots = document.querySelectorAll('.click-dot');
    dots.forEach((dot, index) => {
        const dotNumberElement = dot.querySelector('.dot-number');
        if (dotNumberElement) {
            dotNumberElement.innerText = (index + 1).toString();
        }
    });
    const listItems = document.querySelectorAll('#coordinates-list .coordinate-item');
    listItems.forEach((item, index) => {
        const pointDisplayNumber = item.querySelector('.point-display-number');
        if (pointDisplayNumber) {
            pointDisplayNumber.innerText = (index + 1).toString();
        }
    });
    redrawLines();
}
function redrawLines() {
    const svg = document.getElementById('connection-lines');
    if (!svg)
        return;
    svg.innerHTML = '';
    const dots = Array.from(document.querySelectorAll('.click-dot'));
    if (dots.length < 2)
        return;
    for (let i = 0; i < dots.length - 1; i++) {
        const dot1 = dots[i];
        const dot2 = dots[i + 1];
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        const x1 = parseFloat(dot1.style.left || '0');
        const y1 = parseFloat(dot1.style.top || '0');
        const x2 = parseFloat(dot2.style.left || '0');
        const y2 = parseFloat(dot2.style.top || '0');
        line.setAttribute('x1', x1.toString());
        line.setAttribute('y1', y1.toString());
        line.setAttribute('x2', x2.toString());
        line.setAttribute('y2', y2.toString());
        line.setAttribute('stroke-width', '2');
        line.setAttribute('stroke', '#ff0000');
        svg.appendChild(line);
    }
}
function createCoordinateListItem(clickId, x, y, isNew = false) {
    const listItem = document.createElement('li');
    listItem.classList.add('coordinate-item');
    if (!isNew && clickId !== null) {
        listItem.setAttribute('data-click-id', clickId.toString());
    }
    const pointNumberSpan = document.createElement('span');
    pointNumberSpan.classList.add('point-display-number');
    const inputX = document.createElement('input');
    inputX.type = 'number';
    inputX.classList.add('coord-x-input');
    inputX.value = x.toFixed(2);
    inputX.step = '0.01';
    inputX.autocomplete = 'off';
    const inputY = document.createElement('input');
    inputY.type = 'number';
    inputY.classList.add('coord-y-input');
    inputY.value = y.toFixed(2);
    inputY.step = '0.01';
    inputY.autocomplete = 'off';
    const updateButton = document.createElement('button');
    updateButton.classList.add('update-coord-btn');
    updateButton.textContent = isNew ? 'Save New' : 'Update';
    if (isNew) {
        updateButton.classList.add('save-new-coord-btn');
    }
    const deleteButton = document.createElement('button');
    deleteButton.classList.add('delete-coord-btn');
    deleteButton.textContent = 'Delete';
    listItem.appendChild(document.createTextNode('Point '));
    listItem.appendChild(pointNumberSpan);
    listItem.appendChild(document.createTextNode(': X '));
    listItem.appendChild(inputX);
    listItem.appendChild(document.createTextNode(' Y '));
    listItem.appendChild(inputY);
    listItem.appendChild(updateButton);
    listItem.appendChild(deleteButton);
    const coordinatesList = document.getElementById('coordinates-list');
    if (coordinatesList) {
        coordinatesList.appendChild(listItem);
    }
    else {
        console.error("Element with ID 'coordinates-list' not found.");
    }
    attachEventListenersToListItem(listItem, isNew);
    return listItem;
}
function attachEventListenersToListItem(listItem, isNewInitially = false) {
    const updateBtn = listItem.querySelector('.update-coord-btn');
    const deleteBtn = listItem.querySelector('.delete-coord-btn');
    const inputX = listItem.querySelector('.coord-x-input');
    const inputY = listItem.querySelector('.coord-y-input');
    let isStillNew = isNewInitially;
    if (!updateBtn || !deleteBtn || !inputX || !inputY) {
        console.error("Could not find all required elements within list item:", listItem);
        return;
    }
    console.log(`[attachEventListenersToListItem] For item data-id=${listItem.dataset.clickId}, X_val=${inputX.value}, Y_val=${inputY.value}`);
    updateBtn.addEventListener('click', function () {
        const currentClickIdStr = listItem.dataset.clickId;
        const currentClickId = currentClickIdStr ? parseInt(currentClickIdStr, 10) : null;
        const newX = parseFloat(inputX.value);
        const newY = parseFloat(inputY.value);
        if (isNaN(newX) || isNaN(newY)) {
            alert('Please enter valid numbers for X and Y.');
            return;
        }
        const requestBody = {
            item_id: selectedImageId,
            item_type: 'user_image',
            x: newX,
            y: newY,
            id: currentClickId
        };
        if (isStillNew || currentClickId === null) {
            fetch('/add-click/', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
                body: JSON.stringify({ image_id: requestBody.item_id, x: newX, y: newY })
            })
                .then(response => response.json())
                .then(data => {
                if (data.success && data.click_id !== undefined) {
                    listItem.setAttribute('data-click-id', data.click_id.toString());
                    updateBtn.textContent = 'Update';
                    if (updateBtn.classList.contains('save-new-coord-btn')) {
                        updateBtn.classList.remove('save-new-coord-btn');
                    }
                    isStillNew = false;
                    createDotOnImage(data.click_id, newX, newY);
                    renumberDotsAndListItems();
                }
                else {
                    alert('Failed to save new point. ' + (data.error || ''));
                }
            }).catch(error => console.error('Error saving new point:', error));
        }
        else {
            fetch('/update-click/', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
                body: JSON.stringify({ id: currentClickId, x: newX, y: newY })
            })
                .then(response => response.json())
                .then(data => {
                if (data.status === 'success') {
                    const dot = document.querySelector(`.click-dot[data-id="${currentClickId}"]`);
                    if (dot) {
                        dot.style.left = newX + 'px';
                        dot.style.top = newY + 'px';
                        redrawLines();
                    }
                }
                else {
                    alert('Failed to update point. ' + (data.message || ''));
                }
            }).catch(error => console.error('Error updating point:', error));
        }
    });
    listItem.addEventListener('mouseenter', () => {
        const clickId = listItem.dataset.clickId;
        if (!clickId)
            return;
        listItem.classList.add('highlighted');
        const dotElement = document.querySelector(`.click-dot[data-id="${clickId}"]`);
        if (dotElement) {
            dotElement.classList.add('highlighted');
        }
    });
    listItem.addEventListener('mouseleave', () => {
        const clickId = listItem.dataset.clickId;
        if (!clickId)
            return;
        listItem.classList.remove('highlighted');
        const dotElement = document.querySelector(`.click-dot[data-id="${clickId}"]`);
        if (dotElement) {
            dotElement.classList.remove('highlighted');
        }
    });
    deleteBtn.addEventListener('click', function () {
        const currentClickIdStr = listItem.dataset.clickId;
        if (isStillNew || !currentClickIdStr) {
            listItem.remove();
            renumberDotsAndListItems();
            return;
        }
        const currentClickId = parseInt(currentClickIdStr, 10);
        fetch('/delete-click/', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
            body: JSON.stringify({ id: currentClickId })
        })
            .then(response => response.json())
            .then(data => {
            if (data.status === 'deleted') {
                listItem.remove();
                const dot = document.querySelector(`.click-dot[data-id="${currentClickId}"]`);
                if (dot)
                    dot.remove();
                renumberDotsAndListItems();
            }
            else {
                alert('Failed to delete point.');
            }
        }).catch(error => console.error('Error deleting point:', error));
    });
    [inputX, inputY].forEach(inputField => {
        inputField.addEventListener('input', function () {
            const currentClickIdStr = listItem.dataset.clickId;
            if (currentClickIdStr && !isStillNew) {
                const currentClickId = parseInt(currentClickIdStr, 10);
                const dot = document.querySelector(`.click-dot[data-id="${currentClickId}"]`);
                if (dot) {
                    let newXFromInput = parseFloat(inputX.value);
                    let newYFromInput = parseFloat(inputY.value);
                    if (!isNaN(newXFromInput) && !isNaN(newYFromInput)) {
                        // --- BEGIN MODIFICATION: Clamp coordinates for live input update ---
                        const mainImageElement = document.getElementById('main-image');
                        let clampedX = newXFromInput;
                        let clampedY = newYFromInput;
                        if (mainImageElement) {
                            const dotWidth = 10; // As per CSS .click-dot width
                            const dotHeight = 10; // As per CSS .click-dot height
                            // Clamp X
                            if (mainImageElement.width < dotWidth) {
                                clampedX = mainImageElement.width / 2;
                            }
                            else {
                                const minXAllowed = dotWidth / 2;
                                const maxXAllowed = mainImageElement.width - (dotWidth / 2);
                                clampedX = Math.max(minXAllowed, Math.min(newXFromInput, maxXAllowed));
                            }
                            // Clamp Y
                            if (mainImageElement.height < dotHeight) {
                                clampedY = mainImageElement.height / 2;
                            }
                            else {
                                const minYAllowed = dotHeight / 2;
                                const maxYAllowed = mainImageElement.height - (dotHeight / 2);
                                clampedY = Math.max(minYAllowed, Math.min(newYFromInput, maxYAllowed));
                            }
                            // Update input field if value was clamped, to give feedback
                            if (clampedX.toFixed(2) !== newXFromInput.toFixed(2) && inputField === inputX) {
                                inputX.value = clampedX.toFixed(2);
                            }
                            if (clampedY.toFixed(2) !== newYFromInput.toFixed(2) && inputField === inputY) {
                                inputY.value = clampedY.toFixed(2);
                            }
                        }
                        else {
                            console.warn("Main image element not found, cannot apply boundary constraints for live input.");
                        }
                        // --- END MODIFICATION ---
                        dot.style.left = clampedX + 'px';
                        dot.style.top = clampedY + 'px';
                        redrawLines();
                    }
                }
            }
        });
    });
}
function initializeCoordinateListInteractions() {
    document.querySelectorAll('#coordinates-list .coordinate-item').forEach(item => {
        const clickId = item.dataset.clickId;
        if (clickId) {
            attachEventListenersToListItem(item, false);
        }
    });
    const addPointToListBtn = document.getElementById('add-point-on-list-btn');
    if (addPointToListBtn) {
        addPointToListBtn.addEventListener('click', () => {
            const mainImage = document.getElementById('main-image');
            const defaultX = mainImage ? mainImage.width / 2 : 50;
            const defaultY = mainImage ? mainImage.height / 2 : 50;
            createCoordinateListItem(null, defaultX, defaultY, true);
            renumberDotsAndListItems();
        });
    }
}
function initializeDot(dot) {
    const image = document.getElementById("main-image");
    dot.addEventListener("mousedown", (e) => {
        if (e.button !== 0)
            return;
        draggedDot = dot;
        e.preventDefault();
        document.addEventListener('mouseup', handleDocumentMouseUp, { once: true });
    });
    const deleteBtn = dot.querySelector('.delete-dot-btn');
    if (deleteBtn) {
        deleteBtn.addEventListener('click', function (e) {
            e.stopPropagation();
            const clickIdStr = dot.dataset.id;
            if (!clickIdStr) {
                console.warn("Dot has no data-id for deletion:", dot);
                return;
            }
            const clickId = parseInt(clickIdStr, 10);
            fetch('/delete-click/', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
                body: JSON.stringify({ id: clickId })
            })
                .then(response => response.json())
                .then(data => {
                if (data.status === 'deleted') {
                    dot.remove();
                    const listItem = document.querySelector(`#coordinates-list .coordinate-item[data-click-id="${clickId}"]`);
                    if (listItem)
                        listItem.remove();
                    renumberDotsAndListItems();
                }
                else {
                    alert('Failed to delete point.');
                }
            }).catch(error => console.error('Error deleting point:', error));
        });
    }
    dot.addEventListener('mouseenter', () => {
        const clickId = dot.dataset.id;
        if (!clickId)
            return;
        dot.classList.add('highlighted');
        const listItem = document.querySelector(`#coordinates-list .coordinate-item[data-click-id="${clickId}"]`);
        if (listItem) {
            listItem.classList.add('highlighted');
        }
    });
    dot.addEventListener('mouseleave', () => {
        const clickId = dot.dataset.id;
        if (!clickId)
            return;
        dot.classList.remove('highlighted');
        const listItem = document.querySelector(`#coordinates-list .coordinate-item[data-click-id="${clickId}"]`);
        if (listItem) {
            listItem.classList.remove('highlighted');
        }
    });
}
function handleDocumentMouseUp() {
    if (!draggedDot)
        return;
    const finalX = parseFloat(draggedDot.style.left || '0');
    const finalY = parseFloat(draggedDot.style.top || '0');
    const clickIdStr = draggedDot.dataset.id;
    if (!clickIdStr) {
        console.error("Dragged dot has no data-id for update:", draggedDot);
        draggedDot = null;
        return;
    }
    const clickId = parseInt(clickIdStr, 10);
    fetch('/update-click/', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
        body: JSON.stringify({ id: clickId, x: finalX, y: finalY })
    })
        .then(response => {
        if (!response.ok) {
            console.error('Position save failed after drag for dot ID:', clickId, response.statusText);
        }
        return response.json();
    })
        .then(data => {
        if (data.status !== 'success') {
            console.warn('Update click response status not success:', data);
        }
    })
        .catch(error => console.error('Error updating position after drag:', error));
    draggedDot = null;
}
function createDotOnImage(clickId, x, y) {
    const container = document.getElementById('image-container');
    if (!container) {
        console.error("Element with ID 'image-container' not found.");
        throw new Error("Image container not found, cannot create dot.");
    }
    const dot = document.createElement('div');
    dot.className = 'click-dot';
    dot.style.left = `${x}px`;
    dot.style.top = `${y}px`;
    dot.setAttribute('data-id', clickId.toString());
    dot.innerHTML = `<span class="dot-number"></span>
                    <button class="delete-dot-btn" title="Delete this point">âœ–</button>`;
    container.appendChild(dot);
    initializeDot(dot);
    return dot;
}
//# sourceMappingURL=functions.js.map

===== File: ./main/permissions.py =====
# permissions.py
from rest_framework import permissions

class IsOwner(permissions.BasePermission):
    def has_object_permission(self, request, view, obj):
        return obj.user == request.user 

===== File: ./main/forms.py =====
from django import forms
from .models import UserImage, CommonImage

class UserImageForm(forms.ModelForm):
    class Meta:
        model = UserImage
        fields = ['name', 'image']

class CommonImageUploadForm(forms.ModelForm): # New form
    class Meta:
        model = CommonImage
        fields = ['name', 'image', 'description']
        widgets = {
            'description': forms.Textarea(attrs={'rows': 3}),
        }
        help_texts = {
            'name': 'A unique name for this shared image.',
            'image': 'Select the image file.',
            'description': 'Optional: Briefly describe the image.'
        }

class DefineGridForm(forms.Form): # New form for grid definition
    name = forms.CharField(max_length=100, label="Grid Name", help_text="Name for this grid image.")
    columns = forms.IntegerField(min_value=1, max_value=50, initial=5, label="Columns (Vertical Lines)")
    rows = forms.IntegerField(min_value=1, max_value=50, initial=5, label="Rows (Horizontal Lines)")

===== File: ./main/admin.py =====
# main/admin.py
from django.contrib import admin
from .models import UserImage, ImageClick, CommonImage, GameBoard, Reaction # Dodaj Reaction


@admin.register(Reaction)
class ReactionAdmin(admin.ModelAdmin):
    list_display = ('user', 'reaction_type', 'content_object_display', 'timestamp')
    list_filter = ('reaction_type', 'content_type', 'timestamp')
    search_fields = ('user__username',)
    readonly_fields = ('content_object_display',) # Aby uniknÄ…Ä‡ problemÃ³w z GenericForeignKey w edycji

    def content_object_display(self, obj):
        return str(obj.content_object)
    content_object_display.short_description = 'Reacted To'

@admin.register(GameBoard)
class GameBoardAdmin(admin.ModelAdmin):
    list_display = ('name', 'user', 'rows', 'cols', 'get_dots_count', 'get_paths_count')
    list_filter = ('user', 'rows', 'cols')
    search_fields = ('name', 'user__username')
    readonly_fields = ('dots_config_pretty', 'paths_config_pretty') # If you have these methods

    fieldsets = (
        (None, {
            'fields': ('user', 'name', 'rows', 'cols')
        }),
        ('Configuration (Raw JSON - Edit with caution)', {
            'classes': ('collapse',),
            'fields': ('dots_config', 'paths_config'), # Ensure paths_config is here
        }),
        ('Configuration (Formatted View)', { # Assuming you have these helper methods
            'fields': ('dots_config_pretty', 'paths_config_pretty'),
        }),
    )

    def get_dots_count(self, obj):
        if isinstance(obj.dots_config, list):
            return len(obj.dots_config)
        return 0
    get_dots_count.short_description = 'Dots Count'

    def get_paths_count(self, obj):
        if isinstance(obj.paths_config, list): # Check the new paths_config field
            return len(obj.paths_config)
        return 0
    get_paths_count.short_description = 'Paths Count'

    def dots_config_pretty(self, obj):
        import json
        from django.utils.html import format_html
        formatted_json = json.dumps(obj.dots_config, indent=4)
        return format_html("<pre>{}</pre>", formatted_json)
    dots_config_pretty.short_description = 'Dots Config (Formatted)'

    def paths_config_pretty(self, obj):
        import json
        from django.utils.html import format_html
        formatted_json = json.dumps(obj.paths_config, indent=4)
        return format_html("<pre>{}</pre>", formatted_json)
    paths_config_pretty.short_description = 'Paths Config (Formatted)'


@admin.register(UserImage) # Use the decorator for cleaner registration
class UserImageAdmin(admin.ModelAdmin):
    list_display = ('name', 'user', 'image_thumbnail') # Added thumbnail for better display
    list_filter = ('user',)
    search_fields = ('name', 'user__username')
    readonly_fields = ('image_preview',) # For a larger preview in the detail view

    def image_thumbnail(self, obj):
        from django.utils.html import format_html
        if obj.image:
            return format_html('<img src="{}" style="width: 45px; height:45px; object-fit:cover;" />', obj.image.url)
        return "No Image"
    image_thumbnail.short_description = 'Thumbnail'

    def image_preview(self, obj):
        from django.utils.html import format_html
        if obj.image:
            return format_html('<img src="{}" style="max-width: 200px; max-height:200px;" />', obj.image.url)
        return "No Image"
    image_preview.short_description = 'Image Preview'


# --- ImageClick Admin (Optional: can be an inline in UserImageAdmin) ---
@admin.register(ImageClick)
class ImageClickAdmin(admin.ModelAdmin):
    list_display = ('id', 'user', 'image_name', 'x', 'y')
    list_filter = ('user', 'image')
    search_fields = ('image__name', 'user__username')

    def image_name(self, obj):
        return obj.image.name
    image_name.short_description = 'On Image'
    image_name.admin_order_field = 'image__name'


# --- CommonImage Admin ---
@admin.register(CommonImage)
class CommonImageAdmin(admin.ModelAdmin):
    list_display = ('name', 'image_thumbnail', 'description')
    search_fields = ('name', 'description')
    readonly_fields = ('image_preview',)

    def image_thumbnail(self, obj):
        from django.utils.html import format_html
        if obj.image:
            return format_html('<img src="{}" style="width: 45px; height:45px; object-fit:cover;" />', obj.image.url)
        return "No Image"
    image_thumbnail.short_description = 'Thumbnail'

    def image_preview(self, obj):
        from django.utils.html import format_html
        if obj.image:
            return format_html('<img src="{}" style="max-width: 200px; max-height:200px;" />', obj.image.url)
        return "No Image"
    image_preview.short_description = 'Image Preview'

===== File: ./main/signals.py =====
# main/signals.py
from django.db.models.signals import post_save
from django.dispatch import receiver
from .models import GameBoard, UserImage, ImageClick
from .event_queue import broadcast_event

@receiver(post_save, sender=GameBoard)
def game_board_saved_handler(sender, instance: GameBoard, created: bool, **kwargs):
    print(f"SIGNAL [game_board_saved_handler]: Fired for GameBoard ID {instance.id}. CREATED: {created}")
    if created:
        try:
            creator_username = instance.user.username
        except AttributeError:
            creator_username = "UnknownUser"
            print(f"SIGNAL [game_board_saved_handler]: Warning - User or username not found for GameBoard ID {instance.id}")

        print(f"SIGNAL [game_board_saved_handler]: New GameBoard - ID: {instance.id}, Name: {instance.name}")
        event_data = {
            "board_id": instance.id,
            "board_name": instance.name,
            "creator_username": creator_username
        }
        broadcast_event(event_type="newBoard", data=event_data)
    else:
        print(f"SIGNAL [game_board_saved_handler]: GameBoard ID {instance.id} updated, not new. No 'newBoard' SSE event.")

@receiver(post_save, sender=UserImage)
def user_image_saved_handler(sender, instance: UserImage, created: bool, **kwargs): # Zmieniona nazwa handlera dla jasnoÅ›ci
    """
    WysyÅ‚a zdarzenie 'newPath' GDY UserImage jest tworzony LUB aktualizowany.
    JeÅ›li jest tworzony, to jest to nowy obrazek do rysowania Å›cieÅ¼ek.
    JeÅ›li jest aktualizowany, zakÅ‚adamy, Å¼e konfiguracja Å›cieÅ¼ek mogÅ‚a siÄ™ zmieniÄ‡.
    """
    print(f"SIGNAL [user_image_saved_handler]: Fired for UserImage ID {instance.id}. CREATED: {created}")
    
    try:
        user_username = instance.user.username
    except AttributeError:
        user_username = "UnknownUser"
        print(f"SIGNAL [user_image_saved_handler]: Warning - User for UserImage ID {instance.id} not found.")

    action_type = "created" if created else "updated"
    print(f"SIGNAL [user_image_saved_handler]: UserImage {action_type} - ID: {instance.id}, Name: {instance.name}. Sending 'newPath' event.")
    
    event_data = {
        "path_id": None,  # Dla ogÃ³lnego zdarzenia UserImage, nie mamy konkretnego ID Å›cieÅ¼ki
        "board_id": instance.id, # ID UserImage traktujemy jako ID planszy
        "board_name": instance.name,
        "user_username": user_username, # UÅ¼ytkownik, ktÃ³ry jest wÅ‚aÅ›cicielem/modyfikowaÅ‚
        "action": action_type # Dodatkowa informacja dla frontendu, czy obraz zostaÅ‚ utworzony czy zaktualizowany
    }
    broadcast_event(event_type="newPath", data=event_data)


@receiver(post_save, sender=ImageClick)
def image_click_created_handler(sender, instance: ImageClick, created: bool, **kwargs):
    """
    WysyÅ‚a zdarzenie 'newPath' GDY tworzony jest NOWY ImageClick.
    """
    print(f"SIGNAL [image_click_created_handler]: Fired for ImageClick ID {instance.id}. CREATED: {created}")
    if created: # Tylko przy tworzeniu nowego punktu
        try:
            user_username = instance.user.username
        except AttributeError:
            user_username = "UnknownUser"
            print(f"SIGNAL [image_click_created_handler]: Warning - User for ImageClick ID {instance.id} not found.")
        
        try:
            image_id = instance.image.id
            image_name = instance.image.name
        except AttributeError:
            image_id = None
            image_name = "UnknownImage"
            print(f"SIGNAL [image_click_created_handler]: Warning - Image for ImageClick ID {instance.id} not found.")

        print(f"SIGNAL [image_click_created_handler]: New ImageClick created - ID: {instance.id} on Image ID {image_id}. Sending 'newPath' event.")
        event_data = {
            "path_id": instance.id,
            "board_id": image_id,
            "board_name": image_name,
            "user_username": user_username,
            "action": "point_added" # Specyficzna akcja dla dodania punktu
        }
        broadcast_event(event_type="newPath", data=event_data)

===== File: ./main/models.py =====
from django.db import models
from django.contrib.auth.models import User
import uuid
from django.conf import settings
from django.db.models.signals import post_save
from django.dispatch import receiver
from rest_framework.authtoken.models import Token
from django.core.exceptions import ValidationError
from django.contrib.auth.models import User
from django.contrib.contenttypes.fields import GenericForeignKey
from django.contrib.contenttypes.models import ContentType

class Reaction(models.Model):
    REACTION_CHOICES = [
        ('heart', 'â¤ï¸'),
        ('gasp', 'ðŸ˜®'),
        ('grin', 'ðŸ˜„'),
    ]

    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name="reactions")
    reaction_type = models.CharField(max_length=10, choices=REACTION_CHOICES)
    timestamp = models.DateTimeField(auto_now_add=True)

    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)
    object_id = models.PositiveIntegerField()
    content_object = GenericForeignKey('content_type', 'object_id') # Obiekt, na ktÃ³ry jest reakcja

    class Meta:
        ordering = ['-timestamp']
        unique_together = ('user', 'content_type', 'object_id') # UÅ¼ytkownik moÅ¼e mieÄ‡ tylko jednÄ… reakcjÄ™ na dany obiekt

    def __str__(self):
        return f"{self.user.username} reacted with {self.get_reaction_type_display()} to {self.content_object}"
    
class UserImage(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='images')
    name = models.CharField(max_length=100, unique=True)
    image = models.ImageField(upload_to='uploads/%Y/%m/%d/')

    def save(self, *args, **kwargs):
        if not self.name:
            self.name = f"{self.user.id}_{uuid.uuid4().hex}"

        super().save(*args, **kwargs)

    def __str__(self):
        return self.name
    
class ImageClick(models.Model):
    image = models.ForeignKey(UserImage, on_delete=models.CASCADE, related_name='clicks')
    user = models.ForeignKey(User, on_delete=models.CASCADE, default=1)
    x = models.FloatField()
    y = models.FloatField()

    def __str__(self):
        return f"Click on {self.image.name} by {self.user} at ({self.x}, {self.y})"

class CommonImage(models.Model):
    name = models.CharField(max_length=100, unique=True, help_text="Descriptive name for the common image.")
    image = models.ImageField(upload_to='common_images/%Y/%m/%d/', help_text="The actual image file.")
    description = models.TextField(blank=True, null=True, help_text="Optional description.")
    def __str__(self):
        return self.name

    class Meta:
        ordering = ['name']
        verbose_name = "Common Image"
    

@receiver(post_save, sender=settings.AUTH_USER_MODEL)
def create_auth_token(sender, instance=None, created=False, **kwargs):
    if created:
        Token.objects.create(user=instance)

class GameBoard(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='game_boards')
    name = models.CharField(max_length=100, default="Untitled Board")
    rows = models.PositiveIntegerField()
    cols = models.PositiveIntegerField()
    dots_config = models.JSONField(default=list, blank=True)

    def __str__(self):
        return f"{self.name} ({self.rows}x{self.cols}) by {self.user.username}"

    def clean(self):
        super().clean()
        if not (1 < self.rows <= 50): # Example limits
            raise ValidationError({'rows': 'Rows must be between 2 and 50.'})
        if not (1 < self.cols <= 50): # Example limits
            raise ValidationError({'cols': 'Columns must be between 2 and 50.'})

        if self.dots_config:
            if not isinstance(self.dots_config, list):
                raise ValidationError({'dots_config': 'Dots configuration must be a list.'})

            dot_colors_count = {}
            occupied_cells = set()

            for dot in self.dots_config:
                if not all(k in dot for k in ['row', 'col', 'color']):
                    raise ValidationError({'dots_config': 'Each dot must have row, col, and color.'})
                if not (0 <= dot['row'] < self.rows and 0 <= dot['col'] < self.cols):
                    raise ValidationError({'dots_config': f"Dot at ({dot['row']},{dot['col']}) is out of bounds."})

                cell = (dot['row'], dot['col'])
                if cell in occupied_cells:
                    raise ValidationError({'dots_config': f"Cell ({dot['row']},{dot['col']}) is occupied by more than one dot."})
                occupied_cells.add(cell)

                dot_colors_count[dot['color']] = dot_colors_count.get(dot['color'], 0) + 1

            for color, count in dot_colors_count.items():
                if count != 2:
                    raise ValidationError({'dots_config': f"Color {color} must be used for exactly two dots. Found {count}."})

    def save(self, *args, **kwargs):
        self.full_clean() # Call clean() before saving
        super().save(*args, **kwargs)


===== File: ./main/templates/rest_framework/api.html =====
{% extends "rest_framework/base.html" %}  {# extend DRFâ€™s base layout #}
{% load i18n %}                            {# for translating strings #}

{# Optionally override the Bootstrap theme â€“ you can point this to your own CSS if you like #}
{% block bootstrap_theme %}
  <link
    rel="stylesheet"
    href="https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css"
    integrity="sha384-7nHVqZgEfT1Z2YKzy+YBmfmhgcKs4JXQgnauVpD6vSBOVTY7TsIseQ3C6E+
    Ai5oX" crossorigin="anonymous"
  >
{% endblock %}

{# You can override other blocks here (e.g. navbar, branding) if you need to customize the header #}

{# Finally, render the standard browsable API content #}
{% block content %}
  {{ block.super }}
{% endblock %}


===== File: ./main/templates/registration/login.html =====
{% extends "game_board/base.html" %}

{% block title %}Login{% endblock %}

{% block content %}
  <h2>Login</h2>
  {% if form.errors %}
    <p style="color: red;">Your username and password didn't match. Please try again.</p>
  {% endif %}

  {% if next %}
    {% if user.is_authenticated %}
      <p>Your account doesn't have access to this page. To proceed,
      please login with an account that has access.</p>
    {% else %}
      <p>Please login to see this page.</p>
    {% endif %}
  {% endif %}

  <form method="post" action="{% url 'login' %}">
    {% csrf_token %}
    <table>
      <tr>
        <td>{{ form.username.label_tag }}</td>
        <td>{{ form.username }}</td>
      </tr>
      <tr>
        <td>{{ form.password.label_tag }}</td>
        <td>{{ form.password }}</td>
      </tr>
    </table>
    <input type="submit" value="Login" class="button">
    <input type="hidden" name="next" value="{{ next }}">
  </form>

  <p>Don't have an account? <a href="{% url 'register' %}">Sign up here</a>.</p> {# <-- ADD THIS LINE #}

{% endblock %}

===== File: ./main/templates/registration/register.html =====
{% extends "game_board/base.html" %} {# Or your project's main base template #}

{% block title %}Sign Up{% endblock %}

{% block content %}
  <h2>Sign Up</h2>
  <form method="post">
    {% csrf_token %}
    {{ form.as_p }} {# This will render the form fields as paragraphs #}
    <button type="submit" class="button">Sign Up</button>
  </form>
  <p>Already have an account? <a href="{% url 'login' %}">Login here</a>.</p>
{% endblock %}

===== File: ./main/templates/game_board/board_list.html =====
{% extends "main/base.html" %}
{% load static %} {# Good practice to include if you might add static files to this template later #}

{% block title %}My Connect-Dots Boards{% endblock %}

{% block head_extra %}
 
{% endblock %}

{% block content %}
    <h2>My Connect-Dots Boards</h2>
    <a href="{% url 'game_board:board_create' %}">Create New Board</a>
    <hr style="margin-bottom: 20px;">

    {% if boards %}
        <ul class="board-list">
            {% for board in boards %}
            <li class="board-item">
                <h3>{{ board.name }}</h3>
                <p>Dimensions: {{ board.rows }} rows Ã— {{ board.cols }} columns</p>
                <p>Dot Pairs: ({{ board.dots_config|length }} dots total)</p>
                {# You could add a small visual preview of the board here if desired #}
                <a href="{% url 'game_board:board_edit' board.id %}">View</a>
                <form action="{% url 'game_board:board_delete' board.id %}" method="post" style="display: inline;" onsubmit="return confirm('Are you sure you want to delete the board \'{{ board.name|escapejs }}\'?');">
                    {% csrf_token %}
                    <button type="submit">Delete</button>
                </form>
            </li>
            {% endfor %}
        </ul>
    {% else %}
        <p class="no-boards-message">You haven't created any Connect-Dots boards yet. <a href="{% url 'game_board:board_create' %}">Create one now!</a></p>
    {% endif %}
{% endblock %}

{% block extra_js %}
<script src="{% static 'main/ts/dist/grid.js' %}"></script>
{% endblock %}



===== File: ./main/templates/game_board/board_editor.html =====
{% extends "main/base.html" %}
{% load static %}

{% block title %}{% if board_instance %}Edit {{ board_instance.name }}{% else %}Create New Board{% endif %}{% endblock %}

{% block head_extra %}
<style>
    #grid-container {
        display: grid;
        border: 1px solid #ccc;
        margin-bottom: 20px;
        user-select: none;
    }
    .grid-cell {
        border: 1px solid #eee;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        transition: background-color 0.2s;
    }
    .grid-cell:hover {
        background-color: #f0f0f0;
    }
    .grid-cell .dot-visual {
        width: 70%;
        height: 70%;
        border-radius: 50%;
        box-shadow: inset 0 0 3px rgba(0,0,0,0.3);
    }
    #color-palette { margin-bottom: 15px; }
    .color-button {
        width: 30px; height: 30px; border: 2px solid #fff;
        margin-right: 5px; cursor: pointer; display: inline-block;
        border-radius: 50%;
    }
    .color-button.selected {
        border-color: #000;
        box-shadow: 0 0 5px #000;
    }
    #messages { margin-top: 10px; }
    .success { color: green; }
    .error { color: red; }
</style>
{% endblock %}

{% block content %}
<h1>{% if board_instance %}Edit Board: <span id="board-title-display">{{ board_instance.name }}</span>{% else %}Create New Board{% endif %}</h1>

{% csrf_token %}
<input type="hidden" id="boardId" value="{{ board_instance.id | default:'' }}">
<script id="initial-board-data" type="application/json">
    {{ initial_board_data_json | safe }}
</script>

<div class="form-group">
    <label for="boardName">Board Name:</label>
    <input type="text" id="boardName" value="{{ board_instance.name | default:'My New Board' }}">
</div>

<div class="form-group">
    <label for="numRows">Rows:</label>
    <input type="number" id="numRows" value="{{ board_instance.rows | default:5 }}" min="2" max="50">
</div>

<div class="form-group">
    <label for="numCols">Columns:</label>
    <input type="number" id="numCols" value="{{ board_instance.cols | default:5 }}" min="2" max="50">
</div>

<button id="generateGridButton" class="button">Generate/Update Grid</button>
<hr>

<h3>Select Color & Place Dots:</h3>
<div id="color-palette">
</div>
<p>Selected Color: <span id="selected-color-display">None</span></p>
<p>Instructions: Select a color, then click two empty cells to place a pair of dots. Click an existing dot of the selected color to remove it.</p>

<div id="grid-container">
</div>


<button id="saveBoardButton" class="button">Save Board</button>
<button id="saveAsImageButton" class="button" >Save as Path Background</button>
<div id="messages"></div>

{% endblock %}

{% block extra_js %}
<script src="{% static 'main/ts/dist/grid.js' %}"></script>
{% endblock %}

===== File: ./main/templates/game_board/base.html =====
{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}Connect The Dots Board Editor{% endblock %}</title>
    <!-- Simple styling, replace with Bootstrap or your preferred CSS framework -->
    <style>
        body { font-family: sans-serif; margin: 20px; background-color: #f4f4f4; }
        nav { margin-bottom: 20px; background-color: #333; padding: 10px; border-radius: 5px; }
        nav a { color: white; margin-right: 15px; text-decoration: none; }
        nav a:hover { text-decoration: underline; }
        .container { background-color: white; padding: 20px; border-radius: 5px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        h1, h2 { color: #333; }
        table { width: 100%; border-collapse: collapse; margin-bottom: 20px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f0f0f0; }
        .button, button {
            background-color: #007bff; color: white; padding: 10px 15px;
            border: none; border-radius: 4px; cursor: pointer; text-decoration: none;
            font-size: 1em; margin-right: 5px;
        }
        .button:hover, button:hover { background-color: #0056b3; }
        .button-danger { background-color: #dc3545; }
        .button-danger:hover { background-color: #c82333; }
        .form-group { margin-bottom: 15px; }
        .form-group label { display: block; margin-bottom: 5px; }
        .form-group input[type="text"], .form-group input[type="number"] {
            width: calc(100% - 22px); padding: 10px; border: 1px solid #ccc; border-radius: 4px;
        }
        .error-message { color: red; font-size: 0.9em; }
    </style>
    {% block head_extra %}{% endblock %}
</head>
<body>
    <nav>
        <a href="{% url 'game_board:board_list' %}">My Boards</a>
        <a href="{% url 'game_board:board_create' %}">Create New Board</a>
        {% if user.is_authenticated %}
            <span>Welcome, {{ user.username }}!</span>
            <a href="{% url 'logout' %}" style="float:right;">Logout</a>
        {% else %}
            <a href="{% url 'login' %}" style="float:right;">Login</a>
        {% endif %}
    </nav>
    <div class="container">
        {% block content %}{% endblock %}
    </div>
    {% block scripts_extra %}{% endblock %}
</body>
</html>

===== File: ./main/templates/main/login.html =====
{% extends "main/base.html" %}
{% load static %}

{% block title %}Login{% endblock title %}

{% block content %}
    <h2>Login</h2>
    <form method="post" action="{% url 'login' %}">
        {% csrf_token %}
        {{ form.as_p }}
        <button type="submit">Login</button>
    </form>
    <p>Don't have an account? <a href="{% url 'register' %}">Register here</a></p>
{% endblock content %}

===== File: ./main/templates/main/upload_common_image.html =====
{% extends "main/base.html" %}
{% load static %}

{% block title %}Upload a Common Path{% endblock title %}

{% block content %}
    <h2>Upload an Path to the Common Library</h2>
    <p>This path will be available for other users to use.</p>
    <form method="POST" enctype="multipart/form-data" action="{% url 'upload_common_image' %}">
        {% csrf_token %}
        {{ form.as_p }}
        <button type="submit">Upload Common Image</button>
    </form>
    <br>
    <a href="{% url 'home' %}">Back to Home</a>
{% endblock content %}

===== File: ./main/templates/main/upload_image.html =====
{% extends "main/base.html" %}
{% load static %}

{% block title %}Upload Path{% endblock title %}

{% block content %}
    <h2>Upload a new path</h2>
    <form method="POST" enctype="multipart/form-data" action="{% url 'upload_image' %}">
        {% csrf_token %}
        {{ form.as_p }}
        <button type="submit">Upload</button>
    </form>
{% endblock content %}

===== File: ./main/templates/main/user_panel.html =====
{% extends "main/base.html" %}
{% load static %}

{% block title %}User Panel - {{ user.username }}{% endblock title %}

{% block content %}
    <h2>Login: {{ user.username }}</h2>

    <h3>Your Personal Paths</h3>
    {% if images %}
    <ul>
        {% for image_obj in images %}
        <li>
            <p>{{ image_obj.name }}</p>
            <img src="{{ image_obj.image.url }}" alt="{{ image_obj.name }}" width="100" height="100">
            <form action="{% url 'user_panel' %}" method="post" style="display: inline-block; margin-right: 10px;">
                {% csrf_token %}
                <input type="hidden" name="image_id_for_rename" value="{{ image_obj.id }}">
                <input type="text" name="name" value="{{ image_obj.name }}" placeholder="New name" required>
                <button type="submit" name="action" value="rename_image">Rename</button>
            </form>
            <a href="{% url 'delete_image' image_obj.id %}" onclick="return confirm('Are you sure you want to delete this image and its points?');" style="display: inline-block;">Delete</a>
        </li>
        {% endfor %}
    </ul>
    {% else %}
    <p>You have not uploaded any paths yet. <a href="{% url 'upload_image' %}">Upload one now.</a></p>
    {% endif %}

    <hr>
    <h3>Upload New Path from Panel</h3>
    <form method="POST" enctype="multipart/form-data" action="{% url 'user_panel' %}">
        {% csrf_token %}
        {{ upload_form.as_p }} {# Assuming you pass 'upload_form' from the view for new uploads #}
        <button type="submit" name="action" value="upload_new_image">Upload New Path</button>
    </form>
    <hr>

    <h3>Change Your Password</h3>
    <form method="post" action="{% url 'change_password' %}">
        {% csrf_token %}
        {{ password_form.as_p }}
        <button type="submit">Change Password</button>
    </form>
{% endblock content %}

===== File: ./main/templates/main/define_grid.html =====
{% extends "main/base.html" %}
{% load static %}

{% block title %}Define New Grid Image{% endblock title %}

{% block content %}
    <h2>Define Your Grid Image</h2>
    <p>Specify the dimensions for your grid. An image representing this grid will be generated and added to your personal images.</p>
    <form method="post" action="{% url 'define_grid' %}">
        {% csrf_token %}
        {{ form.as_p }}
        <button type="submit">Create Grid Image</button>
    </form>
    <br>
    <a href="{% url 'home' %}">Back to Home</a>
{% endblock content %}

===== File: ./main/templates/main/base.html =====
{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}Path Editor{% endblock title %}</title>
    <link rel="stylesheet" href="{% static 'main/css/style.css' %}"> {# Assuming your main CSS is here #}
    {% block extra_css %}{% endblock extra_css %}
    {% block head_extra %}{% endblock head_extra %}
</head>
<body>
    <div id="toast-container"></div>
    <nav>
        <a href="{% url 'home' %}">Home</a>
        {% if user.is_authenticated %}
            <a href="{% url 'user_panel' %}">My Paths</a>
            <a href="{% url 'upload_image' %}">Upload Personal Path</a>
            <a href="{% url 'upload_common_image' %}">Upload Common Path</a>
            <a href="{% url 'game_board:board_list' %}">My Boards</a>
            <a href="{% url 'game_board:board_create' %}">Create New Board</a>
            <a href="{% url 'logout' %}" style="float:right;">Logout </a>
        {% else %}
            <a href="{% url 'login' %}">Login</a>
            {% if not on_register_page %} {# Assuming you have a context variable 'on_register_page' #}
                <a href="{% url 'register' %}">Register</a>
            {% endif %}
        {% endif %}
    </nav>
    <hr>
    <main>
        {% block content %}
        {% endblock content %}
    </main>
    {% block extra_js %}
    {% endblock extra_js %}
    {% if user.is_authenticated %} {# Inicjuj SSE tylko dla zalogowanych uÅ¼ytkownikÃ³w #}
        <script src="{% static 'main/ts/dist/sseNotifications.js' %}"></script> 
    {% endif %}
</body>
</html>

===== File: ./main/templates/main/home.html =====
{% extends "main/base.html" %}
{% load static %}

{% block title %}Home - Image Path Editor{% endblock title %}

{% block content %}
    <h2>Welcome, {{ user.username }}!</h2>

    {# --- IMAGE SELECTION SECTION --- #}
    {% if not selected_image %}
        <form method="get" action="{% url 'home' %}">
            <label for="image-select">Personal paths:</label>
            <select name="selected" id="image-select" onchange="this.form.submit()">
                <option value="">-- choose an image --</option>
                {% for img in user_images %}
                    <option value="{{ img.name }}">
                        {{ img.name }} (Yours)
                    </option>
                {% endfor %}
            </select>
        </form>
        <a href="{% url 'upload_image' %}">Upload a new personal image</a>

        <hr>
        <h3>Or Use a Common Image:</h3>
        {% if common_images_list %}
            <div class="common-images-grid" style="display: flex; flex-wrap: wrap; gap: 10px;">
                {% for c_img in common_images_list %}
                    <div class="common-image-item" style="border: 1px solid #ccc; padding: 5px; text-align: center;">
                        <p>{{ c_img.name }}</p>
                        {% if c_img.image %}
                        <img src="{{ c_img.image.url }}" alt="{{ c_img.name }}" width="100" height="100" style="object-fit: cover;">
                        <br>
                        <a href="{% url 'use_common_image' c_img.id %}">Use this image</a>
                        {% else %}
                        <p>Image not available</p>
                        {% endif %}
                    </div>
                {% endfor %}
            </div>
        {% else %}
            <p>No common images available at the moment.</p>
        {% endif %}
        <hr>

    {% else %} {# An image IS selected, show the editor #}
        
        <p><a href="{% url 'home' %}">Select a different image</a></p> 
        
        <h3>Selected Path: {{ selected_image.name }}</h3>

        <div id="message-container" style="text-align: center; font-size: 16px; color: blue; display: none;"></div>
        
        <div id="editor-layout">
            <div id="image-option-containter">
                <button id="add-point-on-image-btn">Add Point on Image</button>
                <br>
                <div id="image-container">
                    <svg id="connection-lines" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></svg>
                    <img src="{{ selected_image.image.url }}" id="main-image" alt="{{ selected_image.name }}" />
                    {% for click in selected_image.clicks.all %}
                    <div class="click-dot"
                        data-id="{{ click.id }}"
                        style="left: {{ click.x }}px; top: {{ click.y }}px;">
                        <span class="dot-number"></span>
                        <button class="delete-dot-btn" title="Delete this point">âœ–</button>
                    </div>
                    {% endfor %}
                </div>
                <br>
                <a href="{% url 'delete_image' selected_image.id %}" onclick="return confirm('Are you sure you want to delete this image and all its points?');">Delete image</a>
            </div>

            <div id="coordinates-list-container">
                <button id="add-point-on-list-btn">Add New Point to List</button>
                <h4>Coordinates of Points:</h4>
                <ul id="coordinates-list">
                    {% for click in selected_image.clicks.all %}
                        <li data-click-id="{{ click.id }}" class="coordinate-item">
                            Point <span class="point-display-number">{{ forloop.counter }}</span>:
                            X<input type="number" class="coord-x-input" value="{{ click.x|floatformat:2 }}" step="1.00" autocomplete="off">
                            Y<input type="number" class="coord-y-input" value="{{ click.y|floatformat:2 }}" step="1.00" autocomplete="off">
                            <button class="update-coord-btn">Update</button>
                            <button class="delete-coord-btn">Delete</button>
                        </li>
                    {% endfor %}
                </ul>
            </div>
        </div>
        <br>
    {% endif %} {# End of 'if selected_image' / 'if not selected_image' logic #}

{% endblock content %}

{% block extra_js %}
    <script>
        const csrfToken = '{{ csrf_token }}';
        const selectedImageId = {{ selected_image.id|default_if_none:"null" }};
        // console.log("[HTML Init Script] selectedImageId:", selectedImageId); // For debugging

        let draggedDot = null;
        let addModeOnClick = false;
    </script>
    <script src="{% static 'main/js/functions.js' %}"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // console.log("[HTML DOMContentLoaded] Event fired. selectedImageId:", selectedImageId); // For debugging

            function initializeEditorComponents() {
                // console.log("[HTML initializeEditorComponents] Called."); // For debugging
                // This function assumes elements like #main-image are present.
                if (typeof initializePageElements === 'function') {
                    initializePageElements();
                } else {
                    console.error("initializePageElements is not defined. Check functions.js");
                }
                if (typeof initializeCoordinateListInteractions === 'function') {
                    initializeCoordinateListInteractions();
                } else {
                    console.error("initializeCoordinateListInteractions is not defined. Check functions.js");
                }
            }

            if (selectedImageId) { // If an image is selected, its HTML (including #main-image) should be rendered
                const mainImageElement = document.getElementById('main-image');
                if (mainImageElement) {
                    // console.log("[HTML DOMContentLoaded] main-image found."); // For debugging
                    if (mainImageElement.complete) {
                        // console.log("[HTML DOMContentLoaded] main-image already complete. Initializing editor."); // For debugging
                        initializeEditorComponents();
                    } else {
                        // console.log("[HTML DOMContentLoaded] main-image not complete. Adding load listener."); // For debugging
                        mainImageElement.addEventListener('load', () => {
                            // console.log("[HTML DOMContentLoaded] main-image LOAD event. Initializing editor."); // For debugging
                            initializeEditorComponents();
                        });
                    }
                } else {
                    // This case should ideally not happen if selectedImageId is true,
                    // as it implies the editor block in HTML wasn't rendered.
                    console.warn("[HTML DOMContentLoaded] selectedImageId is set, but #main-image not found.");
                }
            } else { // No image selected, editor part is not rendered
                // console.log("[HTML DOMContentLoaded] No selectedImageId. Editor components not initialized."); // For debugging
                const addPointOnImageBtn = document.getElementById('add-point-on-image-btn');
                const addPointToListBtn = document.getElementById('add-point-on-list-btn');
                if(addPointOnImageBtn) addPointOnImageBtn.disabled = true;
                if(addPointToListBtn) addPointToListBtn.disabled = true;
            }
            
            // Event listeners that should be active regardless of initial image selection,
            // but their internal logic might depend on editor elements existing.
            
            const addPointOnImageBtn = document.getElementById('add-point-on-image-btn');
            const messageContainer = document.getElementById('message-container');
            if (addPointOnImageBtn) {
                addPointOnImageBtn.addEventListener('click', () => {
                    addModeOnClick = !addModeOnClick;
                    const mainImgElem = document.getElementById('main-image'); // Needs to exist
                    if (addModeOnClick) {
                        addPointOnImageBtn.textContent = "Stop Adding on Image";
                        if(messageContainer) {
                            messageContainer.innerText = "Click anywhere on the image to place a new point.";
                            messageContainer.style.display = "block";
                        }
                        if(mainImgElem) mainImgElem.style.cursor = 'crosshair';
                    } else {
                        addPointOnImageBtn.textContent = "Add Point on Image";
                        if(messageContainer) messageContainer.style.display = "none";
                        if(mainImgElem) mainImgElem.style.cursor = 'default';
                    }
                });
            }

            const mainImageEventTarget = document.getElementById('main-image'); // Get target for click
            if (mainImageEventTarget) {
                mainImageEventTarget.addEventListener('click', function (e) {
                    if (!addModeOnClick || !selectedImageId) return;
                    const rect = e.target.getBoundingClientRect();
                    const x = parseFloat((e.clientX - rect.left).toFixed(2));
                    const y = parseFloat((e.clientY - rect.top).toFixed(2));
                    fetch('/add-click/', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
                        body: JSON.stringify({ image_id: selectedImageId, x: x, y: y })
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            if (typeof createDotOnImage === 'function' && 
                                typeof createCoordinateListItem === 'function' &&
                                typeof renumberDotsAndListItems === 'function') {
                                createDotOnImage(data.click_id, x, y);
                                createCoordinateListItem(data.click_id, x, y, false);
                                renumberDotsAndListItems();
                            } else {
                                console.error("One or more functions (createDotOnImage, createCoordinateListItem, renumberDotsAndListItems) are not defined.");
                            }
                        } else {
                            console.error("Failed to add click via image click", data);
                        }
                    });
                });
            }
            
            document.addEventListener("mousemove", (e) => {
                if (!draggedDot) return;
                const mainImageForMove = document.getElementById('main-image');
                if (!mainImageForMove) return; 
                
                const imageRect = mainImageForMove.getBoundingClientRect();
                let newLeft = e.clientX - imageRect.left;
                let newTop = e.clientY - imageRect.top;

                const boundaryMaxLeft = mainImageForMove.width;
                const boundaryMinLeft = 0;
                const boundaryMaxTop = mainImageForMove.height;
                const boundaryMinTop = 0;
                
                // Keep entire dot within image boundaries
                newLeft = Math.max(boundaryMinLeft, Math.min(newLeft, boundaryMaxLeft));
                newTop = Math.max(boundaryMinTop, Math.min(newTop, boundaryMaxTop));   

                draggedDot.style.left = newLeft + "px";
                draggedDot.style.top = newTop + "px";

                if (typeof redrawLines === 'function') {
                    redrawLines();
                } else {
                    console.error("redrawLines is not defined.");
                }

                const clickId = draggedDot.dataset.id;
                const listItem = document.querySelector(`#coordinates-list .coordinate-item[data-click-id="${clickId}"]`);
                if (listItem) {
                    listItem.querySelector('.coord-x-input').value = parseFloat(newLeft).toFixed(2);
                    listItem.querySelector('.coord-y-input').value = parseFloat(newTop).toFixed(2);
                }
            });

        }); // End of DOMContentLoaded
    </script>
{% endblock extra_js %}

===== File: ./main/templates/main/register.html =====
{% extends "main/base.html" %}
{% load static %}

{% block title %}Register{% endblock title %}

{% block content %}
    <h2>Register</h2>
    <form method="post" action="{% url 'register' %}">
        {% csrf_token %}
        {{ form.as_p }}
        <button type="submit">Register</button>
    </form>
    <p>Already have an account? <a href="{% url 'login' %}">Login here</a></p>
{% endblock content %}

===== File: ./main/tests.py =====
import os
import uuid
from io import BytesIO
from PIL import Image as PILImage
from django.test import TestCase
from django.urls import reverse
from django.contrib.auth.models import User
from django.core.files.uploadedfile import SimpleUploadedFile
from django.conf import settings
from rest_framework.test import APIClient
from rest_framework import status
from rest_framework.authtoken.models import Token
from .models import UserImage, ImageClick

def create_test_image_file(name="test_image.png", ext="png", size=(50, 50), color="red"):
    file_obj = BytesIO()
    image = PILImage.new("RGB", size=size, color=color)
    image.save(file_obj, format=ext.upper())
    file_obj.seek(0)
    return SimpleUploadedFile(name, file_obj.read(), content_type=f"image/{ext}")

class BaseSetupTestCase(TestCase):
    @classmethod
    def setUpTestData(cls):
        cls.user1_data = {'username': 'user1', 'password': 'password123'}
        cls.user1 = User.objects.create_user(**cls.user1_data)
        cls.user2_data = {'username': 'user2', 'password': 'password456'}
        cls.user2 = User.objects.create_user(**cls.user2_data)
        cls.image_u1 = UserImage.objects.create(
            user=cls.user1,
            name="image_user1",
            image=create_test_image_file("img_u1.png")
        )
        cls.image_u2 = UserImage.objects.create(
            user=cls.user2,
            name="image_user2",
            image=create_test_image_file("img_u2.png")
        )
        cls.click_u1_img_u1 = ImageClick.objects.create(
            image=cls.image_u1,
            user=cls.user1,
            x=10.0,
            y=20.0
        )

    def setUp(self):
        self.client = APIClient()

    @classmethod
    def tearDownClass(cls):
        for img_obj in UserImage.objects.all():
            if img_obj.image and hasattr(img_obj.image, 'path'):
                if os.path.exists(img_obj.image.path):
                    try:
                        os.remove(img_obj.image.path)
                        img_dir = os.path.dirname(img_obj.image.path)
                        if not os.listdir(img_dir):
                            os.rmdir(img_dir)
                            month_dir = os.path.dirname(img_dir)
                            if not os.listdir(month_dir):
                                os.rmdir(month_dir)
                                year_dir = os.path.dirname(month_dir)
                                if not os.listdir(year_dir):
                                    os.rmdir(year_dir)
                    except OSError:
                        pass
        super().tearDownClass()

class ModelTests(BaseSetupTestCase):

    def test_userimage_creation(self):
        self.assertEqual(self.image_u1.user, self.user1)
        self.assertEqual(self.image_u1.name, "image_user1")
        self.assertTrue(self.image_u1.image.name.startswith('uploads/'))
        self.assertEqual(str(self.image_u1), "image_user1")

    def test_imageclick_creation(self):
        self.assertEqual(self.click_u1_img_u1.image, self.image_u1)
        self.assertEqual(self.click_u1_img_u1.user, self.user1)
        self.assertEqual(self.click_u1_img_u1.x, 10.0)
        self.assertEqual(str(self.click_u1_img_u1), f"Click on {self.image_u1.name} by {self.user1.username} at (10.0, 20.0)")

    def test_user_image_relation(self):
        self.assertIn(self.image_u1, self.user1.images.all())

    def test_image_click_relation(self):
        self.assertIn(self.click_u1_img_u1, self.image_u1.clicks.all())

class WebAuthTests(BaseSetupTestCase):

    def test_home_page_requires_login(self):
        response = self.client.get(reverse('home'))
        self.assertEqual(response.status_code, status.HTTP_302_FOUND)
        self.assertIn(reverse('login'), response.url)

    def test_user_login_and_logout(self):
        login_response = self.client.post(reverse('login'), self.user1_data)
        self.assertEqual(login_response.status_code, status.HTTP_302_FOUND)
        self.assertEqual(login_response.url, '/')
            
        home_response = self.client.get(reverse('home'))
        self.assertEqual(home_response.status_code, status.HTTP_200_OK)
        self.assertContains(home_response, self.user1.username)
        logout_response = self.client.get(reverse('logout'))
        self.assertEqual(logout_response.status_code, status.HTTP_302_FOUND)
        self.assertIn(reverse(settings.LOGOUT_REDIRECT_URL.strip('/')), logout_response.url)
        home_response_after_logout = self.client.get(reverse('home'))
        self.assertEqual(home_response_after_logout.status_code, status.HTTP_302_FOUND)

    def test_user_sees_only_own_images_on_home(self):
        self.client.login(username=self.user1_data['username'], password=self.user1_data['password'])
        response = self.client.get(reverse('home'))
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertContains(response, self.image_u1.name)
        self.assertNotContains(response, self.image_u2.name)

    def test_user_cannot_delete_others_image_via_web(self):
        self.client.login(username=self.user1_data['username'], password=self.user1_data['password'])
        delete_url = reverse('delete_image', args=[self.image_u2.id])
        response = self.client.post(delete_url)
        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)
        self.assertTrue(UserImage.objects.filter(id=self.image_u2.id).exists())

class WebCRUDTests(BaseSetupTestCase):

    def setUp(self):
        super().setUp()
        self.client.login(username=self.user1_data['username'], password=self.user1_data['password'])

    def test_upload_new_image(self):
        initial_image_count = UserImage.objects.filter(user=self.user1).count()
        base_file_name = "web_upload"
        image_file = create_test_image_file(f"{base_file_name}.jpg", ext="jpeg")
        data = {
            'name': 'My Web Uploaded Image',
            'image': image_file
        }
        response = self.client.post(reverse('upload_image'), data, format='multipart')
        self.assertEqual(response.status_code, status.HTTP_302_FOUND)
        self.assertEqual(response.url, reverse('home'))
        self.assertEqual(UserImage.objects.filter(user=self.user1).count(), initial_image_count + 1)
        new_image = UserImage.objects.get(user=self.user1, name='My Web Uploaded Image')
        self.assertIn(base_file_name, new_image.image.name)
        self.assertTrue(new_image.image.name.lower().endswith(".jpg"))
    

    def test_add_click_via_ajax(self):
        initial_click_count = ImageClick.objects.filter(image=self.image_u1, user=self.user1).count()
        click_data = {
            'image_id': self.image_u1.id,
            'x': 30.5,
            'y': 40.5
        }
        response = self.client.post(reverse('add_click'), click_data, format='json')
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        response_data = response.json()
        self.assertTrue(response_data['success'])
        self.assertIn('click_id', response_data)
        self.assertEqual(ImageClick.objects.filter(image=self.image_u1, user=self.user1).count(), initial_click_count + 1)
        new_click = ImageClick.objects.get(id=response_data['click_id'])
        self.assertEqual(new_click.x, 30.5)

    def test_delete_click_via_ajax(self):
        self.assertTrue(ImageClick.objects.filter(id=self.click_u1_img_u1.id).exists())
        click_id_to_delete = self.click_u1_img_u1.id
        
        delete_data = {'id': click_id_to_delete}
        response = self.client.post(reverse('delete_click'), delete_data, format='json')
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.json()['status'], 'deleted')
        self.assertFalse(ImageClick.objects.filter(id=click_id_to_delete).exists())

    def test_user_cannot_delete_others_click_via_ajax(self):
        click_u2 = ImageClick.objects.create(image=self.image_u2, user=self.user2, x=5, y=5)
        self.client.login(username=self.user1_data['username'], password=self.user1_data['password'])
        delete_data = {'id': click_u2.id}
        response = self.client.post(reverse('delete_click'), delete_data, format='json')
        
        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)
        self.assertTrue(ImageClick.objects.filter(id=click_u2.id).exists())

class APITests(BaseSetupTestCase):

    def setUp(self):
        super().setUp()
        self.user1_token = Token.objects.get(user=self.user1)
        self.user2_token = Token.objects.get(user=self.user2)
        self.client.credentials(HTTP_AUTHORIZATION=f'Token {self.user1_token.key}')

    def test_api_list_images_requires_authentication(self):
        self.client.credentials()
        response = self.client.get(reverse('userimage-list'))
        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)

    def test_api_list_images_returns_only_own_images(self):
        response = self.client.get(reverse('userimage-list'))
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data), UserImage.objects.filter(user=self.user1).count())
        self.assertEqual(response.data[0]['name'], self.image_u1.name)
        for item in response.data:
            self.assertNotEqual(item['name'], self.image_u2.name)

    def test_api_create_image(self):
        initial_count = UserImage.objects.filter(user=self.user1).count()
        image_file = create_test_image_file("api_upload.gif", ext="gif")
        unique_name = f"API Test Image {self.user1.username} {uuid.uuid4().hex}"
        data = {'name': unique_name, 'image': image_file}
        
        response = self.client.post(reverse('userimage-list'), data, format='multipart')
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertEqual(UserImage.objects.filter(user=self.user1).count(), initial_count + 1)
        self.assertEqual(response.data['name'], unique_name)
        self.assertEqual(response.data['user'], self.user1.id)

    def test_api_retrieve_own_image_detail(self):
        response = self.client.get(reverse('userimage-detail', args=[self.image_u1.id]))
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['name'], self.image_u1.name)

    def test_api_cannot_retrieve_others_image_detail(self):
        response = self.client.get(reverse('userimage-detail', args=[self.image_u2.id]))
        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)

    def test_api_delete_own_image(self):
        image_to_delete = UserImage.objects.create(user=self.user1, name="to_delete_api", image=create_test_image_file())
        response = self.client.delete(reverse('userimage-detail', args=[image_to_delete.id]))
        self.assertEqual(response.status_code, status.HTTP_204_NO_CONTENT)
        self.assertFalse(UserImage.objects.filter(id=image_to_delete.id).exists())

    def test_api_cannot_delete_others_image(self):
        response = self.client.delete(reverse('userimage-detail', args=[self.image_u2.id]))
        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)
        self.assertTrue(UserImage.objects.filter(id=self.image_u2.id).exists())

    def test_api_create_image_invalid_data(self):
        data = {'name': ''}
        response = self.client.post(reverse('userimage-list'), data, format='json')
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertIn('image', response.data)
        self.assertIn('name', response.data)

    def test_api_list_clicks_returns_only_own_clicks(self):
        ImageClick.objects.create(image=self.image_u2, user=self.user2, x=1, y=1)
        response = self.client.get(reverse('imageclick-list'))
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data), ImageClick.objects.filter(user=self.user1).count())
        self.assertEqual(response.data[0]['id'], self.click_u1_img_u1.id)

    def test_api_create_click_on_own_image(self):
        initial_count = ImageClick.objects.filter(user=self.user1).count()
        data = {
            'image': self.image_u1.id,
            'x': 55.0,
            'y': 65.0
        }
        response = self.client.post(reverse('imageclick-list'), data, format='json')
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertEqual(ImageClick.objects.filter(user=self.user1).count(), initial_count + 1)
        self.assertEqual(response.data['x'], 55.0)
        self.assertEqual(response.data['user'], self.user1.id)

    def test_api_delete_own_click(self):
        click_to_delete = ImageClick.objects.create(image=self.image_u1, user=self.user1, x=1, y=1)
        response = self.client.delete(reverse('imageclick-detail', args=[click_to_delete.id]))
        self.assertEqual(response.status_code, status.HTTP_204_NO_CONTENT)
        self.assertFalse(ImageClick.objects.filter(id=click_to_delete.id).exists())

    def test_api_cannot_delete_others_click(self):
        click_u2 = ImageClick.objects.create(image=self.image_u2, user=self.user2, x=1, y=1)
        response = self.client.delete(reverse('imageclick-detail', args=[click_u2.id]))
        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)
        self.assertTrue(ImageClick.objects.filter(id=click_u2.id).exists())

===== File: ./main/urls.py =====
# main/urls.py
from django.urls import path, include
# from django.conf import settings # Not needed here if MEDIA_URL is handled at project level
# from django.conf.urls.static import static # Not needed here
# from django.contrib.auth import views as auth_views # Auth views usually at project level
from rest_framework.routers import DefaultRouter
from . import views

router = DefaultRouter()
router.register(r'images', views.UserImageViewSet)
router.register(r'clicks', views.ImageClickViewSet)

# Keep app_name if you use it for these non-board URLs, or remove if not needed.
# app_name = 'main' # Example, if you namespace these

urlpatterns = [
    path('', views.home, name='home'),
    path('register/', views.register, name='register'),
    path('add-click/', views.add_click, name='add_click'),
    path('user-panel/', views.user_panel, name='user_panel'),
    path('delete-click/', views.delete_click, name='delete_click'),
    path('record-click/', views.record_click, name='record_click'),
    path('update-click/', views.update_click, name='update_click'),
    path('upload-image/', views.upload_image, name='upload_image'),
    path('change-password/', views.change_password, name='change_password'),
    path('delete/<int:image_id>/', views.delete_image, name='delete_image'),
    path('use-common-image/<int:common_image_id>/', views.use_common_image, name='use_common_image'),
    path('upload-common-image/', views.upload_common_image, name='upload_common_image'),
    path('stream/', views.sse_notifications_view, name='sse_stream'),
    path('', include(router.urls)), # For your DRF viewsets
    # REMOVE THE FOLLOWING BOARD URLS FROM HERE:
    # path('define-grid/', views.define_grid, name='define_grid'), # Ensure this view exists if uncommented
    # path('create/', views.board_editor_view, name='board_create'),
    # path('<int:board_id>/edit/', views.board_editor_view, name='board_edit'),
    # path('<int:board_id>/delete/', views.board_delete_view, name='board_delete'),
    # path('api/save_board/', views.save_board_api_view, name='save_board_api'),
    # path('api/board/<int:board_id>/', views.get_board_data_api_view, name='get_board_data_api'),
]

# urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT) # Usually handled at project level

===== File: ./main/urls_board.py =====
# main/urls_board.py
from django.urls import path
from . import views # Assuming your board views are in main/views.py

app_name = 'game_board' # You can keep this namespace if you like, or change it

urlpatterns = [
    path('', views.board_list_view, name='board_list'), # Assuming this view exists in main.views
    path('create/', views.board_editor_view, name='board_create'),
    path('events/', views.sse_notifications_view, name='sse_board_events'),
    path('<int:board_id>/edit/', views.board_editor_view, name='board_edit'),
    path('<int:board_id>/delete/', views.board_delete_view, name='board_delete'),
    # API endpoint
    path('api/save_board/', views.save_board_api_view, name='save_board_api'),
    path('api/board/<int:board_id>/', views.get_board_data_api_view, name='get_board_data_api'),
]

===== File: ./main/event_queue.py =====
# main/event_queue.py
import queue
import threading
import json
import uuid

_client_queues = {}  # Dictionary: {client_id: queue.Queue}
_client_queues_lock = threading.Lock()

def add_client_queue():
    client_id = str(uuid.uuid4())
    q = queue.Queue(maxsize=100)
    with _client_queues_lock:
        _client_queues[client_id] = q
    print(f"SSE [event_queue]: Client queue added (ID: {client_id}). Total queues: {len(_client_queues)}")
    return client_id, q

def remove_client_queue(client_id: str):
    with _client_queues_lock:
        if client_id in _client_queues:
            del _client_queues[client_id]
            print(f"SSE [event_queue]: Client queue removed (ID: {client_id}). Total queues: {len(_client_queues)}")
        else:
            print(f"SSE [event_queue]: Attempted to remove non-existent client queue (ID: {client_id}).")

def broadcast_event(event_type: str, data: dict):
    if not isinstance(event_type, str) or not isinstance(data, dict):
        print(f"SSE [event_queue] ERROR: Invalid event_type or data for broadcast. Type: {event_type}, Data: {data}")
        return

    sse_formatted_message = f"event: {event_type}\ndata: {json.dumps(data)}\n\n"
    print(f"SSE [event_queue]: Broadcasting event - Type: {event_type}, Data: {json.dumps(data)}")

    current_client_ids = []
    with _client_queues_lock:
        current_client_ids = list(_client_queues.keys())

    if not current_client_ids:
        print("SSE [event_queue]: No active client queues to broadcast to.")
        return

    print(f"SSE [event_queue]: Number of client queues to broadcast to: {len(current_client_ids)}")

    for client_id in current_client_ids:
        with _client_queues_lock:
            q = _client_queues.get(client_id)
        
        if q:
            try:
                print(f"SSE [event_queue]: Attempting to put message in queue for client_id: {client_id}")
                q.put_nowait(sse_formatted_message)
                print(f"SSE [event_queue]: Message put in queue for client_id: {client_id} successfully")
            except queue.Full:
                print(f"SSE [event_queue] WARNING: Client queue full for event '{event_type}' (Client ID: {client_id}). Message dropped for this client.")
            except Exception as e:
                print(f"SSE [event_queue] ERROR: Failed to put message in queue for client_id {client_id}: {e}")
        else:
            print(f"SSE [event_queue] WARNING: Queue for client_id {client_id} not found during broadcast (race condition?).")

===== File: ./main/serializers.py =====
from rest_framework import serializers
from .models import UserImage, ImageClick

class ImageClickSerializer(serializers.ModelSerializer):
    class Meta:
        model = ImageClick
        fields = ['id', 'user', 'x', 'y', 'image']

class UserImageSerializer(serializers.ModelSerializer):
    clicks = ImageClickSerializer(many=True, read_only=True)
    user = serializers.PrimaryKeyRelatedField(read_only=True)
    def get_queryset(self):
        # ðŸ” Zwracaj tylko obrazy danego uÅ¼ytkownika
        return UserImage.objects.filter(user=self.request.user)

    def perform_create(self, serializer):
        # ðŸ” Ustaw wÅ‚aÅ›ciciela obrazu automatycznie
        serializer.save(user=self.request.user)
    class Meta:
        model = UserImage
        fields = ['id', 'user', 'name', 'image', 'clicks']


===== File: ./main/views.py =====
# main/views.py
from django.contrib.auth.decorators import login_required
from django.contrib.auth.forms import UserCreationForm, PasswordChangeForm
from django.contrib.auth import login, logout, update_session_auth_hash
from django.shortcuts import render, redirect, get_object_or_404
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from django.core.files.base import ContentFile
from django.db import transaction 
from django.conf import settings
from django.core.exceptions import ValidationError
from django.core.files.base import ContentFile
from django.contrib.contenttypes.models import ContentType
from django.views.decorators.http import require_POST
from django.http import StreamingHttpResponse
from rest_framework import viewsets, serializers
from rest_framework.permissions import IsAuthenticated
from PIL import Image as PILImage, ImageDraw, ImageFont # Dodaj ImageFont, jeÅ›li chcesz numery
from .models import ImageClick, UserImage, CommonImage, Reaction, GameBoard, UserImage # Dodaj Reaction
from .serializers import UserImageSerializer, ImageClickSerializer
from .forms import UserImageForm, CommonImageUploadForm 
from .permissions import IsOwner
from .forms import DefineGridForm
from .event_queue import add_client_queue, remove_client_queue
import json
import io
import base64
import re
import time
import queue # For queue.Queue and queue.Empty

@login_required
@require_POST # Reakcje to tworzenie danych
def add_reaction_view(request):
    try:
        data = json.loads(request.body.decode('utf-8'))
        object_type_str = data.get('object_type') # np. 'gameboard' lub 'userimage'
        object_id = data.get('object_id')
        reaction_type_key = data.get('reaction_type') # np. 'heart', 'gasp', 'grin'
    except json.JSONDecodeError:
        return JsonResponse({'status': 'error', 'message': 'Invalid JSON.'}, status=400)

    if not all([object_type_str, object_id, reaction_type_key]):
        return JsonResponse({'status': 'error', 'message': 'Missing required data.'}, status=400)

    # Mapowanie stringu object_type na model Django
    if object_type_str == 'gameboard':
        model = GameBoard
    elif object_type_str == 'userimage':
        model = UserImage
    # Dodaj inne modele, jeÅ›li chcesz na nich reagowaÄ‡
    else:
        return JsonResponse({'status': 'error', 'message': 'Invalid object type.'}, status=400)

    try:
        content_object_instance = model.objects.get(pk=object_id)
        content_type_instance = ContentType.objects.get_for_model(content_object_instance)
    except model.DoesNotExist:
        return JsonResponse({'status': 'error', 'message': 'Object not found.'}, status=404)
    except Exception as e:
        return JsonResponse({'status': 'error', 'message': f'Error fetching object: {str(e)}'}, status=500)

    # Sprawdzenie, czy reaction_type jest prawidÅ‚owy
    valid_reaction_types = [choice[0] for choice in Reaction.REACTION_CHOICES]
    if reaction_type_key not in valid_reaction_types:
        return JsonResponse({'status': 'error', 'message': 'Invalid reaction type.'}, status=400)

    # Logika "jedna reakcja na obiekt od uÅ¼ytkownika"
    # JeÅ›li chcesz pozwoliÄ‡ na zmianÄ™ reakcji, to:
    # 1. SprÃ³buj pobraÄ‡ istniejÄ…cÄ… reakcjÄ™.
    # 2. JeÅ›li istnieje i jest inna, zaktualizuj jÄ….
    # 3. JeÅ›li istnieje i jest taka sama, moÅ¼esz jÄ… usunÄ…Ä‡ (toggle) lub nic nie robiÄ‡.
    # 4. JeÅ›li nie istnieje, utwÃ³rz nowÄ….

    # Uproszczona logika: usuÅ„ poprzedniÄ… reakcjÄ™ uÅ¼ytkownika na ten obiekt (jeÅ›li istnieje) i dodaj nowÄ….
    # To efektywnie pozwala zmieniÄ‡ reakcjÄ™.
    Reaction.objects.filter(
        user=request.user,
        content_type=content_type_instance,
        object_id=content_object_instance.pk
    ).delete()

    try:
        reaction = Reaction.objects.create(
            user=request.user,
            reaction_type=reaction_type_key,
            content_type=content_type_instance,
            object_id=content_object_instance.pk
        )
        
        # Po pomyÅ›lnym zapisaniu reakcji, wyÅ›lij zdarzenie SSE
        # Potrzebujemy informacji o obiekcie, na ktÃ³ry zareagowano
        reacted_object_name = ""
        if isinstance(content_object_instance, GameBoard):
            reacted_object_name = content_object_instance.name
        elif isinstance(content_object_instance, UserImage):
            reacted_object_name = content_object_instance.name
        
        # Zdarzenie SSE o nowej reakcji
        # (logika broadcast_event jest w main/event_queue.py)
        from .event_queue import broadcast_event # Upewnij siÄ™, Å¼e ten import jest dostÄ™pny
        broadcast_event(
            event_type="newReaction",
            data={
                "reaction_id": reaction.id,
                "reaction_type": reaction.reaction_type, # klucz np. 'heart'
                "reaction_display": reaction.get_reaction_type_display(), # emotka np. 'â¤ï¸'
                "user_username": request.user.username,
                "object_type": object_type_str,
                "object_id": content_object_instance.pk,
                "object_name": reacted_object_name
            }
        )

        return JsonResponse({
            'status': 'success',
            'message': 'Reaction added.',
            'reaction_id': reaction.id,
            'reaction_type': reaction.reaction_type
        })
    except Exception as e: # Np. bÅ‚Ä…d unikalnoÅ›ci, jeÅ›li nie usuwasz starej reakcji
        return JsonResponse({'status': 'error', 'message': f'Could not save reaction: {str(e)}'}, status=400)

# @login_required # Odkomentuj, jeÅ›li chcesz autoryzacji
def sse_notifications_view(request):
    client_id, client_q = add_client_queue()
    print(f"SSE VIEW: Client connected (ID: {client_id}) from {request.META.get('REMOTE_ADDR')}")

    def event_stream_generator(client_id_for_generator, queue_for_generator):
        print(f"SSE VIEW [Generator]: Started for client ID: {client_id_for_generator}")
        try:
            yield ":sse-connection-established client_id={}\n\n".format(client_id_for_generator)
            last_keep_alive = time.time()

            while True:
                current_time = time.time()
                if current_time - last_keep_alive > 15:
                    yield ":keep-alive\n\n"
                    last_keep_alive = current_time

                try:
                    message = queue_for_generator.get(timeout=1) 
                    yield message
                    queue_for_generator.task_done()
                except queue.Empty:
                    continue
                except Exception as e_inner_q:
                    print(f"SSE VIEW [Generator] ERROR (queue get) for client ID {client_id_for_generator}: {e_inner_q}")
                    break 

        except GeneratorExit:
            print(f"SSE VIEW [Generator]: Client ID {client_id_for_generator} disconnected (GeneratorExit).")
        except Exception as e_outer_gen:
            print(f"SSE VIEW [Generator] ERROR (outer) for client ID {client_id_for_generator}: {e_outer_gen}")
        finally:
            print(f"SSE VIEW [Generator]: Cleaning up for client ID: {client_id_for_generator}.")
            remove_client_queue(client_id_for_generator)

    response = StreamingHttpResponse(event_stream_generator(client_id, client_q), content_type='text/event-stream')
    response['Cache-Control'] = 'no-cache, no-store, must-revalidate'
    response['Pragma'] = 'no-cache'
    response['Expires'] = '0'
    response['X-Accel-Buffering'] = 'no'
    return response

@login_required
@require_POST # Ensure this view only accepts POST requests
def save_grid_as_image_view(request):
    try:
        data = json.loads(request.body.decode('utf-8'))
    except json.JSONDecodeError:
        return JsonResponse({'status': 'error', 'message': 'Invalid JSON.'}, status=400)

    image_data_url = data.get('image_data_url')
    image_name = data.get('name', 'Generated Grid Image')
    filename = data.get('filename', 'grid_image.png')

    if not image_data_url:
        return JsonResponse({'status': 'error', 'message': 'Missing image data URL.'}, status=400)

    try:
        # Decode the base64 data URL
        # format: data:[<mime_type>][;base64],<data>
        header, encoded_data = image_data_url.split(',', 1)
        # mime_type = header.split(';')[0].split(':')[1] # e.g. image/png

        # Basic validation for filename (you might want more robust sanitization)
        safe_filename = re.sub(r'[^\w\.\-]', '_', filename)

        image_data_binary = base64.b64decode(encoded_data)
        image_content_file = ContentFile(image_data_binary, name=safe_filename)

        # Create a UserImage instance (or your equivalent model for path editing backgrounds)
        # Ensure unique name if your UserImage.name must be unique
        unique_image_name = image_name
        counter = 1
        while UserImage.objects.filter(user=request.user, name=unique_image_name).exists():
            unique_image_name = f"{image_name}_{counter}"
            counter += 1
        
        user_image = UserImage(user=request.user, name=unique_image_name)
        user_image.image.save(safe_filename, image_content_file, save=True) # save=True will commit to DB

        return JsonResponse({
            'status': 'success',
            'message': 'Grid image saved successfully.',
            'image_id': user_image.id,
            'image_name': user_image.name,
            'image_url': user_image.image.url
        })

    except (TypeError, ValueError) as e: # Catch base64 decoding errors
        return JsonResponse({'status': 'error', 'message': f'Invalid image data format: {str(e)}'}, status=400)
    except Exception as e:
        # Log the exception e
        return JsonResponse({'status': 'error', 'message': f'An unexpected error occurred: {str(e)}'}, status=500)

@login_required
def board_list_view(request):
    boards = GameBoard.objects.filter(user=request.user).order_by('-id')
    return render(request, 'game_board/board_list.html', {'boards': boards})

@login_required
def board_editor_view(request, board_id=None):
    board_instance = None
    initial_board_data_json = "null" # Default for new board

    if board_id:
        board_instance = get_object_or_404(GameBoard, pk=board_id, user=request.user)
        initial_board_data = {
            "id": board_instance.id,
            "name": board_instance.name,
            "rows": board_instance.rows,
            "cols": board_instance.cols,
            "dots_config": board_instance.dots_config
        }
        initial_board_data_json = json.dumps(initial_board_data)


    # This view primarily serves the HTML structure.
    # The actual board creation/editing logic happens via API calls from TypeScript.
    # However, you might pre-populate some form fields if editing.
    context = {
        'board_instance': board_instance,
        'initial_board_data_json': initial_board_data_json,
    }
    return render(request, 'game_board/board_editor.html', context)


@login_required
@require_POST # Ensures this view only accepts POST requests
def save_board_api_view(request):
    try:
        data = json.loads(request.body.decode('utf-8'))
    except json.JSONDecodeError:
        return JsonResponse({'status': 'error', 'message': 'Invalid JSON'}, status=400)

    board_id = data.get('id')
    name = data.get('name', 'Untitled Board')
    rows = data.get('rows')
    cols = data.get('cols')
    dots_config = data.get('dots_config', [])

    if not all([name, isinstance(rows, int), isinstance(cols, int), isinstance(dots_config, list)]):
        return JsonResponse({'status': 'error', 'message': 'Missing or invalid data fields.'}, status=400)

    try:
        if board_id:
            # Update existing board
            board = get_object_or_404(GameBoard, pk=board_id, user=request.user)
            board.name = name
            board.rows = rows
            board.cols = cols
            board.dots_config = dots_config
            board.save() # This will call full_clean()
            return JsonResponse({'status': 'success', 'message': 'Board updated successfully.', 'board_id': board.id})
        else:
            # Create new board
            board = GameBoard(user=request.user, name=name, rows=rows, cols=cols, dots_config=dots_config)
            board.save() # This will call full_clean()
            return JsonResponse({'status': 'success', 'message': 'Board created successfully.', 'board_id': board.id}, status=201)
    except ValidationError as e:
        return JsonResponse({'status': 'error', 'message': 'Validation Error', 'errors': e.message_dict}, status=400)
    except Exception as e:
        # Log the exception e
        return JsonResponse({'status': 'error', 'message': f'An unexpected error occurred: {str(e)}'}, status=500)


@login_required
def get_board_data_api_view(request, board_id):
    board = get_object_or_404(GameBoard, pk=board_id, user=request.user)
    data = {
        "id": board.id,
        "name": board.name,
        "rows": board.rows,
        "cols": board.cols,
        "dots_config": board.dots_config
    }
    return JsonResponse(data)


@login_required
@require_POST # Use POST for destructive actions
def board_delete_view(request, board_id):
    board = get_object_or_404(GameBoard, pk=board_id, user=request.user)
    board.delete()
    # If called via AJAX, return JSON. If via form, redirect.
    if request.headers.get('x-requested-with') == 'XMLHttpRequest':
        return JsonResponse({'status': 'success', 'message': 'Board deleted successfully.'})
    return redirect('game_board:board_list')

class UserImageViewSet(viewsets.ModelViewSet):
    queryset = UserImage.objects.all()  # Add this back
    serializer_class = UserImageSerializer
    permission_classes = [IsAuthenticated, IsOwner]

    def get_queryset(self):
        user = self.request.user
        if user.is_authenticated:
            return UserImage.objects.filter(user=user)
        return UserImage.objects.none() 
    
    def perform_create(self, serializer):
        serializer.save(user=self.request.user)

class ImageClickViewSet(viewsets.ModelViewSet):
    queryset = ImageClick.objects.all()  # Add this back
    serializer_class = ImageClickSerializer
    permission_classes = [IsAuthenticated, IsOwner]

    def get_queryset(self):
        user = self.request.user
        if user.is_authenticated:
            return ImageClick.objects.filter(user=user)
        return ImageClick.objects.none() # Or handle unauthenticated access

    def perform_create(self, serializer):
        image_instance = serializer.validated_data.get('image')
        if image_instance.user != self.request.user:
            raise serializers.ValidationError("You can only add clicks to your own images.")
        serializer.save(user=self.request.user, image=image_instance)

    def perform_update(self, serializer):
        if 'image' in serializer.validated_data:
            image_instance = serializer.validated_data.get('image')
            if image_instance.user != self.request.user:
                raise serializers.ValidationError("You can only associate clicks with your own images.")
        serializer.save()


@csrf_exempt
@login_required
def add_click(request):
    if request.method == "POST":
        data = json.loads(request.body)
        image_id = data['image_id']
        x = float(data['x'])
        y = float(data['y'])

        image = get_object_or_404(UserImage, id=image_id, user=request.user)
        click = ImageClick.objects.create(image=image, user=request.user, x=x, y=y)

        return JsonResponse({
            'success': True,
            'click_id': click.id
        })
    return JsonResponse({'success': False})

@csrf_exempt
@login_required
def delete_click(request):
    if request.method == 'POST':
        data = json.loads(request.body)
        try:
            click = ImageClick.objects.get(id=data['id'], user=request.user)
            click.delete()
            return JsonResponse({'status': 'deleted'})
        except ImageClick.DoesNotExist:
            return JsonResponse({'status': 'not found'}, status=404)

@csrf_exempt
@login_required
def update_click(request):
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            click = ImageClick.objects.get(id=data['id'], user=request.user) # Check ownership
            
            click.x = data['x']
            click.y = data['y']
            click.save()
            return JsonResponse({'status': 'success'})
        except ImageClick.DoesNotExist:
            return JsonResponse({'status': 'not found or forbidden'}, status=404)
        except Exception as e:
            return JsonResponse({'status': 'error', 'message': str(e)})
    return JsonResponse({'status': 'invalid request'}, status=400)

@login_required
def record_click(request):
    if request.method == "POST":
        image_id = request.POST.get('image_id')
        x = request.POST.get('x')
        y = request.POST.get('y')

        image = get_object_or_404(UserImage, id=image_id, user=request.user)
        click = ImageClick.objects.create(image=image, user=request.user, x=x, y=y) # Assign current user
        return JsonResponse({'status': 'ok'})

    return JsonResponse({'status': 'error'}, status=400)

@login_required
@transaction.atomic # Ensures that if any part fails, the whole operation is rolled back
def use_common_image(request, common_image_id):
    common_image = get_object_or_404(CommonImage, id=common_image_id)
    
    new_image_name_base = common_image.name
    new_image_name = new_image_name_base
    counter = 1
    while UserImage.objects.filter(user=request.user, name=new_image_name).exists():
        new_image_name = f"{new_image_name_base}_{counter}"
        counter += 1

    user_image = UserImage(
        user=request.user,
        name=new_image_name
    )

    try:
        with open(common_image.image.path, 'rb') as f:
            image_content = ContentFile(f.read(), name=common_image.image.name.split('/')[-1]) # Get original filename
            user_image.image.save(image_content.name, image_content, save=True) # Save the file to UserImage
        
        return redirect(f"{settings.LOGIN_REDIRECT_URL}?selected={user_image.name}")
    except IOError as e:
        print(f"Error copying common image file: {e}") # Log this properly
        return redirect('home') # Or wherever appropriate

@login_required
def home(request):
    user_images_list = UserImage.objects.filter(user=request.user) # Ensure this is the variable name
    common_images_list = CommonImage.objects.all()
    selected = request.GET.get('selected')
    selected_image = user_images_list.filter(name=selected).first() if selected else None
    return render(request, 'main/home.html', {
        'user_images': user_images_list,
        'common_images_list': common_images_list,   
        'selected_image': selected_image,
    })

def register(request):
    if request.method == 'POST':
        form = UserCreationForm(request.POST)
        if form.is_valid():
            user = form.save()
            login(request, user)
            return redirect('/')
    else:
        form = UserCreationForm()
    return render(request, 'main/register.html', {'form': form})

@login_required
def upload_image(request):
    if request.method == 'POST':
        form = UserImageForm(request.POST, request.FILES)
        if form.is_valid():
            user_image = form.save(commit=False)
            user_image.user = request.user
            user_image.save()
            return redirect('home')
    else:
        form = UserImageForm()
    return render(request, 'main/upload_image.html', {'form': form})

@login_required
def upload_common_image(request):
    if request.method == 'POST':
        form = CommonImageUploadForm(request.POST, request.FILES)
        if form.is_valid():
            common_image = form.save(commit=False)
            common_image.save()
            return redirect('home') # Or to a page showing common images
    else:
        form = CommonImageUploadForm()
    return render(request, 'main/upload_common_image.html', {'form': form})

@login_required
def user_panel(request):
    images = UserImage.objects.filter(user=request.user)
    if request.method == 'POST':
        image_id_to_update = request.POST.get('image_id_for_rename') # Assuming a distinct field name for clarity
        if image_id_to_update:
            image_instance = get_object_or_404(UserImage, id=image_id_to_update, user=request.user)
            form = UserImageForm(request.POST, request.FILES, instance=image_instance)
        else:
            form = UserImageForm(request.POST, request.FILES)
        
        if form.is_valid():
            image = form.save(commit=False)
            image.user = request.user
            image.save()
            return redirect('user_panel')
    else:
        form = UserImageForm() # Form for uploading a new image / or empty form for rename if not POST

    password_form = PasswordChangeForm(user=request.user)
    
    return render(request, 'main/user_panel.html', {
        'images': images,
        'upload_form': form, # Renamed for clarity in template if needed
        'password_form': password_form,
    })

@login_required
def change_password(request):
    if request.method == 'POST':
        password_form = PasswordChangeForm(user=request.user, data=request.POST)
        if password_form.is_valid():
            password_form.save()
            update_session_auth_hash(request, password_form.user)
            return redirect('user_panel')
    else:
        password_form = PasswordChangeForm(user=request.user)
    
    images = UserImage.objects.filter(user=request.user)
    upload_form = UserImageForm() # Or maintain state if it was a multi-purpose page
    return render(request, 'main/user_panel.html', {
        'images': images,
        'upload_form': upload_form,
        'password_form': password_form, # This will have errors
    })

@login_required
def delete_image(request, image_id):
    image = get_object_or_404(UserImage, id=image_id, user=request.user)
    image.image.delete()
    image.delete()
    return redirect('user_panel')

===== File: ./main/migrations/0001_initial.py =====
# Generated by Django 4.2.20 on 2025-06-08 16:07

from django.conf import settings
from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='CommonImage',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(help_text='Descriptive name for the common image.', max_length=100, unique=True)),
                ('image', models.ImageField(help_text='The actual image file.', upload_to='common_images/%Y/%m/%d/')),
                ('description', models.TextField(blank=True, help_text='Optional description.', null=True)),
            ],
            options={
                'verbose_name': 'Common Image',
                'ordering': ['name'],
            },
        ),
        migrations.CreateModel(
            name='UserImage',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=100, unique=True)),
                ('image', models.ImageField(upload_to='uploads/%Y/%m/%d/')),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='images', to=settings.AUTH_USER_MODEL)),
            ],
        ),
        migrations.CreateModel(
            name='ImageClick',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('x', models.FloatField()),
                ('y', models.FloatField()),
                ('image', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='clicks', to='main.userimage')),
                ('user', models.ForeignKey(default=1, on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),
            ],
        ),
        migrations.CreateModel(
            name='GameBoard',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(default='Untitled Board', max_length=100)),
                ('rows', models.PositiveIntegerField()),
                ('cols', models.PositiveIntegerField()),
                ('dots_config', models.JSONField(blank=True, default=list)),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='game_boards', to=settings.AUTH_USER_MODEL)),
            ],
        ),
    ]


===== File: ./main/migrations/__init__.py =====


===== File: ./main/__init__.py =====


===== File: ./main/apps.py =====
from django.apps import AppConfig

class MainConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'main'

    def ready(self):
        import main.models # Or 'import main.signals' if you put the signal handler there
        print("MainConfig.ready() called - Attempting to import signals...")
        try:
            import main.signals
            print("MainConfig.ready(): main.signals imported successfully.")
        except ImportError as e:
            print(f"MainConfig.ready() ERROR: Could not import main.signals - {e}")

# class GameBoardConfig(AppConfig):
#     default_auto_field = 'django.db.models.BigAutoField'
#     name = 'game_board'


===== File: ./manage.py =====
#!/usr/bin/env python
import os
import sys

if __name__ == "__main__":
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "login_required_project.settings")
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError("Couldn't import Django.") from exc
    execute_from_command_line(sys.argv)
